-- Adminer 3.7.1 MySQL dump

SET NAMES utf8;
SET foreign_key_checks = 0;
SET time_zone = '+02:00';
SET sql_mode = 'NO_AUTO_VALUE_ON_ZERO';

DROP TABLE IF EXISTS `mirror_posts`;
CREATE TABLE `mirror_posts` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` text NOT NULL,
  `slug` text NOT NULL,
  `body` text NOT NULL,
  PRIMARY KEY (`id`),
  FULLTEXT KEY `title_body` (`title`,`body`),
  FULLTEXT KEY `title` (`title`),
  FULLTEXT KEY `body` (`body`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

INSERT INTO `mirror_posts` (`id`, `title`, `slug`, `body`) VALUES
(2,	'Asymetrická šifra s veřejným klíčem',	'asymetricka-sifra-s-verejnym-klicem',	'O veřejné distribuci klíčů jsem již dříve psal. Pojďme se však podívat nejen na samotnou distribuci, ale i na myšlenku asymetrického šifrování. Prvně je však třeba vysvětlit několik důležitých věcí. Začněme tím, co vlastně znamená asymetrická šifra. Před myšlenkou asymetrického šifrování, jejíž autorem je Whitfield Diffie, se používalo výhradně šifrování symetrické, což znamená, že proces dešifrování zakódované zprávy je přesně opačný k procesu šifrování. Asymetrické šifrování však zavádí myšlenku použití jiného klíče na šifrování a jiného na dešifrování.\r\n\r\nJak to vyřešit? Jak je možné použít jiný klíč na šifrování a jiný na dešifrování? Již existoval koncept, který umožňoval výměnu  klíčů veřejně (a bezpečně). Stále byl však na principu synchronní komunikace odesílatele a příjemce, což nebylo optimální řešení a proto byl vymyšlen způsob jak tento problém obejít. Myšlenka byla jednoduchá. Příjemce musí vytvořit veřejný klíč, který následně zveřejní tak, aby byl veřejný opravdu pro všechny. V tomto případě je jasné, že by to nemělo smysl, pokud by se nepoužívala jednosměrná funkce šifrování, což je další pravidlo. A zároveň opět onen příjemce musí mít svůj tajný klíč, který dokáže informaci zašifrovanou veřejným klíčem dešifrovat. Z toho je patrná ta asymetričnost šifry. Nepoužívám stejný klíč na zašifrování a dešifrování jako u jiných šifer.\r\n\r\nTomuto systému se říká RSA (Ronald Riverst, Adi Shamir, Leonard Adleman). Pojďme se na něj teď podívat matematicky, protože teorie je moc obecná (a matematika zase složitá). Odesílatel zprávy si musí zvolit dvě velmi velká prvočísla (A, B). Tyto prvočísla mezi sebou vynásobí a dostane další ještě větší číslo (AB). Násobení je zcela triviální jednosměrná operace a systém RSA si zakládá na tom, že faktorizovat velké číslo je v reálním čase prakticky nemožné. Dále si odesílatel zvolí číslo C a to uveřejní společně s číslem AB. Toto jsou informace, které má každý k dispozici. Pro šifrování je nutné zprávu převést na číslo M (například binárně). Toto číslo se poté dosadí podle vzorce \"šifra\"= M^C (mod AB). Zpětně se pak informace dá velmi snadno dostat obráceným postupem se znalostí onoho součinu prvočísel zvolených na začátku. Bez znalosti těchto prvočísel je dešifrování téměř nemožné, což však také není úplně pravda viz poslední odstavec.\r\n\r\nJe zřejmé, že úspěch šifry spočívá ve zvolení dostatečně velkých prvočísel a mocnitele C, který by vzhledem k prvočíslům neměl mít žádného společného dělitele. Resp. přesněji čísla C a (A-1) * (B-1). Při představení RSA byl pro jeho reprezentaci uveřejněn zašifrovaný text s veřejným klíčem. Soutěžním úkolem bylo faktorizovat veřejný klíč na dvě složky a poté zprávu dešifrovat. Faktorizace trvala ve výsledku celkem 17 let, kdy tým 600 dobrovolníků oznámil 26. dubna 1994 činitele veřejného klíče. A jaký že byl ten klíč?\r\n\r\n/--code\r\nN = 114 381 625 757 888 867 669 235 779 976 146 612 010 218 296 721 242 362 562 561 842 935 706 935 245 733 897 830 597 123 563 958 705 058 989 075 147 599 290 026 879 543 541\r\n\\--\r\n\r\nDílčí prvočísla si nechám jako tajemství? (-:'),
(3,	'Lovec matematik',	'lovec-matematik',	'Znáte následující hádanku?\r\n\r\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Tam zastřelil medvěda. Jakou měl medvěd barvu?\r\n\r\nŘešení je více než jednoduché. Stačí si představit sférický trojúhelník vycházející ze severního pólu, který má všechny strany dlouhé 10 km (tedy každý úhel má 90°). Vzhledem k severnímu pólu je zřejmé, že medvěd musí být bílý. Existuje však ještě jiné řešení této hádanky čistě z geometrického (matematického chcete-li) hlediska? Vypusťme tedy medvěda a zamysleme se nad následující hádankou:\r\n\r\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Měl však smůlu a tak nic neulovil.\r\n\r\nJedno řešení už známe. Zamyslete se ještě jednou nad druhým řešením. Přesuňme se na jižní polokouli do libovolného bodu vzdáleného 11 591,55 m od jižního pólu. Pokud šel lovec nejprve 10 km na jih, dorazil do druhého bodu vzdáleného 1591,55 m od jižního pólu. Ze základní matematiky jistě všichni znají vzorec pro obvod kruhu O = 2&pi;r. Dosazením do vzorce zjistíme velmi zajímavou skutečnost. Obvod kruhu, tedy délka cesty na západ je dlouhá přibližně přesně 10 km. Lovec se tedy dostane na stejný bod vzdálený 1591,55 m od pólu a cestou na sever dojde do úplného začátku stejně tak jako tomu bylo při využití sférického trojúhelníku na opačné straně planety.\r\n\r\nPokud nebyl lovec matematik a neuvědomoval si tuto skutečnost, muselo být poměrně vyčerpávající dorazit po třiceti kilometrech do stejného místa...'),
(4,	'Tabulkový masakr',	'tabulkovy-masakr',	'Určitě znáte HTML a tím pádem znáte i tabulky. Pro jistotu připomenutí.\r\nTabulka se v HTML tvoří párovým tagem <code>&lt;table&gt;&lt;/table&gt;</code>, její řádky jsou <code>&lt;tr&gt;&lt;/tr&gt;</code> a buňky <code>&lt;td&gt;&lt;/td&gt;</code>. Buňky mají volitelné atributy <code>rowspan</code> a <code>colspan</code>. Tyto atributy určují, kolik bude buňka zabírat místa v řádce, resp. ve sloupci. Tyto znalosti stačí k pochopení pojmu \"tabulkový paradox\".\r\n\r\nPodívejte se na první ukázku:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\">A3</td>\r\n	</tr>\r\n	<tr>\r\n		<td colspan=\"3\">B1</td>\r\n	</tr>\r\n	<tr>\r\n		<td>C1</td>\r\n		<td>C3</td>\r\n	</tr>\r\n	<tr>\r\n		<td>D1</td>\r\n		<td>D3</td>\r\n	</tr>\r\n</table>\r\n\r\nZde je vidět co se stane, když roztáhneme buňku **A2** na tři řádky a zároveň roztáhneme buňku **B1** na tři sloupce podle následujícího kódu:\r\n/--code html\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\">A3</td>\r\n	</tr>\r\n	<tr>\r\n		<td colspan=\"3\">B1</td>\r\n	</tr>\r\n	<tr>\r\n		<td>C1</td>\r\n		<td>C3</td>\r\n	</tr>\r\n	<tr>\r\n		<td>D1</td>\r\n		<td>D3</td>\r\n	</tr>\r\n</table>\r\n\\--\r\nTam kde by měla být buňka **B2** vzniká krásné okénko do Narnie, které je společné jako pro druhý sloupec, tak pro druhý řádek.\r\n\r\nDůsledkem neopatrného zacházení se spojováním sloupců může být výsledek viditelný ve druhé ukázce:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\" colspan=\"4\">A3</td>\r\n		<td width=\"33%\" rowspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">B1</td>\r\n		<td width=\"33%\" rowspan=\"4\">B2</td>\r\n		<td width=\"33%\" colspan=\"4\">B3</td>\r\n		<td width=\"33%\" rowspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">C1</td>\r\n		<td width=\"33%\" rowspan=\"4\">C2</td>\r\n		<td width=\"33%\" colspan=\"4\">C3</td>\r\n		<td width=\"33%\" rowspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">D1</td>\r\n		<td width=\"33%\" rowspan=\"4\">D2</td>\r\n		<td width=\"33%\" colspan=\"4\">D3</td>\r\n		<td width=\"33%\" rowspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\n<br />\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">A1</td>\r\n		<td width=\"33%\" colspan=\"4\">A2</td>\r\n		<td width=\"33%\" rowspan=\"4\">A3</td>\r\n		<td width=\"33%\" colspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">B1</td>\r\n		<td width=\"33%\" colspan=\"4\">B2</td>\r\n		<td width=\"33%\" rowspan=\"4\">B3</td>\r\n		<td width=\"33%\" colspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">C1</td>\r\n		<td width=\"33%\" colspan=\"4\">C2</td>\r\n		<td width=\"33%\" rowspan=\"4\">C3</td>\r\n		<td width=\"33%\" colspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">D1</td>\r\n		<td width=\"33%\" colspan=\"4\">D2</td>\r\n		<td width=\"33%\" rowspan=\"4\">D3</td>\r\n		<td width=\"33%\" colspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\n<br />\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\" colspan=\"4\">A3</td>\r\n		<td width=\"33%\" colspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">B1</td>\r\n		<td width=\"33%\" colspan=\"4\">B2</td>\r\n		<td width=\"33%\" rowspan=\"4\">B3</td>\r\n		<td width=\"33%\" rowspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">C1</td>\r\n		<td width=\"33%\" rowspan=\"4\">C2</td>\r\n		<td width=\"33%\" colspan=\"4\">C3</td>\r\n		<td width=\"33%\" colspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">D1</td>\r\n		<td width=\"33%\" rowspan=\"4\">D2</td>\r\n		<td width=\"33%\" colspan=\"4\">D3</td>\r\n		<td width=\"33%\" colspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\nZa domácí úkol se pokuste napsat alespoň jednu podobnou tabulku bez nahlédnutí do zdrojového kódu... :-)\r\n\r\nA poslední perlička vyvracející tvrzení, že párový element <code>&lt;tr&gt;&lt;/tr&gt;</code> vytváří v tabulce novou řádku. Podívejte se na následující kód. Hádám, že už je vám jasné co se stane.\r\n/--code html\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\r\n</table>\r\n\\--\r\nVýsledek je vidět ve třetí ukázce:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\r\n</table>\r\n\r\nVyzkoušejte, že se tabulkový paradox vykresluje ve všech prohlížečích stejně. Mám to tedy chápat tak, že tolik oblíbený Chrome je stejný shit jako IE? Kdepak... Jedná se opravdu o paradox, který by sice měl (prapodivné) řešení((výsledek potlačující paradox, vyvolávající další spory)), ale pak by byl porušen význam některých atributů buňek tabulky.'),
(6,	'Výpočet mediánu',	'vypocet-medianu',	'Zadání\r\n======\r\n\r\nNajděte v dostupné literatuře nebo vymyslete co nejlepší algoritmus pro výpočet mediánu.\r\nNezapomeňte na citaci zdrojů. Kritéria kvality v sestupném pořadí jsou: výpočetní složitost, \r\njednoduchost a implementační nenáročnost, paměťová spotřeba.\r\n\r\nDefinice\r\n========\r\n\r\nMedián je hodnota, která dělí seřazenou posloupnost na dvě stejně velké (co se množství týče)\r\nčásti. Důležitou vlastností mediánu je skutečnost, že není ovlivněn žádnou extrémní hodnotou,\r\njako je tomu například u průměru.\r\n\r\nAnalýza problému\r\n================\r\n\r\nExistuje několik způsobů jak daný problém vyřešit. První řešení bude velmi přímočaré. Jedná se\r\ntotiž o způsob, který zřejmě napadne každého jako první.\r\n\r\nPřímočaré řešení\r\n----------------\r\n\r\nToto řešení vlastně ani není tak hledání mediánu jako hledání algoritmicky nejrychlejšího způsobu\r\njako seřadit danou posloupnost čísel, protože pokud již máme seřazenou posloupnost, stačí zvolit\r\nprostřední prvek a získáme požadovaný medián. Tento poslední krok můžeme přirozeně vykonat\r\nse složitostí O(1). Seřadit posloupnost je možné lineárně logaritmickou složitostí O(NlogN) avšak\r\ns dodatečnou pamětí. Dodatečné paměti je samozřejmě možné se vyhnout, například použitím\r\nřadicího algoritmu Quicksort, vystavujeme se však nebezpečí kvadratické složitosti v nejhorším\r\npřípadě.\r\n\r\nPři zpětném pohledu je jasné, že nejvíce času strávíme řazením posloupnosti. Přitom řazení\r\nnebylo v zadání. Je to opravdu nutné? Následující algoritmy uvažují vstupní neseřazenou posloupnost\r\nstejně jako přímočaré řešení, ale nebudou vynakládat všechen svůj drahocený čas k\r\nřazení.\r\n\r\nAlgoritmus FIND\r\n---------------\r\n\r\nMetoda FIND je mnohem promyšlenější. Využívá techniky \"rozděl a panuj\", což je samo o sobě\r\nvelmi silná zbraň. FIND se chová velmi podobně jako již zmíněný Quicksort (oba algoritmy vymyslel\r\nTony Hoare) s tím, že hledá k-té nejmenší číslo, což je pouze zobecnění problému hledání\r\nmediánu.\r\n\r\nPři hledání postupujeme tak, že neseřazenou posloupnost projíždíme zleva, dokud nenalezneme\r\nprvek, který je větší (nebo roven) než námi zvolený pivot. Poté projíždíme posloupnost\r\nzprava, dokud nenarazíme na prvek, který je menší (nebo roven) pivotu. V tuto chvíli máme k\r\ndispozici dva prvky, a oba jsou na špatné straně, takže je prohodíme. V procesu zkoumání výměn\r\npokračujeme tak dlouho, dokud se nestřetneme. Tím je zajištěno, že jsou menší prvky než pivot\r\numístěny na levé straně a prvky větší než pivot zase na pravé.\r\n\r\nTím však ještě není medián určen, protože pivot byl zvolen (například) náhodně. Můžou\r\ntotiž nastat tři případy. V nejideálnější situaci je opravdu pivot mediánem a celý proces hledání\r\nmůžeme úspěšně ukončit. Může se však stát, že pivot nebude uprostřed posloupnosti, tedy byl\r\nzvolen nešťastně a není mediánem. V tom případě musíme hledat (např. rekurzivně) medián v\r\nhorní, popř. dolní části posloupnosti v závislosti na umístění aktuálního pivota. Jinak řečeno pokud\r\nbyl pivot moc malý, upravíme spodní mez posloupnosti. Pokud byl pivot naopak velký,\r\nupravíme horní mez posloupnosti a cel ý postup opakujeme. Pokud je pivot \"tak akorát\", pak je\r\nnaším mediánem.\r\n\r\nOčekávaný čas metody FIND je 4n, je nutné však připomenout, že je celé hledání založeno na\r\nQuicksortu, takže může složitost klesnout do kvadratické třídy. Existuje však i lineární řešení viz\r\nnásledující odstavce.\r\n\r\nAlgoritmus SELECT\r\n-----------------\r\n\r\nSELECT je svým chováním velmi podobný metodě FIND, ale dokáže eliminovat problém se\r\nšpatným zvolením pivota. Postupuje se následovně. Nejdříve rozdělíme neseřazenou posloupnost\r\nna pět částí s tím, že jedna nemusí být úplná. Následně najdeme medián každé skupiny. Z\r\nnalezených mediánů najdeme jeden celkový medián. Zde se však nesmíme ukvapit a použít tento\r\nmedián jako výsledný. Zatím to totiž byl pouze poměrně spolehlivý odhad vhodného pivota pro\r\ndělení celé posloupnosti.\r\n\r\nOpět mohou nastat tři příklady tzn. pivot je rovnou mediánem, pivot je větší, nebo je pivot\r\nmenší než medián. Při neshodě pivota s mediánem voláme SELECT rekurzivně do té doby,\r\nnež dostaneme požadovaný prvek. Postup hledání se může zdát dost zamotaný a rekurze na\r\npřehlednosti nepřidává, nicméně tento algoritmus má složitost O(n).\r\n\r\nSrovnání zmíněných algoritmů\r\n============================\r\n\r\nHledání mediánu pomocí přímočaré metody vede k seřazení posloupnosti (což nebylo zadáno).\r\nKromě toho získáme nejlepší složitost O(NlogN), což nemusí být úplně špatné vzhledem k nejhor\r\nší složitosti Quicksortu O(n^2), ale spotřebujeme více paměti. Oproti tomu algoritmus FIND\r\nnezabere více paměti než je nutné, jeho složitost však může být také kvadratická. Jednoznačně\r\nnejlepší řešení se zdá být metoda vyhledávání SELECT, která nejenže nespotřebuje dodatečnou\r\npaměť, ale navíc si udržuje lineární složitost což je alespoň podle běžně dostupné literatury\r\nnejlepší možné řešení.\r\n\r\nZávěr\r\n=====\r\n\r\nNezáleží-li nám na složitosti, nebo paměťové náročnosti, zvolíme přímočarou metodu hledání\r\nmediánu, která je nejjednodužší na implementaci a pochopení. V opačném případě zvolíme algoritmus\r\nSELECT, který je sice složitý, ale má vynikající výsledky.'),
(7,	'Osm návrhových přikázání',	'osm-navrhovych-prikazani',	'Právě mám rozečtenou knihu, která popisuje návrhové vzory v PHP. Mimo jiné autor popisuje pravidla při návrhu softwaru, která jsou prokládána velkým množstvím ukázek a vysvětlivek. Celkem je na třiceti stranách knihy (kde je rozebírán návrh) schován následující seznam pravidel.\r\n\r\n1) Přístup k údajům vždy v rámci třídy zapouzdřete a poskytněte metody, pomocí nichž lze dané údaje získat.\r\n2) Svá rozhraní navrhujte tak, aby je bylo možné později rozšířit.\r\n3) V metodách tříd nezapouzdřujte jen údaje, ale také algoritmy, díky čemuž budou komplexní operace implementované centrálně na jednom místě.\r\n4) Znovupoužitelnost kódu je lepší než duplicitní kód.\r\n5) Vyvarujte se monolitickým strukturám a rozložte je na co nejmenší části, které mohou být implementované nezávisle na sobě. Pokud používáte rozsáhlé příkazy <code>if/elseif/else</code> nebo <code>switch</code>, popřemýšlejte, zda by se nedaly nahradit zaměnitelnými třídami.\r\n6) Dědění vede k neflexibilním strukturám. Na kombinaci různých funkcí používejte raději kompozice objektů.\r\n7) Vždy programujte vůči rozhraní, a nikdy ne vůči konkrétní implementaci.\r\n8) Vyhýbejte se těsným závislostem mezi jednotlivými třídami aplikace a vždy upřednostňujte volné vazby tříd.\r\n\r\nDalší seznam který všichni znají, ale málokdo ho úplně dodržuje. (-:'),
(9,	'Návrhový vzor Singleton',	'navrhovy-vzor-singleton',	'Návrhový vzor Singleton je velmi známý. Má za úkol zajistit, že bude z určité třídy existovat pouze jedna instance. K této instanci poskytne globální přístupový bod. Jednoduché zadání, ale samotná implementace může být v PHP zákeřná. Proč? Tak prvně záleží na tom, jak budeme u návrhu striktní.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n}\r\n\\--\r\n\r\nTakovouto třídu lze totiž rovnou prohlásit za návrhový vzor Singleton. Dává to smysl, protože můžeme zavolat:\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = Object::getInstance();\r\n\\--\r\n\r\nTím se pokusíme vytvořit dvě instance této třídy, ve skutečnosti se však vytvoří jen jedna. Tyto objekty jsou identické, což lze dokázat jednoduchou zkouškou:\r\n\r\n/--code php\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\'; //TRUE\r\n} else {\r\n	echo \'$obj1 !== $obj2\';\r\n}\r\n\\--\r\n\r\nSingleton to je a nikdo nemůže říct ne. Jak jsem však již psal, záleží na tom, jak budeme u návrhu striktní, protože by to nebylo PHP, kdyby neexistovalo několik otazníků a háčků. Pravděpodobně spoustu lidí totiž napadne, že metoda <code>getInstance()</code> je sice hezká, ale vůbec ji nemusím použít. V takovém případě celý princip Singletona padá.\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = new Object();\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nTo je jasné, zatím ve třídě neexistuje žádný mechanismus, který by zakázal používání konstruktoru. K tomu je potřeba pouze malá úprava třídy.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n}\r\n\\--\r\n\r\nV tento moment již nepůjde objekt vytvořit pomocí operátoru <code>new</code>. Případný pokus skončí fatální chybou. Nebylo by to však PHP, kdyby neexistovalo několik dalších otazníků a háčků. S ledovým klidem si totiž mohu první vytvořený objekt naklonovat a tím opět získám dvě nezávislé instance jedné třídy. Ale to jsem přece nechtěl!\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = clone $obj1;\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nProti tomuto postupu se mohu bránit opět podobným způsobem jako u konstruktoru.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	private function __clone() {}\r\n}\r\n\\--\r\n\r\nPokus o naklonování již vytvořené instance pomocí metody <code>getInstance()</code> skončí opět fatální chybou. Jenže nebylo by to PHP, kdyby... Co se stane, když vytoření objekt serializuji a pak ho zase deserializuji?\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = unserialize(serialize($obj1));\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nTo už začíná být poněkud otravné. Ale tak dobře, i to se dá ošéfovat.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	private function __clone() {}\r\n	private function __wakeup() {}\r\n}\r\n\\--\r\n\r\nToto už sice vrátí jen warning, ale víme o tom. Schválně jsem nepsal, že se to vše dá ošetřit, protože je to spíše zákaz (popř. upozornění). Je samozřejmě možné (lepší) vracet různé vyjímky atd. Stejně tak je spousta variant jak psát přítupové modifikátory k metodám. To jednoduše vše zaleží na tom, co od Singleton objektu očekáváme a kdo objekt používá, protože jak jsem již psal, úplně klidně stačí Singleton s jednou metodou <code>getInstance()</code>. Svoji funkci plní, tečka.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	public final function __clone() {\r\n		throw new Exception(\'Objekt nelze klonovat!\');\r\n	}\r\n	public final function __wakeup() {\r\n		throw new Exception(\'Objekt nelze deserializovat!\');\r\n	}\r\n}\r\n\\--'),
(10,	'Návrhový vzor Factory Method',	'navrhovy-vzor-factory-method',	'Návrhový vzor Factory Method má za úkol definovat rozhraní pro vytváření objektů s tím, že vlastní tvorbu instancí přenechává potomkům. Samotný návrhový vzor tedy tvoří například tyto dvě třídy.\r\n\r\n/--code php\r\n<?php\r\nabstract class ACreator {\r\n	protected $attribute;\r\n	public function __construct($attribute) {\r\n		$this->attribute = $attribute;\r\n	}\r\n	abstract public function createConcreteObject();\r\n}\r\n\\--\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteCreator extends ACreator {\r\n	public function createConcreteObject() {\r\n		$concreteObject = new ConcreteObject($this->attribute);\r\n		return $concreteObject;\r\n	}\r\n}\r\n\\--\r\n\r\nAby však tento vzor měl nějaký smysl, je potřeba ještě minimálně jedna třída od které se budou dělat instance (ConcreteObject).\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteObject implements IObject {\r\n	protected $attribute;\r\n	public function __construct($attribute) {\r\n		$this->attribute = $attribute;\r\n	}\r\n	public function test() {\r\n		echo $this->attribute;\r\n	}\r\n}\r\n\\--\r\n\r\nPřípadně jeho rozhraní:\r\n\r\n/--code php\r\n<?php\r\ninterface IObject {\r\n	public function test();\r\n}\r\n\\--\r\n\r\nVraťme se však na začátek. Vytvářet objekty všichni umí. Slouží k tomu známý operátor <code>new</code>. Na tom není nic divného, ale jen do chvíle, než se nad tím zamyslíte. Představte si rozsáhlou aplikaci, kde na každém rohu potřebujete vytvořit instanci určitého objektu. Takže jako vždy zavoláte operátor <code>new</code> a předáte všechny potřebné argumenty. A pak se to stane. Najednou zjistíte, že nutně potřebujete přidat do konstruktoru argument/y a máte týden co dělat. K tomu se právě hodí vytvořit si továrnu na tyto instance, kdy budeme pouze volat metodu pro její vytvoření, ale to jak se vytvoří necháme na továrně. Obecně se ve světě OOP velmi často dělá, že nějakou práci prostě necháme na někom jiném. Je to funkční a pohodlný přístup. :-)\r\n\r\nPokud tedy zapomenu na to, že existují nějaké třídy Creator, tak by použití třídy ConcreteObject vypadalo asi takto:\r\n\r\n/--code php\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance->test();\r\n\\--\r\n\r\nPři zapojení továrny je použití zdánlivě složitější.\r\n\r\n/--code php\r\n$factory = new ConcreteCreator(\'TEST\');\r\n$instance = $factory->createConcreteObject();\r\n$instance->test();\r\n\\--\r\n\r\nPřidaná hodnota tohoto postupu je však velká. Již nejsme vázání na konkrétní implementaci objektu ConcreteObject. Vlastně nás to vůbec nezajímá. Víme, že pro jeho tvorbu potřebuje továrna nějaký atribut a to, jestli pak ještě další tři přidá, nebo ne, nám může být úplně jedno. Kdo stále ještě nevěří, že je tento postup výhodný, nechť si vyzkouší vytvořit několik instancí stejného objektu (hloupý, ale názorný příklad).\r\n\r\n/--code php\r\n// pomocí operátoru new:\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n\r\n// pomocí továrny:\r\n$factory = new ConcreteCreator(\'TEST\');\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n\\--\r\n\r\nA teď přidejme nový atribut - aktuální rok.\r\n\r\n/--code php\r\n// pomocí operátoru new:\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n\r\n// pomocí továrny:\r\n$factory = new ConcreteCreator(\'TEST\', date(\'Y\'));\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n\\--\r\n\r\nKrom toho, že by mě za chvíli přestalo bavit do každého konstruktoru kopírovat nový atribut, tak jsem také mohl udělat o hodně více chyb než u továrny. Pravdou je, že jsem musel upravit ještě pár tříd:\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteObject implements IObject {\r\n	protected $attribute;\r\n	protected $year;\r\n	public function __construct($attribute, $year) {\r\n		$this->attribute = $attribute;\r\n		$this->year = $year;\r\n	}\r\n	// ...\r\n}\r\n\r\nabstract class ACreator {\r\n	protected $attribute;\r\n	protected $year;\r\n	public function __construct($attribute, $year) {\r\n		$this->attribute = $attribute;\r\n		$this->year = $year;\r\n	}\r\n	abstract public function createConcreteObject();\r\n}\r\n\r\nclass ConcreteCreator extends ACreator {\r\n	public function createConcreteObject() {\r\n		$concreteObject = new ConcreteObject($this->attribute, $this->year);\r\n		return $concreteObject;\r\n	}\r\n}\r\n\\--\r\n\r\nNicméně křivka výhod při používání továrny velmi rychle překoná svým stoupáním křivku lenosti při používání operátoru new.\r\n\r\nMimochodem vzpomeňte si na \"osm návrhových přikázání\":http://www.zeminem.cz/osm-navrhovych-prikazani, kde se také říká, že máme vždy programovat vůči rozhraní, a nikdy ne vůči konkrétní implementaci, což tento návrhový vzor perfektně splňuje.'),
(11,	'Nette 2.1-dev CliRouter',	'nette-2-1-dev-clirouter',	'Routování CLI((Command Line Interface)) aplikací je oblast, o které se v Nette moc nemluví. A když mluví, tak divně (nebo staře). Což na jednu stranu dává smysl, protože tato routa existuje už od roku 2009. Na druhou stranu je to zvláštní, protože je stále experimentální.\r\n\r\n> The unidirectional router for CLI.\r\n> \r\n> (experimental)\r\n\r\nDokonce se už mluvilo o tom, že se zruší. No snad se to nestane...\r\n\r\nProč o tom mluvím? Rád bych ukázal, jak se dá v nastávající verzi Nette tato routa použít. V nové verzi Nette se již routy nepíší do bootsrap.php jak tomu bylo (alespoň myslím) dříve. Tentokrát je v adresářové struktuře soubor router/**RouterFactory.php**, který se právě o routování postará. Tento soubor může vypadat například takto:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Nette,\r\n	Nette\\Application\\Routers\\RouteList,\r\n	Nette\\Application\\Routers\\Route,\r\n	Nette\\Application\\Routers\\CliRouter;\r\n\r\n/**\r\n * Router factory.\r\n */\r\nclass RouterFactory {\r\n\r\n	private $container;\r\n\r\n	public function __construct(Nette\\DI\\Container $container) {\r\n		$this->container = $container;\r\n	}\r\n\r\n	/**\r\n	 * @return \\Nette\\Application\\IRouter\r\n	 */\r\n	public function createRouter() {\r\n		$router = new RouteList();\r\n		if ($this->container->parameters[\'consoleMode\']) {\r\n			$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\r\n		} else {\r\n			$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\r\n			$router[] = new Route(\'user/<presenter>/<action>[/<id>]\', array(\r\n				\'module\' => \'User\',\r\n				\'presenter\' => \'Board\',\r\n				\'action\' => \'default\',\r\n			));\r\n			$router[] = new Route(\'<presenter>/<action>[/<id>]\', array(\r\n				\'module\' => \'Front\',\r\n				\'presenter\' => \'Homepage\',\r\n				\'action\' => \'default\',\r\n			));\r\n		}\r\n		return $router;\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nToto je reálná funkční ukázka (ze které jsem něco nepodstatného umazal). Jak je vidět, tak aplikaci mám rozdělenou na moduly, takže defaultní routa ukazuje do modulu Front, pak je k dispozici User modul, link na RSS a konečně CliRouter, který se naroutuje pouze v případě, že běží aplikace v konzolovém módu (CLI).\r\n\r\nPokud se teď přesunu k presenterové části modulu Cli, mohu zde umístit dvě třídy. Klasický BasePresenter, který bude pro jistotu kontrolovat, jestli se opravdu jedná o consoleMode například takto:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App\\CliModule;\r\n\r\nuse Nette;\r\n\r\nabstract class BasePresenter extends Nette\\Application\\UI\\Presenter {\r\n\r\n	public function startup() {\r\n		parent::startup();\r\n		if (!$this->context->parameters[\'consoleMode\']) {\r\n			throw new Nette\\Security\\AuthenticationException;\r\n		}\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nNo a pak už stačí jen CliPresenter, který bude dědit od BasePresenteru, takže vždy dojde ke kontrole. Zde stačí metoda action*(), která se spustí podle naroutování. V mém případě se tedy jedná o actionCron():\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App\\CliModule;\r\n\r\nuse Nette;\r\n\r\nclass CliPresenter extends BasePresenter {\r\n\r\n	public function actionCron() {\r\n		echo \'FUNGUJU!\';\r\n		$this->terminate();\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nA teď to nejdůležitější! Aplikace se spustí pomocí terminálu jednoduchým příkazem \"<code>php index.php</code>\". Samozřejmě je nutné ukázat na index Nette aplikace. No a samozřejmě se mohu odkázat i na jinou část aplikace dopsání parametru. Pokud bych chtěl podle výše uvedených souborů přejít na hlavní stránku, stačí napsat pouze \"<code>php index.php Fron:Homepage:default</code>\".'),
(54,	'AJAX upload souborů v Nette pomocí Fine Uploaderu',	'ajax-upload-souboru-v-nette-pomoci-fine-uploaderu',	'A je zde další ukázka vlastní práce, která se může hodit i někomu dalšímu. Tentokrát půjde o ajaxové\r\nnahrávání souborů v Nette pomocí \"Fine Uploaderu .{target:_blank}\":http://fineuploader.com/.\r\nObecně to není moc jednoduchá sranda, ale uvidíte, že to zase není taková věda...\r\n\r\nA jak už to tak dělávám, lepší než spoustu povídání je spousta ukázek. Prvně je potřeba nalinkovat\r\nsoubory Fine Uploaderu, nette.ajaxu a vlastního javascriptového souboru:\r\n\r\n/--code html\r\n<script src=\"{$basePath}/js/jquery.fineuploader-3.7.0.min.js\"></script>\r\n<script src=\"{$basePath}/js/nette.ajax.js\"></script>\r\n<script src=\"{$basePath}/js/main.js\"></script>\r\n\\--\r\n\r\nPoužití samotného Fine Uploaderu je nesmírně jednoduché. Nejdříve je třeba vytvořit element na který\r\nse uploader později zavěsí a případně tlačítko na upload, pokud nechceme soubory uploadovat rovnou:\r\n\r\n/--code html\r\n<div id=\"image-uploader\"{ifset $selected} data-id=\"{$selected}\"{/ifset}></div>\r\n<div id=\"triggerUpload\">Nahrát obrázky</div>\r\n\\--\r\n\r\nPřichází na řadu samotné oživení uploaderu pomocí javascriptu (soubor main.js):\r\n\r\n/--code javascript\r\n$(function () {\r\n	if ($(\'#image-uploader\').length != 0) { //test existence elementu\r\n		$.nette.ext(\'uploader\', {\r\n			complete: function () { //zavěšení na konec ajaxového požadavku\r\n				var uploader = $(\'#image-uploader\').fineUploader({\r\n					request: {\r\n						endpoint: \'product/default/\' + $(\'#image-uploader\').data(\'id\') + \'?do=upload\'\r\n					},\r\n					text: {\r\n						uploadButton: \'Klikněte, nebo Přetáhněte obrázky\',\r\n						cancelButton: \'zrušit\',\r\n						failUpload: \'Nahrání obrázku se nezdařilo\',\r\n						dragZone: \'Přetáhněte soubory sem\',\r\n						dropProcessing: \'Zpracovávám přetažené soubory...\',\r\n						formatProgress: \'{percent}% z {total_size}\',\r\n						waitingForResponse: \'Zpracovávám...\'\r\n					},\r\n					autoUpload: false,\r\n					failedUploadTextDisplay: {\r\n						mode: \'custom\',\r\n						maxChars: 70,\r\n						responseProperty: \'error\',\r\n						enableTooltip: true\r\n					}\r\n				});\r\n				$(\'#triggerUpload\').click(function () {\r\n					uploader.fineUploader(\'uploadStoredFiles\');\r\n				});\r\n			}\r\n		});\r\n	}\r\n\r\n	$.nette.init(); //inicializace nette.ajax\r\n});\r\n\\--\r\n\r\nProtože jsem v mém případě donačítal tento upload element ajaxově, musel jsem script pro uploader\r\nzavěsit na nette.ajax událost complete. Tato obálka se dá smazat a spouštět klasicky\r\npři události document.ready. Je zde spoustu, pro samotnou funkčnost, zbytečného kódu.\r\nPodstatný je pouze request:endpoint, který ukazuje na URL adresu aplikace, kde čeká Nette handle.\r\nTen může vypadat například takto:\r\n\r\n/--code php\r\npublic function handleUpload($id) {\r\n	$allowedExtensions = array(\"jpeg\", \"jpg\", \"png\", \"gif\"); //například pro obrázky\r\n	$uploader = new \\qqFileUploader($allowedExtensions);\r\n	//...\r\n	try {\r\n		$result = $uploader->handleUpload(__DIR__ . \'/../../../www/uploads/\' . $id . \'/default\', NULL);\r\n		$result[\'uploadName\'] = $uploader->getUploadName();\r\n		//...\r\n	} catch (\\Exception $exc) {\r\n		$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse(array(\r\n			\'error\' => $exc->getMessage(),\r\n		)));\r\n	}\r\n	$this->invalidateControl();\r\n	$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse($result));\r\n}\r\n\\--\r\n\r\nOpět jsem vypustil části, které nejsou úplně důležité pro samotnou funkčnost. Jde pouze o to mít\r\npřipravenou handle metodu, která převezme například ID, důležité však je, že spouští metodu handleUpload()\r\na odesílá JSON odpověď a to jak errorovou, tak normální, což je následně na straně klienta vyhodnoceno\r\njako úspěšný upload.\r\n\r\nV kódu je zmíněna také třída qqFileUploader. Tu naleznete například na \"GitHubu .{target:_blank}\":https://github.com/Widen/fine-uploader-server a nejenom pro PHP. Já jsem si tuto třídu obohatil pouze\r\no webalize názvů souborů.\r\n\r\nA to je vlastně úplně celé. Stačí tedy spustit Fine Uploader na straně klienta například\r\npodle oficiálních návodů, endpoint nastavit na nějaký handle v aplikaci a ten správně použit.\r\nTo konkrétně obnáší odeslání JSON odpovědi o úspěšném zpracování obrázku.'),
(44,	'Portál ZČU dočasně mimo provoz',	'portal-zcu-docasne-mimo-provoz',	'Zvolit správný titulek pro webovou stránku je naprosto klíčové.\r\nMnozí programátoři si to neuvědomují a ti ostatní chybují.\r\nTitulek je jedna z nejdůležitějších věcí, podle které se\r\nlidé rozhodují jestli na web vstoupit, nebo ne. Proto je třeba mít\r\n<code>title</code> tag na každé stránce jiný a je potřeba myslet\r\ni na stránky, které se zase až tak často nezobrazují.\r\nJe totiž docela smůla, když vás google bot indexuje během profylaxe\r\nserverů:\r\n\r\n[* http://www.zeminem.cz/img/pictures/portal.png *]\r\n\r\nWeb má poté odpuzující titulek, i když už dávno funguje.\r\nNutno však říct, že je to občas problém ohlídat.\r\nTak alespoň to pobaví... (-:'),
(45,	'Testování presenterů v Nette',	'testovani-presenteru-v-nette',	'Tak toto je přesně to téma o kterém se naustále mluví, ale tím to z velké části končí.\r\nNemá smysl zabývat se tím, jestli testovat, nebo ne. Na to už si každý přijde sám.\r\nV následujících odstavcích bych rád předvedl myšlenku jak si\r\nušetřit pár řádek kódu při testech (\\Nette\\Tester).\r\n\r\nNezbytná teorie\r\n===============\r\n\r\nPro testování presenterů je zapotřebí získat továrnu na presentery PresenterFactory\r\na následně daný presenter vyrobit. Například takto:\r\n\r\n/--code php\r\n$presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\r\n$this->presenter = $presenterFactory->createPresenter(\'Front:Homepage\');\r\n\\--\r\n\r\nK tomu je zapotřebí \\Nette\\DI\\Container, který získáme například v konstruktoru, nebo\r\npomocí inject anotace.\r\n\r\nNásledně je třeba vytvořit požadavek, ten spustit a testovat výslednou odpověď:\r\n\r\n/--code php\r\n$request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\r\n$response = $this->presenter->run($request);\r\n\\--\r\n\r\nPrávě nad vrácenou odpovědí lze spustit testovací sadu, která bude testovat, \r\nzda byla například získána textová odpověď a tedy jestli se jedná o šablonu:\r\n\r\n/--code php\r\n\\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\r\n\\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\r\n\\--\r\n\r\nJe také vhodné otestovat samotný HTML kód. Již mě to párkrát upozornilo na\r\nnevalidní kód, což se může stát, pokud se šablona skládá z hodně include částí.\r\nNevalidní ve smyslu například dvojité HTML ukončovací značky:\r\n\r\n/--code php\r\n$html = (string)$response->getSource();\r\n$dom = \\Tester\\DomQuery::fromHtml($html);\r\n\\Tester\\Assert::true($dom->has(\'title\'));\r\n\\--\r\n\r\nPsaní, psaní, psaní...\r\n======================\r\n\r\nPředchozí teorie je zapotřebí opakovat pro každý presenter. Už jen proto, že je třeba\r\nvytvořit pokaždé nový požadavek. Nicméně je jasné, že to po otestování FrontModule\r\nzačne být lehce kopírovací nuda.\r\n\r\nJe tedy vhodné vytvořit si třídu, která ušetří spoustu řádek.\r\nMůj první návrh vypadá přibližně takto:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Test;\r\n\r\nclass Presenter extends \\Nette\\Object {\r\n\r\n        private $container;\r\n        private $presenter;\r\n        private $presName;\r\n\r\n        public function __construct(\\Nette\\DI\\Container $container) {\r\n                $this->container = $container;\r\n        }\r\n\r\n        /**\r\n         * @param $presName string Fully qualified presenter name.\r\n         */\r\n        public function init($presName) {\r\n                $presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\r\n                $this->presenter = $presenterFactory->createPresenter($presName);\r\n                $this->presenter->autoCanonicalize = FALSE;\r\n                $this->presName = $presName;\r\n        }\r\n\r\n        public function test($action, $method = \'GET\', $params = array(), $post = array()) {\r\n                $params[\'action\'] = $action;\r\n                $request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\r\n                $response = $this->presenter->run($request);\r\n                return $response;\r\n        }\r\n\r\n        public function testAction($action, $method = \'GET\', $params = array(), $post = array()) {\r\n                $response = $this->test($action, $method, $params, $post);\r\n\r\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\r\n                \\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\r\n\r\n                $html = (string)$response->getSource();\r\n                $dom = \\Tester\\DomQuery::fromHtml($html);\r\n                \\Tester\\Assert::true($dom->has(\'title\'));\r\n\r\n                return $response;\r\n        }\r\n\r\n        public function testForm($action, $method = \'POST\', $post = array()) {\r\n                $response = $this->test($action, $method, $post);\r\n\r\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\RedirectResponse);\r\n\r\n                return $response;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nTestování samotných presenterů je pak již otázkou několika málo řádek:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Test;\r\n\r\n$container = require __DIR__ . \'/../bootstrap.php\';\r\n\r\nclass HomepagePresenterTest extends \\Tester\\TestCase {\r\n\r\n        public function __construct(\\Nette\\DI\\Container $container) {\r\n                $this->tester = new \\Test\\Presenter($container);\r\n        }\r\n\r\n        public function setUp() {\r\n                $this->tester->init(\'Front:Homepage\');\r\n        }\r\n\r\n        public function testRenderDefault() {\r\n                $this->tester->testAction(\'default\');\r\n        }\r\n\r\n}\r\n\r\nid(new HomepagePresenterTest($container))->run();\r\n\\--\r\n\r\nTakto chápu testování presenterů v Nette já. Dále budu směrovat testy tak, abych nemusel psát téměř nic\r\na měl jsem otestováno téměř všechno. Myslím si, že toto je jediná cesta jak se přinutit k testování.\r\nNelze se již vymlouvat na to, že je to spousta psaní navíc. Není.'),
(46,	'CRON validátor',	'cron-validator',	'A jak už to tak bývá, tak opět ohnutý pro Nette. Tentokráte inspirovaný řešením ISPConfigu.\r\n\r\nMůžeš tohle, nesmíš tamto\r\n=========================\r\n\r\nSamotný CRON zápis je velmi rozmanitý a proto se omezím pouze na základní požadavky:\r\n\r\n1)  obecně jsou povolené znaky <code>0-9</code>, <code>čárka</code>, <code>*</code>, <code>-</code>, <code>/</code>\r\n2)  <code>čárka</code>, <code>-</code> a <code>/</code> nesmí být nikdy vedle sebe\r\n3)  <code>x</code>, <code>x-y</code>, <code>x/y</code>, <code>x-y/z</code>, <code>*/x</code>, kde x,y,z jsou čísla z povolených časových rozsahů\r\n4)  povolený rozsah pro minuty: <strong>0-59</strong>\r\n5)  povolený rozsah pro hodiny: <strong>0-23</strong>\r\n6)  povolený rozsah pro dny měsíce: <strong>1-31</strong>\r\n7)  povolený rozsah pro měsíce: <strong>1-12</strong>\r\n8)  povolený rozsah pro dny v týdnu: <strong>0-6</strong>\r\n\r\nTo je myslím slušný výčet pravidel pro zvalidování jednoho příkazu.\r\nÚkolem tohoto článku není ukázat jak tvořit a zpracovávat formulář, ale bude vhodné\r\numístit sem celý kód alespoň vytvoření:\r\n\r\n/--code php\r\n/**\r\n  * @return Nette\\Application\\UI\\Form\r\n  */\r\nprotected function createComponentAddCron() {\r\n	$form = new Nette\\Application\\UI\\Form;\r\n	$form->addProtection();\r\n	$form->addText(\'minutes\', \'Minuty:\')\r\n		->addRule(\\Fresh\\ValidateCron::MINUTES, \'Nevalidní CRON zápis - minuty.\');\r\n	$form->addText(\'hours\', \'Hodiny:\')\r\n		->addRule(\\Fresh\\ValidateCron::HOURS, \'Nevalidní CRON zápis - hodiny.\');\r\n	$form->addText(\'mdays\', \'Dny měsíce:\')\r\n		->addRule(\\Fresh\\ValidateCron::MDAYS, \'Nevalidní CRON zápis - mdays.\');\r\n	$form->addText(\'months\', \'Měsíce:\')\r\n		->addRule(\\Fresh\\ValidateCron::MONTHS, \'Nevalidní CRON zápis - měsíce.\');\r\n	$form->addText(\'wdays\', \'Dny v týdnu:\')\r\n		->addRule(\\Fresh\\ValidateCron::WDAYS, \'Nevalidní CRON zápis - wdays.\');\r\n	$form->addText(\'command\', \'Příkaz:\')\r\n		->setRequired(\'Vyplňte prosím příkaz, který bude CRON spouštět.\');\r\n	$form->addSubmit(\'save\', \'Přidat nový CRON\');\r\n	$form->onSuccess[] = $this->addCronSucceeded;\r\n	return $form;\r\n}\r\n\\--\r\n\r\nA rovnou bez hloupých povídání celý validátor:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Fresh;\r\n\r\n/**\r\n * Class ValidateCron - inspired by ISPConfig\r\n * @package Fresh\r\n */\r\nclass ValidateCron extends \\Nette\\Object {\r\n\r\n        const MINUTES = \'\\Fresh\\ValidateCron::validateMinutes\';\r\n        const HOURS = \'\\Fresh\\ValidateCron::validateHours\';\r\n        const MDAYS = \'\\Fresh\\ValidateCron::validateMdays\';\r\n        const MONTHS = \'\\Fresh\\ValidateCron::validateMonths\';\r\n        const WDAYS = \'\\Fresh\\ValidateCron::validateWdays\';\r\n\r\n        public static function validateMinutes(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 59);\r\n        }\r\n\r\n        public static function validateHours(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 23);\r\n        }\r\n\r\n        public static function validateMdays(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 31);\r\n        }\r\n\r\n        public static function validateMonths(\\Nette\\Forms\\IControl $control) {\r\n                if($control->getValue() != \'@reboot\') { // allow value @reboot in month field\r\n                        return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 12);\r\n                } else {\r\n                        return TRUE;\r\n                }\r\n        }\r\n\r\n        public static function validateWdays(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 6);\r\n        }\r\n\r\n        private static function validateTimeFormat($value, $min_entry = 0, $max_entry = 0) {\r\n                if (preg_match(\"\'^[0-9\\-\\,\\/\\*]+$\'\", $value) == false) { // allowed characters are 0-9, comma, *, -, /\r\n                        return FALSE;\r\n                } elseif (preg_match(\"\'[\\-\\,\\/][\\-\\,\\/]\'\", $value) == true) { // comma, - and / never stand together\r\n                        return FALSE;\r\n                }\r\n                $time_list = explode(\",\", $value);\r\n                foreach ($time_list as $entry) {\r\n                        // possible value combinations:\r\n                        // x               =>      ^(\\d+)$\r\n                        // x-y             =>      ^(\\d+)\\-(\\d+)$\r\n                        // x/y             =>      ^(\\d+)\\/([1-9]\\d*)$\r\n                        // x-y/z           =>      ^(\\d+)\\-(\\d+)\\/([1-9]\\d*)$\r\n                        // */x             =>      ^\\*\\/([1-9]\\d*)$\r\n                        // combined regex  =>      ^(\\d+|\\*)(\\-(\\d+))?(\\/([1-9]\\d*))?$\r\n                        if (preg_match(\"\'^(((\\d+)(\\-(\\d+))?)|\\*)(\\/([1-9]\\d*))?$\'\", $entry, $matches) == false) {\r\n                                return FALSE;\r\n                        }\r\n                        // matches contains:\r\n                        // 1       =>      * or value or x-y range\r\n                        // 2       =>      unused\r\n                        // 3       =>      value if [1] != *\r\n                        // 4       =>      empty if no range was used\r\n                        // 5       =>      2nd value of range if [1] != * and range was used\r\n                        // 6       =>      empty if step was not used\r\n                        // 7       =>      step\r\n                        if ($matches[1] == \"*\") {\r\n                                // not to check\r\n                        } else {\r\n                                if ($matches[3] < $min_entry || $matches[3] > $max_entry) { // check if value is in allowed range\r\n                                        return FALSE;\r\n                                } elseif (isset($matches[4]) && ($matches[5] < $min_entry || $matches[5] > $max_entry || $matches[5] <= $matches[3])) {\r\n                                        // check if value is in allowed range and not less or equal to first value\r\n                                        return FALSE;\r\n                                }\r\n                        }\r\n                        if (isset($matches[6]) && ($matches[7] < 2 || $matches[7] > $max_entry - 1)) { // check if step value is valid\r\n                                return FALSE;\r\n                        }\r\n                } // end foreach entry loop\r\n                return TRUE;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nValidátorem navrácené errory lze vykreslit například takto ručně (nově v DEV Nette):\r\n\r\n/--code html\r\n{form $form}\r\n\r\n<ul class=\"error\" n:if=\"$form->allErrors\">\r\n        <li n:foreach=\"$form->allErrors as $error\">{$error}</li>\r\n</ul>\r\n\r\n...\r\n\r\n{/form}\r\n\\--'),
(47,	'Třída pro připojení k FIO API',	'trida-pro-pripojeni-k-fio-api',	'Další užitečný úryvek, který je škoda nechat ležet v Git repozitářích.\r\nA opět uzpůsobený pro používání s Nette FW.\r\n\r\nNedávno jsem psal o tom, jak používat CLI router v Nette (http://www.zeminem.cz/nette-2-1-dev-clirouter).\r\nPrávě pomocí tohoto routeru je vhodné kontrolovat bankovní výpisy - například pomocí cronu:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App\\CliModule;\r\n\r\nuse Nette;\r\nuse Nette\\Diagnostics\\Debugger;\r\n\r\n/**\r\n * Class CliPresenter\r\n * @package App\\CliModule\r\n */\r\nclass CliPresenter extends BasePresenter {\r\n\r\n        /** @var \\Fio @inject */\r\n        public $fio;\r\n        ...\r\n\r\n        public function actionCron() {\r\n                $this->checkFio(); // FIO vs. nezaplacené objednávky\r\n                ...\r\n                $this->terminate();\r\n        }\r\n\r\n        /**\r\n         * Zkontroluje bankovní účet, porovná s databází a zaplacené objednávky změní na status PAID.\r\n         */\r\n        private function checkFio() {\r\n                try {\r\n                        $transactions = $this->fio->transactions();\r\n                        $unpaid = $this->orders->selectUnpaidOrders(); //získání nezaplacených objednávek\r\n                        //array_intersect() - zde samotné zpracování\r\n                        ...\r\n                } catch (\\Exception $exc) {\r\n                        Debugger::log($exc->getMessage() . \' FILE: \' . $exc->getFile() . \' on line: \' . $exc->getLine(), Debugger::WARNING);\r\n                        echo $exc->getMessage() . EOL;\r\n                }\r\n        }\r\n}\r\n\\--\r\n\r\nK tomu se hodí právě následující třída:\r\n\r\n/--code php\r\n<?php\r\n\r\n/**\r\n * Class Fio\r\n */\r\nclass Fio extends \\Nette\\Object {\r\n\r\n        private $token;\r\n        private $rest_url = \'https://www.fio.cz/ib_api/rest/\';\r\n\r\n        /**\r\n         * @param string $token SECURE\r\n         */\r\n        public function __construct($token) {\r\n                $this->token = $token;\r\n        }\r\n\r\n        /**\r\n         * Pohyby na účtu za určené období.\r\n         * JSON only!\r\n         * @param string $from\r\n         * @param string $to\r\n         */\r\n        public function transactions($from = \'-1 month\', $to = \'now\') {\r\n                $from = \\Nette\\DateTime::from($from)->format(\'Y-m-d\');\r\n                $to = \\Nette\\DateTime::from($to)->format(\'Y-m-d\');\r\n                $url = $this->rest_url . \'periods/\' . $this->token . \'/\' . $from . \'/\' . $to . \'/transactions.json\';\r\n                return $this->parseJSON($this->download($url));\r\n        }\r\n\r\n        /**\r\n         * Oficiální výpisy pohybů z účtu.\r\n         * JSON only!\r\n         * @param $id\r\n         * @param null $year\r\n         * @return array|mixed\r\n         */\r\n        public function transactionsByID($id, $year = NULL) {\r\n                if ($year === NULL) {\r\n                        $year = date(\'Y\');\r\n                }\r\n                $url = $this->rest_url . \'by-id/\' . $this->token . \'/\' . $year . \'/\' . $id . \'/transactions.json\';\r\n                return $this->parseJSON($this->download($url));\r\n        }\r\n\r\n        /**\r\n         * Pohyby na účtu od posledního stažení.\r\n         * JSON only!\r\n         * @return array|mixed\r\n         */\r\n        public function transactionsLast() {\r\n                $url = $this->rest_url . \'last\' . $this->token . \'/transactions.json\';\r\n                return $this->parseJSON($this->download($url));\r\n        }\r\n\r\n        /**\r\n         * @param $url\r\n         * @return mixed\r\n         * @throws \\Exception\r\n         */\r\n        private function download($url) {\r\n                if (!extension_loaded(\'curl\')) {\r\n                        throw new \\Exception(\'Curl extension, does\\\'t loaded.\');\r\n                }\r\n                $curl = curl_init();\r\n                curl_setopt($curl, CURLOPT_URL, $url);\r\n                curl_setopt($curl, CURLOPT_HEADER, FALSE);\r\n                curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\r\n                curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\r\n                curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);\r\n                $result = curl_exec($curl);\r\n                return $result;\r\n                //return file_get_contents($url); //ALTERNATIVE\r\n        }\r\n\r\n        /**\r\n         * @param $data\r\n         * @return array|mixed\r\n         */\r\n        private function parseJSON($data) {\r\n                $json = json_decode($data);\r\n                if($json === NULL) {\r\n                        //Moc ryhlé požadavky na Fio API\r\n                        throw new \\Exception(\'Fio API overheated. Please wait...\');\r\n                        //Když se posílá stále moc požadavků, tak se to z Exception nikdy nevyhrabe. Musí se opravdu počkat.\r\n                }\r\n                if(!$json->accountStatement->transactionList) {\r\n                        return $json; // There are no transactions (header only)\r\n                }\r\n                $payments = array();\r\n                foreach ($json->accountStatement->transactionList->transaction as $row) {\r\n                        $out = array();\r\n                        foreach ($row as $column) {\r\n                                if ($column) {\r\n                                        $out[$column->id] = $column->value; //v $column->name je název položky\r\n                                        /*\r\n                                         * 0  - Datum\r\n                                         * 1  - Částka (!)\r\n                                         * 5  - Variabilní symbol (!)\r\n                                         * 14 - Měna (!)\r\n                                         * Hodnoty (!) se musí použít ke kontrole správnosti...\r\n                                         */\r\n                                }\r\n                        }\r\n                        array_push($payments, $out);\r\n                }\r\n                return $payments;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nS tím, že je zapotřebí předat FIO klíč z neonu. FIO třída se automaticky injectuje, tzn. že i konstruktor\r\ntéto třídy bude doplněn automaticky. Je jen zapotřebí přidat do neonu onu konfiguraci:\r\n\r\n/--code neon\r\nparameters:\r\n	fio_token: \'\' #token pro přístup do FIO banky\r\n    \r\n...\r\n\r\nservices:\r\n	- Fresh\\Fio(token: %fio_token%)\r\n    \r\n...\r\n\\--\r\n\r\nBylo by vhodné upozornit na fakt, že se jedná pouze o read-only přístup, tzn. že neexistují žádné funkce\r\npro zápis (ačkoliv existuje něco jako datumová zarážka). Díky tomu je možné použít takovéto nízkoúrovňové\r\nzabezpečení pomocí jednoho tokenu.'),
(49,	'Using fulltext searching with InnoDB',	'using-fulltext-searching-with-innodb',	'Sometimes is quite useful to use InnoDB engine. \r\nUnfortunately InnoDB is good for tables with foreign keys, but useless for fulltext search. \r\nYou can\'t create fulltext index on InnoDB tables, but you can create this index on MyISAM tables. \r\nUnfortunately you can\'t create foreign keys on MyISAM. It\'s starting to be quite embarassing. \r\nLet me show you how to search via fulltext on InnoDB tables.\r\n\r\nIn fact it\'s not possible to use fulltext index on InnoDB tables, \r\nbut there is possible workaround. At first you need a classic InnoDB structure. \r\nFor example database of  blog:\r\n\r\n/--code sql\r\nSET NAMES utf8;\r\nSET foreign_key_checks = 0;\r\nSET time_zone = \'SYSTEM\';\r\nSET sql_mode = \'NO_AUTO_VALUE_ON_ZERO\';\r\n\r\nDROP TABLE IF EXISTS `posts`;\r\nCREATE TABLE `posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` text NOT NULL,\r\n  `body` text NOT NULL,\r\n  `date` datetime NOT NULL,\r\n  `release_date` datetime NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `title_3` (`title`(200))\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nDROP TABLE IF EXISTS `tags`;\r\nCREATE TABLE `tags` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(50) NOT NULL,\r\n  `color` varchar(6) NOT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nDROP TABLE IF EXISTS `posts_tags`;\r\nCREATE TABLE `posts_tags` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `tag_id` int(11) NOT NULL,\r\n  `post_id` int(11) NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  KEY `tag_id` (`tag_id`),\r\n  KEY `post_id` (`post_id`),\r\n  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),\r\n  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\\--\r\n\r\nNow we have pretty simple database structure with InnoDB tables with foreign keys. \r\nIt would be nice to be able search on database table **posts** using fulltext search:\r\n\r\n/--code sql\r\nSELECT *\r\nFROM posts\r\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE);\r\n\\--\r\n\r\nBut it is not possible. It returns something like:\r\n>   Error in query: The used table type doesn\'t support FULLTEXT indexes\r\n\r\nLet\'s create another one table with triggers and fulltext indexes. \r\nWe need to create mirror table. For example:\r\n\r\n/--code sql\r\nDROP TABLE IF EXISTS `mirror_posts`;\r\nCREATE TABLE `mirror_posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` text NOT NULL,\r\n  `body` text NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  FULLTEXT KEY `title_body` (`title`,`body`),\r\n  FULLTEXT KEY `title` (`title`),\r\n  FULLTEXT KEY `body` (`body`)\r\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\r\n\\--\r\n\r\nAnd than we need to create triggers:\r\n\r\n/--code sql\r\nDELIMITER ;;\r\n\r\nCREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW\r\nINSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body);;\r\n\r\nCREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW\r\nUPDATE mirror_posts SET\r\n    id = NEW.id,\r\n    title = NEW.title,\r\n    body = NEW.body\r\nWHERE id = OLD.id;;\r\n\r\nCREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW\r\nDELETE FROM mirror_posts WHERE id = OLD.id;;\r\n\\--\r\n\r\nIt means, that we copy all of events and data from table **posts** to the table **mirror_posts**.\r\nFinally we can use more complex fulltext search feature:\r\n\r\n/--code sql\r\nSELECT *\r\nFROM mirror_posts\r\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE)\r\nORDER BY 5 * MATCH(title) AGAINST (\'something\') + MATCH(body) AGAINST (\'something\') DESC;\r\n\\--\r\n\r\nAs I said, this is just workaround, not solution. \r\nSometimes it\'s bad practice, because you need copy of indexed columns. \r\nBut it works. And for small blogs it\'s sufficient.'),
(50,	'Problémy fulltextu v Nette',	'problemy-fulltextu-v-nette',	'Nedávno jsem psal o tom, jak využívat fulltext indexy na InnoDB tabulkách (http://www.zeminem.cz/using-fulltext-searching-with-innodb).\r\nNení to nic převratného, ale každý den se to také nedělá. Zmínil jsem také, jak vyhledávat, což\r\nbylo řešení \"Jakuba Vrány .{target:_blank}\":http://php.vrana.cz/fulltextove-vyhledavani-v-mysql.php.\r\n\r\nV diskusi pod článkem zmíňka o tom, jak ošetřit případ, kdy databáze nevrací výsledky pro slova,\r\nkterá jsou kratší než je hodnota **ft_min_word_len**. Implementace pro Nette nebude nijak zvlášť\r\nrozdílná, avšak i zde existuje minimálně jedna zrádnost.\r\n\r\nNette, ty jedna zrádná bestie...\r\n================================\r\n\r\nPro dotazování využívám databázovou vrstvu \\Nette\\Database, což je rozšíření (nadstavba) pro PDO.\r\nS oblibou také využívám fluid zápis a spoléhám na automatické ošetření vstupů. A zde je právě kámen úrazu.\r\nNette je místy až příliš důkladné (což je dobře), ale v tomto případě to znemožňuje korektní\r\npoužití **REGEXP**.\r\n\r\nBěžný kód pro fultextové dotazování může vypadat takto:\r\n\r\n/--code php\r\n/** @var Nette\\Database\\SelectionFactory @inject */\r\npublic $sf;\r\n    \r\n$this->sf->table(\'mirror_posts\')\r\n	->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)\", $search)\r\n	->order(\"5 * MATCH(title) AGAINST (?) + MATCH(body) AGAINST (?) DESC\", $search, $search)\r\n	->limit(50);\r\n\\--\r\n\r\nCož vygeneruje přibližně přesně následující:\r\n\r\n/--code sql\r\nSELECT `id`, `title`, `body` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE)) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nBohužel tento dotaz nevrátí nic. Je to právě kvůli hodnotě **ft_min_word_len**, kterou mám nastavenou\r\nna 4. Takže můžu změnit tuto hodnotu, a nebo pro všechny slova, která jsou kratší než 4 znaky\r\nposkládám složitější dotaz:\r\n\r\n/--code php\r\n$where = \"\";\r\n//$ft_min_word_len = mysql_result(mysql_query(\"SHOW VARIABLES LIKE \'ft_min_word_len\'\"), 0, 1);\r\n$ft_min_word_len = 4;\r\npreg_match_all(\"~[\\\\pL\\\\pN_]+(\'[\\\\pL\\\\pN_]+)*~u\", stripslashes($search), $matches);\r\nforeach ($matches[0] as $part) {\r\n	if (iconv_strlen($part, \"utf-8\") < $ft_min_word_len) {\r\n		$regexp = \"REGEXP \'[[:<:]]\" . addslashes($part) . \"[[:>:]]\'\";\r\n		$where .= \" OR (title $regexp OR body $regexp)\";\r\n	}\r\n}\r\n\\--\r\n\r\nA doplníme fluidní dotaz:\r\n\r\n/--code php\r\n...\r\n->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)$where\", $search) //přidáno $where\r\n...\r\n\\--\r\n\r\nNyní budu vyhledávat stejný výraz a to automaticky poskládaným dotazem:\r\n\r\n/--code sql\r\nSELECT `id` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE) OR (`title` REGEXP \'[[:<:]]`api`[[:>:]]\' OR `body` REGEXP \'[[:<:]]`api`[[:>:]]\')) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nBohužel, ani tento dotaz nevrátí strávný výsledek, ačkoliv se tváří, že by měl.\r\nDůvodem jsou zpětné uvozovky v regulárním výrazu **\'\'[[:<:]]`api`[[:>:]]\'\'**.\r\n\r\nŘešení je zřejmě několik. Například poskládat si tento dotaz sám. Ovšem to není ta nejbezpečnější cesta.\r\nEscapování je zrádné a zrovna vyhledávání je jedna z nejvíce používaných věcí, kdy se uživatel\r\npřímo ptá databáze. Existuje však vyčůranější způsob.\r\n\r\nCo jsem tak vypozoroval, tak Nette se sice o escapování snaží, ale neescapuje výraz zapsaný pomocí\r\n<em>strtoupper()</em>. Tzn. že stačí změnit tvorbu výrazu:\r\n\r\n/--code php\r\n$regexp = \"REGEXP \'[[:<:]]\" . addslashes(strtoupper($part)) . \"[[:>:]]\'\";\r\n\\--\r\n\r\nA dotaz se následně poskládá strávně:\r\n\r\n/--code sql\r\nSELECT `id`, `title`, `body` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE) OR (`title` REGEXP \'[[:<:]]API[[:>:]]\' OR `body` REGEXP \'[[:<:]]API[[:>:]]\')) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nTo že je část výrazu jiná než ve skutečnosti nevadí. Nevím jestli je case-insensitive chování\r\nvlastnost REGEXP, ale tabulkou s postfixem **_ci** se také nic nezkazí.\r\n\r\nJen mě tak napadá, proč se to chová tak zvláštně. Uspokojuji se tím, že zpětná uvozovka\r\nnení úplně součástí escapování, takže se není čeho bát (a první regulár v PHP také nepustí vše),\r\nale je to divné.'),
(51,	'Routování v Nette - prakticky',	'routovani-v-nette-prakticky',	'V následujícím článku se budu opírat o teorii napsanou v \"dokumentaci\":http://doc.nette.org/cs/routing.\r\nJelikož jsem se však Nette učil sám, tak vím jak je těžké routování pochopit\r\na zvlášť potom z dokumentace, která spíše ukazuje fičury, než jak na to. A vzhledem k tomu, že mi\r\npod rukama prošlo velké množství velmi různorodých aplikací, kád bych zde uvedl příklady\r\nadresářové struktury, rout pro daný praktický problém a vzniklé URL adresy.\r\nZačíná přehlídka několika možných rout. Myslím si, že celá řada příkladů bude užitečnější, než teorie.\r\n\r\nZáklad všeho je porozumět tomu, jak se v Nette vytváří \"odkazy\":http://doc.nette.org/cs/presenters#toc-vytvareni-odkazu.\r\nOd toho se velmi podobně sestavují obecné routy tak, aby alespoň jedna seděla svým tvarem na daný odkaz.\r\n\r\nZačněme jednoduchou statickou stránkou, která má tuto jednoduchou adresářovou strukturu (dev Nette):\r\n\r\n/--code\r\napp/\r\n├─── config/\r\n├─── model/\r\n├─── presenters/\r\n│     └── HomepagePresenter.php\r\n│\r\n├─── router/\r\n├─── templates/\r\n│     ├── Homepage/\r\n│     │    ├── kontakt.latte   (zde jednotlivé stránky statického webu)\r\n│     │    └── ...\r\n│     └── @layout.latte\r\n│\r\n└─── bootstrap.php\r\n\\--\r\n\r\nTo znamená, že ne každou stránku se budu odkazovat přibližně jako <code>Homepage:kontakt</code>. Samozřejmě \r\nvždy se záměnou šablony (v tomto případě kontakt - kontakt.latte). To je dost triviální a stačilo by například:\r\n\r\n/--code php\r\n$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\r\n\\--\r\n\r\nTo je sice funkční, bohužel je to spíše teoretická routa, protože výsledek je otřesný:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/homepage/kontakt\r\n\\--\r\n\r\nTuto routu píšu téměř všude. Je to routa velmi obecná a říká přibličně následující:\r\nBude-li se někdo odkazovat ve tvaru **bla:blabla**, pochop **bla** jako presenter a hledej tedy soubor BlaPresenter.php\r\na **blabla** bude šablona presenteru, hledej ji tedy ve složce **bla/blabla.latte** a sestav URL která bude přesně v tomto tvaru.\r\nHomepage:default pouze říká co je výchozí hodnota a co se má hledat, pokud nebude specifikována konkrétní šablona.\r\n\r\nPro takto malý web je mnohem lepší specifikovat konkrétnější routu, která přijde **před** onu obecnou:\r\n\r\n/--code php\r\n$router[] = new Route(\'<action>\', \'Homepage:default\');\r\n\\--\r\n\r\nCož udělá téměř to samé, jen vypustí z URL nadbytečnou informaci o presenteru. Vždy používáme HomepagePresenter, jen\r\nse mění cílová šablona podle URL:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/kontakt\r\n\\--\r\n\r\nVýsledná sada rout pro takovouto malou statickou stránku by tedy mohla vypadat takto:\r\n\r\n/--code php\r\npublic function createRouter() {\r\n	$router = new RouteList();\r\n	$router[] = new Route(\'<action>\', \'Homepage:default\');\r\n	$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\r\n	return $router;\r\n}\r\n\\--\r\n\r\nDále je vhodné používat např. soubor <code>sitemap.xml</code>. Pokud ho také umístím do stejného adresáře\r\njako šablony, routa je opět jednoduchá:\r\n\r\n/--code php\r\n$router[] = new Route(\'sitemap.xml\', \'Homepage:sitemap\');\r\n\\--\r\n\r\nHledá se šablona <code>sitemap.latte</code> a výsledná URL je tak jak má být:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/sitemap.xml\r\n\\--\r\n\r\nTo samé lze udělal pro RSS. Trošku složitější routování přichází vždy když chcete udělat něco speciálního.\r\nNapříklad to, aby číslo za URL udávalo číslo stránky v paginatoru:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/2\r\n\\--\r\n\r\n/--code php\r\n$router[] = new Route(\"[<paginator-page [1|2]>]\", array(\r\n	\'presenter\' => \'Homepage\',\r\n	\'action\' => \'default\',\r\n	\'paginator-page\' => 1\r\n));\r\n\\--\r\n\r\nZde už je nutné druhý parametr rozepsat a více specifikovat. Toto akceptuje pouze konkrétní čísla.\r\na jako druhou specialitu lze napsat takovou routu, která bude tvořit URL z názvů článků:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/using-fulltext-searching-with-innodb\r\n\\--\r\n\r\n/--code php\r\n$router[] = new Route(\'<id>\', array(\r\n	\'presenter\' => \'Single\',\r\n	\'action\' => \'article\',\r\n	\'id\' => array(\r\n		Route::FILTER_IN => function ($url) {\r\n			return $this->posts->getIdByUrl($url);\r\n		},\r\n		Route::FILTER_OUT => function ($id) {\r\n			return $this->posts->getUrlById($id);\r\n		},\r\n	),\r\n));\r\n\\--\r\n\r\nA není úplně na škodu vytvořit routu, která bude řešit napríklad vyhledávání:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/search/fio%20api\r\n\\--\r\n\r\n/--code php\r\n$router[] = new Route(\'search[/<search>]\', \'Search:default\');\r\n\\--\r\n\r\nToto jsou jednoduché routy pro jednoduchou adresářovou strukturu. Lehce složitější jsou pro\r\nmodulární strukturu, kdy je zapotřebí specifikovat modul:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/rss.xml\r\n\\--\r\n\r\n/--code php\r\n$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\r\n\\--\r\n\r\nChová se to stejně jako u předchozího příkladu se sitemap.xml, v tomto příkladu však routa hledá\r\nBlogPresenter.php ve složce FrontModule a šablonu rss.latte, také v tomto modulu. U rout pro\r\nmodulární aplikace již raději rozepisuji druhý parametr, protože je to přehlednější. Následující routa\r\nzvládne jazykové mutace pro FrontModule, jinak je to opět ta nejobecnější routa vůbec:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/en/site/kontakt\r\n\\--\r\n\r\n/--code php\r\n$router[] = new Route(\'[<lang cs|sk|en>/]<presenter>/<action>[/<id>]\', array(\r\n	\'module\' => \'Front\',\r\n	\'presenter\' => \'Homepage\',\r\n	\'action\' => \'default\',\r\n));\r\n\\--\r\n\r\nTo samé, ale opět o trošku náročnější. Tentokrát pro UserModule, který je na jiné URL, než FrontModule:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/user/en/setting/password\r\n\\--\r\n\r\n/--code php\r\n$router[] = new Route(\'user/[<lang cs|sk|en>/]<presenter>/<action>[/<id [0-9]+>]\', array(\r\n	\'module\' => \'User\',\r\n	\'presenter\' => \'Board\',\r\n	\'action\' => \'default\',\r\n));\r\n\\--\r\n\r\nA na závěr ještě poslední přehled možných rout jako příklady toho co je možné.\r\n\r\n/--code php\r\n$router[] = new Route(\'sitemap.xml\', \'Front:Export:sitemap\');\r\n$router[] = new Route(\'kategorie/<category>\', \'Front:Product:default\');\r\n$router[] = new Route(\'produkt/<product>\', \'Front:Product:detail\');\r\n$router[] = new Route(\'\', \'Front:Product:default\');\r\n$router[] = new Route(\'admin/sign-<action>\', \'Admin:Sign:\');\r\n$router[] = new Route(\'registrace/\', \'Front:Register:new\');\r\n$router[] = new Route(\'index.php\', \'Homepage:default\', Route::ONE_WAY);\r\n$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\r\n$router[] = new \\App\\RestRouter(\'api[/<presenter>[/<id>]]\', array( //vyžaduje speciální objekt (není součástí Nette)\r\n	\'module\' => \'Rest\',\r\n	\'presenter\' => \'Resource\',\r\n	\'action\' => \'get\',\r\n), \\App\\RestRouter::RESTFUL);\r\n\\--\r\n\r\nJe zcela zřejmé, že se všechny konstrukce stále opakují, proto považuji za opravdu důležité\r\nperfektně pochopit tvorbu odkazů a následně je to možná trochu o experimentování, ale s\r\ntouto sadou příkladů bude myslím jednoduché najít podobnou routu, jaká je zrovna potřeba.\r\n\r\nJak na v posledním příkladu zmíněný CLI router se dočtete zde: http://www.zeminem.cz/nette-2-1-dev-clirouter\r\n\r\nV článku jsem většinou pozměnil domény, abych neprozrazoval strukturu jiných webů. (-:'),
(52,	'Fluent interface a PCRE',	'fluent-interface-a-pcre',	'Na následujících řádcích předvedu dvě věci. První je úžasný nápad jak vytvářet regulární výrazy pomocí fluent zápisu (\"inspirace .{target:_blank}\":https://github.com/VerbalExpressions/PHPVerbalExpressions/blob/master/VerbalExpressions.php), což je druhá věc o které bych se rád zmínil.\r\n\r\nRegulární výrazy jsou peklo\r\n=======================\r\nAčkoliv znám pár lidí, které regulární výrazy umí, je jich opravdu pár. A nikdo z nich o sobě neřekne, že je umí. Následuje příklad velmi triviálního výrazu, který je ovšem dosti špatný, což je dobře, protože se k tomu vrátím později:\r\n\r\n/--code\r\n/^(http)(s)?(\\:\\/\\/)(www\\.)?([^ ]*)(\\.)([^ ]*)(\\/)?$/\r\n\\--\r\n\r\nTento výraz akceptuje přibližně tvar URL. Je však zřejmé, že je to zápis, který je nesmírně náročný na vymyšlení a extrémně náchylný ke tvoření chyb. Proto je vhodné si jeho tvorbu zjednodušit například nějakou třídou:\r\n\r\n/--code php\r\n<?php\r\n\r\nclass Regexp {\r\n\r\n	private $regexp = \'\';\r\n\r\n	public function has($value) {\r\n		$this->regexp .= \"(\" . preg_quote($value, \'/\') . \")\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function maybe($value) {\r\n		$this->regexp .= \"(\" . preg_quote($value, \'/\') . \")?\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function anythingBut($value) {\r\n		$this->regexp .= \"([^\" . preg_quote($value, \'/\') . \"]*)\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function __toString() {\r\n		return \"/^$this->regexp$/\";\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nS tím, že její použití je prosté:\r\n\r\n/--code php\r\n$regexp = new Regexp();\r\n$regexp->then(\'http\');\r\n$regexp->maybe(\'s\');\r\n$regexp->then(\'://\');\r\n$regexp->maybe(\'www.\');\r\n$regexp->anythingBut(\' \');\r\n$regexp->then(\'.\');\r\n$regexp->anythingBut(\' \');\r\n$regexp->maybe(\'/\');\r\necho $regexp . \'<br>\';\r\necho preg_match($regexp, \'http://www.zeminem.cz/\') ? \'P\' : \'F\';\r\necho preg_match($regexp, \'https://www.zeminem.cz/\') ? \'P\' : \'F\';\r\n\\--\r\n\r\nNemusím však říkat, že to minimálně vypadá naprosto otřesně. Spousta psaní, až moc objektové chování. Elegantnější řešení přináší právě fluent interface.\r\n\r\nFluent interfaces, regulární peklo chladne\r\n===================================\r\nFluent interface je způsob jak řetězit metody za sebe. Používá se poměrně často, ušetří spoustu zbytečného psaní a velmi prospívá srozumitelnosti kódu. Nevýhodou je, že se musí v každé metodě vrátit objekt <code>return $this;</code>, na což se nesmí zapomenout. Každopádně výsledek je skvostný:\r\n\r\n/--code php\r\n$regexp = new Regexp();\r\n$regexp->then(\'http\')\r\n		->maybe(\'s\')\r\n		->then(\'://\')\r\n		->maybe(\'www.\')\r\n		->anythingBut(\' \')\r\n		->then(\'.\')\r\n		->anythingBut(\' \')\r\n		->maybe(\'/\');\r\necho $regexp . \'<br>\';\r\necho preg_match($regexp, \'http://www.zeminem.cz/\') ? \'P\' : \'F\';\r\necho preg_match($regexp, \'https://www.zeminem.cz/\') ? \'P\' : \'F\';\r\n\\--\r\n\r\nTeprve zde vynikne to, jak je důležité správně (čti stručně a jasně) pojmenovávat metody. Díky fluent interfaces lze programovat téměř ve větách, které jsou naprosto srozumitelné.\r\n\r\nNe, peklo je opět peklem\r\n=====================\r\nAčkoliv by se mohlo zdát, že díky objektu, který pomáhá tvořit regulární výrazy je jejich kompozice jednoduchou záležitostí, není tomu tak. Vrátím se k původnímu výrazu, který není dobrý. Proč? V reálném světě je kontrola, resp. předpis, který musí daná adresa mít daleko složitější. Například <code>http</code> nemusí být vůbec přítomno, pokud však je, musí následovat možná <code>s</code> a zcela určitě <code>://</code>. To samé s doménou. Ta může být jen určitý počet znaků dlouhá, může obsahovat tečky (ale ne neomezené množství), samotná TLD má také určitá pravidla (minimálně co se týče délky) a to nemluvím o parametrech za adresou, které jsou téměř bez limitu.\r\n\r\nZkuste si takový objekt napsat. Ve výsledku se i nadále budou regulární výrazy psát ručně, nebo se ve složitějších případech vůbec používat nebudou.'),
(53,	'RSS a Sitemap jednoduše a rychle',	'rss-a-sitemap-jednoduse-a-rychle',	'Pár článků zpět jsem ukazoval několik příkladů, jak tvořit různé routy. Ukazoval jsem routy pro RSS i sitemap.xml. Nikde jsem však zatím neukazoval jak je to jednoduše realizovatelné. Dokonce tak jednoduše, že je škoda tyto soubory nevyužít na jakémkoliv webu, protože mají poměrně velký potenciál.\r\n\r\nZačněme HomepagePresenterem (DEV Nette):\r\n\r\n/--code php\r\n<?php\r\n\r\nclass HomepagePresenter extends BasePresenter {\r\n\r\n	/** @var \\Model\\Posts @inject */\r\n	public $posts;\r\n\r\n	public function renderRss() {\r\n		$this->template->posts = $this->posts->getAllPosts()->order(\'date DESC\')->limit(50);\r\n	}\r\n\r\n	public function renderSitemap() {\r\n		$this->template->sitemap = $this->posts->getAllPosts();\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nTímto říkám, že do šablon <code>rss.latte</code> a <code>sitemap.latte</code> předávám všechny články, nebo jen některé, protože nechci dělat dump celé databáze pro RSS.\r\n\r\nPro úplnost ještě \\Model\\Posts:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Model;\r\n\r\nclass Posts extends \\Nette\\Object {\r\n\r\n	/** @var \\Nette\\Database\\SelectionFactory @inject */\r\n	public $sf;\r\n\r\n	/**\r\n	 * @return Nette\\Database\\Table\\Selection\r\n	 */\r\n	public function getAllPosts() {\r\n		return $this->sf->table(\'posts\');\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nA následují samotné šablony, které musí dodržovat určitý formát, takže se lehce odlišují od normálních šablon. Sitemap.latte:\r\n\r\n/--code html\r\n{contentType application/xml}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\r\n	{foreach $sitemap as $s}\r\n		<url>\r\n			<loc>{link //Single:article $s->id}</loc>\r\n		</url>\r\n	{/foreach}\r\n</urlset>\r\n\\--\r\n\r\nRss.latte:\r\n\r\n/--code html\r\n{contentType application/xml}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<rss version=\"2.0\">\r\n	<channel>\r\n		<title>Martin Zlámal [BLOG]</title>\r\n		<link>{link //:Homepage:default}</link>\r\n		<description>Nejnovější články na blogu.</description>\r\n		<language>cs</language>\r\n\r\n		<item n:foreach=\"$posts as $post\">\r\n			<title>{$post->title}</title>\r\n			<link>{link //:Single:article $post->id}</link>\r\n			<description>{$post->body|texy|striptags}</description>\r\n		</item>\r\n	</channel>\r\n</rss>\r\n\\--\r\n\r\nA pro úplnou úplnost i router:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App;\r\nuse Nette;\r\nuse Nette\\Application\\Routers\\Route;\r\nuse Nette\\Application\\Routers\\RouteList;\r\nuse Nette\\Application\\Routers\\SimpleRouter;\r\n\r\nclass RouterFactory {\r\n\r\n	/**\r\n	 * @return \\Nette\\Application\\IRouter\r\n	 */\r\n	public function createRouter() {\r\n		$router = new RouteList();\r\n		$router[] = new Route(\'sitemap.xml\', \'Homepage:sitemap\');\r\n		// na RSS se dá odkazovat normálně bez routeru, nebo:\r\n		$router[] = new Route(\'rss.xml\', \'Homepage:rss\');\r\n		//...\r\n		$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\r\n		return $router;\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nJednoduché a na pár řádek. Jen vědět jak na to... (-:'),
(55,	'Důležitost titulku podruhé (a naposled)',	'dulezitost-titulku-podruhe-a-naposled',	'Také bych mohl začít slovy: \"Jsem to ale trouba.\" V následujících několika odstavcích bych rád navázal na článek, kde jsem upozorňoval na to, jak je <code>title</code> tag důležitý (http://www.zeminem.cz/portal-zcu-docasne-mimo-provoz). Což jsem si ostatně nechtěně vyzkoušel.\r\n\r\nJak málo stačí k umístění ve vyhledávači\r\n========================================\r\nTag <code>title</code> je jeden z nejvíce důležitých prvků na webové stránce. Zároveň je však jeden z nejvíce opomíjených. Proč se však opět vracím k již dávno vyřešenému problému? Krátce poté co jsem napsal onen osudný článek, mohl jsem pozorovat krásný efekt o kterém jsem psal. Vytvořil jsem totiž článek, jehož URL adresa měla změní <code>...cz/portal-zcu-docasne-mimo-provoz</code> a ve vyhledávači jsem vystupoval s titulkem <code>Portál ZČU dočasně mimo provoz | Martin Zlámal</code>.\r\n\r\nS tímto článkem jsem se okamžitě dostal na první stránku ve vyhledávači a dodnes pozoruji ve statistikách doslova tisíce zobrazení (což je na velikost mého bezvýznamného blogu opravdu hodně) na různé kombinace slov **portal** a **zcu**. Celkem jsem napočítal 7 variant což už chce zapojit fantazii pro spojení dvou slov tolika způsoby.\r\n\r\nJenže není zobrazení jako zobrazení\r\n===================================\r\nMožná by z toho měl kde kdo radost, ale mě osobně to moc nenadchlo. Je třeba se zamyslet nad tím, jaká je z tohoto zobrazení asi návštěvnost, když jsem jednak na pozici až pod tím správným portálem a pak má článek takový titulek, na který nikdo z vyhledávání dobrovolně nepřistoupí. Mizivou.\r\n\r\nOproti tomu naopak články, které byly napsány vyloženě z důvodu zájmu (http://www.zeminem.cz/routovani-v-nette-prakticky) mají mnohem větší procento prokliků. A to nelze srovnávat počty zobrazení jednotlivých článků. Každopádně zdaleka největšího CTR dosahují články, ve jsou popsány návrhové vzory v PHP (např. http://www.zeminem.cz/navrhovy-vzor-factory-method).\r\n\r\nRád bych z tohoto pozorování vyvodil jednoduchý závěr, který je však myslím více než jasný. Nemá smysl psát o jakémkoliv nápadu, ale má smysl psát o tématech, o které je evidentní zájem, což lze ve statistikách snadno pozorovat. Snad jen jednou za čas je zajímavé vybočit z řady a sledovat reakce návštěvníků.'),
(56,	'LaTeX šablona',	'latex-sablona',	'Všiml si také někdo, že většina uživatelů WYSIWYG textového editoru typu Word v něm menšinu času píší a většinu času se snaží ohnout editor tak, aby dělal to co má? Tak přesně toto mě přestalo bavit a začal jsem všechny práce sázet v LaTeXu. Pro psaní mám vytvořenou následující šablonu, kterou s výhodou používám a zatím jsou na ní od kontrolujících dobré ohlasy (pokud si toho někdo všiml).\r\n\r\n/--code tex\r\n\\documentclass[12pt]{article} % use larger type; default would be 10pt\r\n\\usepackage[czech]{babel}\r\n\\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)\r\n\r\n%%% PAGE DIMENSIONS\r\n\\usepackage{geometry} % to change the page dimensions\r\n% \\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}\r\n\\geometry{a4paper}\r\n\r\n\\usepackage{graphicx} % support the \\includegraphics command and options\r\n\\usepackage{wrapfig} % support the wrapfigure section\r\n\r\n\\usepackage{hyperref} % links in \\tableofcontents\r\n\\hypersetup{\r\n	colorlinks,\r\n	citecolor=black,\r\n	filecolor=black,\r\n	linkcolor=black,\r\n	urlcolor=black\r\n}\r\n\r\n% \\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent\r\n\r\n%%% PACKAGES\r\n\\usepackage{booktabs} % for much better looking tables\r\n\\usepackage{array} % for better arrays (eg matrices) in maths\r\n%\\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)\r\n\\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim\r\n\\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float\r\n% These packages are all incorporated in the memoir class to one degree or another...\r\n\\usepackage{tikz} % graphs\r\n\\usepackage{pgfplots}\r\n\\usepackage{float}\r\n\r\n%%% HEADERS & FOOTERS\r\n\\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry\r\n\\pagestyle{fancy} % options: empty , plain , fancy\r\n\\renewcommand{\\headrulewidth}{0pt} % customise the layout...\r\n\\lhead{}\\chead{}\\rhead{}\r\n\\lfoot{}\\cfoot{\\thepage}\\rfoot{}\r\n\r\n%%% SECTION TITLE APPEARANCE\r\n\\usepackage{sectsty}\r\n\\allsectionsfont{\\sffamily\\mdseries\\upshape} % (See the fntguide.pdf for font help)\r\n% (This matches ConTeXt defaults)\r\n\r\n%%% ToC (table of contents) APPEARANCE\r\n\\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC\r\n\\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents\r\n\\renewcommand{\\cftsecfont}{\\rmfamily\\mdseries\\upshape}\r\n\\renewcommand{\\cftsecpagefont}{\\rmfamily\\mdseries\\upshape} % No bold!\r\n\\newcommand{\\bigsize}{\\fontsize{35pt}{20pt}\\selectfont}\r\n\r\n%%% END Article customizations\r\n\r\n\\begin{document}\r\n\r\n	...\r\n\r\n\\end{document}\r\n\\--\r\n\r\nJsem relativně LaTeX nováčkem, proto by mě zajímalo. Používáte nějakou jinou šablonu? Lepší?');

DROP TABLE IF EXISTS `posts`;
CREATE TABLE `posts` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` text NOT NULL,
  `slug` text NOT NULL,
  `body` text NOT NULL,
  `date` datetime NOT NULL,
  `release_date` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `slug` (`slug`(255)),
  KEY `release_date` (`release_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `posts` (`id`, `title`, `slug`, `body`, `date`, `release_date`) VALUES
(2,	'Asymetrická šifra s veřejným klíčem',	'asymetricka-sifra-s-verejnym-klicem',	'O veřejné distribuci klíčů jsem již dříve psal. Pojďme se však podívat nejen na samotnou distribuci, ale i na myšlenku asymetrického šifrování. Prvně je však třeba vysvětlit několik důležitých věcí. Začněme tím, co vlastně znamená asymetrická šifra. Před myšlenkou asymetrického šifrování, jejíž autorem je Whitfield Diffie, se používalo výhradně šifrování symetrické, což znamená, že proces dešifrování zakódované zprávy je přesně opačný k procesu šifrování. Asymetrické šifrování však zavádí myšlenku použití jiného klíče na šifrování a jiného na dešifrování.\r\n\r\nJak to vyřešit? Jak je možné použít jiný klíč na šifrování a jiný na dešifrování? Již existoval koncept, který umožňoval výměnu  klíčů veřejně (a bezpečně). Stále byl však na principu synchronní komunikace odesílatele a příjemce, což nebylo optimální řešení a proto byl vymyšlen způsob jak tento problém obejít. Myšlenka byla jednoduchá. Příjemce musí vytvořit veřejný klíč, který následně zveřejní tak, aby byl veřejný opravdu pro všechny. V tomto případě je jasné, že by to nemělo smysl, pokud by se nepoužívala jednosměrná funkce šifrování, což je další pravidlo. A zároveň opět onen příjemce musí mít svůj tajný klíč, který dokáže informaci zašifrovanou veřejným klíčem dešifrovat. Z toho je patrná ta asymetričnost šifry. Nepoužívám stejný klíč na zašifrování a dešifrování jako u jiných šifer.\r\n\r\nTomuto systému se říká RSA (Ronald Riverst, Adi Shamir, Leonard Adleman). Pojďme se na něj teď podívat matematicky, protože teorie je moc obecná (a matematika zase složitá). Odesílatel zprávy si musí zvolit dvě velmi velká prvočísla (A, B). Tyto prvočísla mezi sebou vynásobí a dostane další ještě větší číslo (AB). Násobení je zcela triviální jednosměrná operace a systém RSA si zakládá na tom, že faktorizovat velké číslo je v reálním čase prakticky nemožné. Dále si odesílatel zvolí číslo C a to uveřejní společně s číslem AB. Toto jsou informace, které má každý k dispozici. Pro šifrování je nutné zprávu převést na číslo M (například binárně). Toto číslo se poté dosadí podle vzorce \"šifra\"= M^C (mod AB). Zpětně se pak informace dá velmi snadno dostat obráceným postupem se znalostí onoho součinu prvočísel zvolených na začátku. Bez znalosti těchto prvočísel je dešifrování téměř nemožné, což však také není úplně pravda viz poslední odstavec.\r\n\r\nJe zřejmé, že úspěch šifry spočívá ve zvolení dostatečně velkých prvočísel a mocnitele C, který by vzhledem k prvočíslům neměl mít žádného společného dělitele. Resp. přesněji čísla C a (A-1) * (B-1). Při představení RSA byl pro jeho reprezentaci uveřejněn zašifrovaný text s veřejným klíčem. Soutěžním úkolem bylo faktorizovat veřejný klíč na dvě složky a poté zprávu dešifrovat. Faktorizace trvala ve výsledku celkem 17 let, kdy tým 600 dobrovolníků oznámil 26. dubna 1994 činitele veřejného klíče. A jaký že byl ten klíč?\r\n\r\n/--code\r\nN = 114 381 625 757 888 867 669 235 779 976 146 612 010 218 296 721 242 362 562 561 842 935 706 935 245 733 897 830 597 123 563 958 705 058 989 075 147 599 290 026 879 543 541\r\n\\--\r\n\r\nDílčí prvočísla si nechám jako tajemství? (-:',	'2012-09-07 22:29:58',	'2012-09-07 22:29:58'),
(3,	'Lovec matematik',	'lovec-matematik',	'Znáte následující hádanku?\r\n\r\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Tam zastřelil medvěda. Jakou měl medvěd barvu?\r\n\r\nŘešení je více než jednoduché. Stačí si představit sférický trojúhelník vycházející ze severního pólu, který má všechny strany dlouhé 10 km (tedy každý úhel má 90°). Vzhledem k severnímu pólu je zřejmé, že medvěd musí být bílý. Existuje však ještě jiné řešení této hádanky čistě z geometrického (matematického chcete-li) hlediska? Vypusťme tedy medvěda a zamysleme se nad následující hádankou:\r\n\r\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Měl však smůlu a tak nic neulovil.\r\n\r\nJedno řešení už známe. Zamyslete se ještě jednou nad druhým řešením. Přesuňme se na jižní polokouli do libovolného bodu vzdáleného 11 591,55 m od jižního pólu. Pokud šel lovec nejprve 10 km na jih, dorazil do druhého bodu vzdáleného 1591,55 m od jižního pólu. Ze základní matematiky jistě všichni znají vzorec pro obvod kruhu O = 2&pi;r. Dosazením do vzorce zjistíme velmi zajímavou skutečnost. Obvod kruhu, tedy délka cesty na západ je dlouhá přibližně přesně 10 km. Lovec se tedy dostane na stejný bod vzdálený 1591,55 m od pólu a cestou na sever dojde do úplného začátku stejně tak jako tomu bylo při využití sférického trojúhelníku na opačné straně planety.\r\n\r\nPokud nebyl lovec matematik a neuvědomoval si tuto skutečnost, muselo být poměrně vyčerpávající dorazit po třiceti kilometrech do stejného místa...',	'2012-09-15 21:50:26',	'2012-09-15 21:50:26'),
(4,	'Tabulkový masakr',	'tabulkovy-masakr',	'Určitě znáte HTML a tím pádem znáte i tabulky. Pro jistotu připomenutí.\r\nTabulka se v HTML tvoří párovým tagem <code>&lt;table&gt;&lt;/table&gt;</code>, její řádky jsou <code>&lt;tr&gt;&lt;/tr&gt;</code> a buňky <code>&lt;td&gt;&lt;/td&gt;</code>. Buňky mají volitelné atributy <code>rowspan</code> a <code>colspan</code>. Tyto atributy určují, kolik bude buňka zabírat místa v řádce, resp. ve sloupci. Tyto znalosti stačí k pochopení pojmu \"tabulkový paradox\".\r\n\r\nPodívejte se na první ukázku:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\">A3</td>\r\n	</tr>\r\n	<tr>\r\n		<td colspan=\"3\">B1</td>\r\n	</tr>\r\n	<tr>\r\n		<td>C1</td>\r\n		<td>C3</td>\r\n	</tr>\r\n	<tr>\r\n		<td>D1</td>\r\n		<td>D3</td>\r\n	</tr>\r\n</table>\r\n\r\nZde je vidět co se stane, když roztáhneme buňku **A2** na tři řádky a zároveň roztáhneme buňku **B1** na tři sloupce podle následujícího kódu:\r\n/--code html\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\">A3</td>\r\n	</tr>\r\n	<tr>\r\n		<td colspan=\"3\">B1</td>\r\n	</tr>\r\n	<tr>\r\n		<td>C1</td>\r\n		<td>C3</td>\r\n	</tr>\r\n	<tr>\r\n		<td>D1</td>\r\n		<td>D3</td>\r\n	</tr>\r\n</table>\r\n\\--\r\nTam kde by měla být buňka **B2** vzniká krásné okénko do Narnie, které je společné jako pro druhý sloupec, tak pro druhý řádek.\r\n\r\nDůsledkem neopatrného zacházení se spojováním sloupců může být výsledek viditelný ve druhé ukázce:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\" colspan=\"4\">A3</td>\r\n		<td width=\"33%\" rowspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">B1</td>\r\n		<td width=\"33%\" rowspan=\"4\">B2</td>\r\n		<td width=\"33%\" colspan=\"4\">B3</td>\r\n		<td width=\"33%\" rowspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">C1</td>\r\n		<td width=\"33%\" rowspan=\"4\">C2</td>\r\n		<td width=\"33%\" colspan=\"4\">C3</td>\r\n		<td width=\"33%\" rowspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">D1</td>\r\n		<td width=\"33%\" rowspan=\"4\">D2</td>\r\n		<td width=\"33%\" colspan=\"4\">D3</td>\r\n		<td width=\"33%\" rowspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\n<br />\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">A1</td>\r\n		<td width=\"33%\" colspan=\"4\">A2</td>\r\n		<td width=\"33%\" rowspan=\"4\">A3</td>\r\n		<td width=\"33%\" colspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">B1</td>\r\n		<td width=\"33%\" colspan=\"4\">B2</td>\r\n		<td width=\"33%\" rowspan=\"4\">B3</td>\r\n		<td width=\"33%\" colspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">C1</td>\r\n		<td width=\"33%\" colspan=\"4\">C2</td>\r\n		<td width=\"33%\" rowspan=\"4\">C3</td>\r\n		<td width=\"33%\" colspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">D1</td>\r\n		<td width=\"33%\" colspan=\"4\">D2</td>\r\n		<td width=\"33%\" rowspan=\"4\">D3</td>\r\n		<td width=\"33%\" colspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\n<br />\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">A1</td>\r\n		<td width=\"33%\" rowspan=\"4\">A2</td>\r\n		<td width=\"33%\" colspan=\"4\">A3</td>\r\n		<td width=\"33%\" colspan=\"4\">A4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" rowspan=\"4\">B1</td>\r\n		<td width=\"33%\" colspan=\"4\">B2</td>\r\n		<td width=\"33%\" rowspan=\"4\">B3</td>\r\n		<td width=\"33%\" rowspan=\"4\">B4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">C1</td>\r\n		<td width=\"33%\" rowspan=\"4\">C2</td>\r\n		<td width=\"33%\" colspan=\"4\">C3</td>\r\n		<td width=\"33%\" colspan=\"4\">C4</td>\r\n	</tr>\r\n	<tr>\r\n		<td width=\"33%\" colspan=\"4\">D1</td>\r\n		<td width=\"33%\" rowspan=\"4\">D2</td>\r\n		<td width=\"33%\" colspan=\"4\">D3</td>\r\n		<td width=\"33%\" colspan=\"4\">D4</td>\r\n	</tr>\r\n</table>\r\n\r\nZa domácí úkol se pokuste napsat alespoň jednu podobnou tabulku bez nahlédnutí do zdrojového kódu... :-)\r\n\r\nA poslední perlička vyvracející tvrzení, že párový element <code>&lt;tr&gt;&lt;/tr&gt;</code> vytváří v tabulce novou řádku. Podívejte se na následující kód. Hádám, že už je vám jasné co se stane.\r\n/--code html\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\r\n</table>\r\n\\--\r\nVýsledek je vidět ve třetí ukázce:\r\n\r\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\r\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\r\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\r\n</table>\r\n\r\nVyzkoušejte, že se tabulkový paradox vykresluje ve všech prohlížečích stejně. Mám to tedy chápat tak, že tolik oblíbený Chrome je stejný shit jako IE? Kdepak... Jedná se opravdu o paradox, který by sice měl (prapodivné) řešení((výsledek potlačující paradox, vyvolávající další spory)), ale pak by byl porušen význam některých atributů buňek tabulky.',	'2012-10-06 22:58:12',	'0000-00-00 00:00:00'),
(6,	'Výpočet mediánu',	'vypocet-medianu',	'Zadání\r\n======\r\n\r\nNajděte v dostupné literatuře nebo vymyslete co nejlepší algoritmus pro výpočet mediánu.\r\nNezapomeňte na citaci zdrojů. Kritéria kvality v sestupném pořadí jsou: výpočetní složitost, \r\njednoduchost a implementační nenáročnost, paměťová spotřeba.\r\n\r\nDefinice\r\n========\r\n\r\nMedián je hodnota, která dělí seřazenou posloupnost na dvě stejně velké (co se množství týče)\r\nčásti. Důležitou vlastností mediánu je skutečnost, že není ovlivněn žádnou extrémní hodnotou,\r\njako je tomu například u průměru.\r\n\r\nAnalýza problému\r\n================\r\n\r\nExistuje několik způsobů jak daný problém vyřešit. První řešení bude velmi přímočaré. Jedná se\r\ntotiž o způsob, který zřejmě napadne každého jako první.\r\n\r\nPřímočaré řešení\r\n----------------\r\n\r\nToto řešení vlastně ani není tak hledání mediánu jako hledání algoritmicky nejrychlejšího způsobu\r\njako seřadit danou posloupnost čísel, protože pokud již máme seřazenou posloupnost, stačí zvolit\r\nprostřední prvek a získáme požadovaný medián. Tento poslední krok můžeme přirozeně vykonat\r\nse složitostí O(1). Seřadit posloupnost je možné lineárně logaritmickou složitostí O(NlogN) avšak\r\ns dodatečnou pamětí. Dodatečné paměti je samozřejmě možné se vyhnout, například použitím\r\nřadicího algoritmu Quicksort, vystavujeme se však nebezpečí kvadratické složitosti v nejhorším\r\npřípadě.\r\n\r\nPři zpětném pohledu je jasné, že nejvíce času strávíme řazením posloupnosti. Přitom řazení\r\nnebylo v zadání. Je to opravdu nutné? Následující algoritmy uvažují vstupní neseřazenou posloupnost\r\nstejně jako přímočaré řešení, ale nebudou vynakládat všechen svůj drahocený čas k\r\nřazení.\r\n\r\nAlgoritmus FIND\r\n---------------\r\n\r\nMetoda FIND je mnohem promyšlenější. Využívá techniky \"rozděl a panuj\", což je samo o sobě\r\nvelmi silná zbraň. FIND se chová velmi podobně jako již zmíněný Quicksort (oba algoritmy vymyslel\r\nTony Hoare) s tím, že hledá k-té nejmenší číslo, což je pouze zobecnění problému hledání\r\nmediánu.\r\n\r\nPři hledání postupujeme tak, že neseřazenou posloupnost projíždíme zleva, dokud nenalezneme\r\nprvek, který je větší (nebo roven) než námi zvolený pivot. Poté projíždíme posloupnost\r\nzprava, dokud nenarazíme na prvek, který je menší (nebo roven) pivotu. V tuto chvíli máme k\r\ndispozici dva prvky, a oba jsou na špatné straně, takže je prohodíme. V procesu zkoumání výměn\r\npokračujeme tak dlouho, dokud se nestřetneme. Tím je zajištěno, že jsou menší prvky než pivot\r\numístěny na levé straně a prvky větší než pivot zase na pravé.\r\n\r\nTím však ještě není medián určen, protože pivot byl zvolen (například) náhodně. Můžou\r\ntotiž nastat tři případy. V nejideálnější situaci je opravdu pivot mediánem a celý proces hledání\r\nmůžeme úspěšně ukončit. Může se však stát, že pivot nebude uprostřed posloupnosti, tedy byl\r\nzvolen nešťastně a není mediánem. V tom případě musíme hledat (např. rekurzivně) medián v\r\nhorní, popř. dolní části posloupnosti v závislosti na umístění aktuálního pivota. Jinak řečeno pokud\r\nbyl pivot moc malý, upravíme spodní mez posloupnosti. Pokud byl pivot naopak velký,\r\nupravíme horní mez posloupnosti a cel ý postup opakujeme. Pokud je pivot \"tak akorát\", pak je\r\nnaším mediánem.\r\n\r\nOčekávaný čas metody FIND je 4n, je nutné však připomenout, že je celé hledání založeno na\r\nQuicksortu, takže může složitost klesnout do kvadratické třídy. Existuje však i lineární řešení viz\r\nnásledující odstavce.\r\n\r\nAlgoritmus SELECT\r\n-----------------\r\n\r\nSELECT je svým chováním velmi podobný metodě FIND, ale dokáže eliminovat problém se\r\nšpatným zvolením pivota. Postupuje se následovně. Nejdříve rozdělíme neseřazenou posloupnost\r\nna pět částí s tím, že jedna nemusí být úplná. Následně najdeme medián každé skupiny. Z\r\nnalezených mediánů najdeme jeden celkový medián. Zde se však nesmíme ukvapit a použít tento\r\nmedián jako výsledný. Zatím to totiž byl pouze poměrně spolehlivý odhad vhodného pivota pro\r\ndělení celé posloupnosti.\r\n\r\nOpět mohou nastat tři příklady tzn. pivot je rovnou mediánem, pivot je větší, nebo je pivot\r\nmenší než medián. Při neshodě pivota s mediánem voláme SELECT rekurzivně do té doby,\r\nnež dostaneme požadovaný prvek. Postup hledání se může zdát dost zamotaný a rekurze na\r\npřehlednosti nepřidává, nicméně tento algoritmus má složitost O(n).\r\n\r\nSrovnání zmíněných algoritmů\r\n============================\r\n\r\nHledání mediánu pomocí přímočaré metody vede k seřazení posloupnosti (což nebylo zadáno).\r\nKromě toho získáme nejlepší složitost O(NlogN), což nemusí být úplně špatné vzhledem k nejhor\r\nší složitosti Quicksortu O(n^2), ale spotřebujeme více paměti. Oproti tomu algoritmus FIND\r\nnezabere více paměti než je nutné, jeho složitost však může být také kvadratická. Jednoznačně\r\nnejlepší řešení se zdá být metoda vyhledávání SELECT, která nejenže nespotřebuje dodatečnou\r\npaměť, ale navíc si udržuje lineární složitost což je alespoň podle běžně dostupné literatury\r\nnejlepší možné řešení.\r\n\r\nZávěr\r\n=====\r\n\r\nNezáleží-li nám na složitosti, nebo paměťové náročnosti, zvolíme přímočarou metodu hledání\r\nmediánu, která je nejjednodužší na implementaci a pochopení. V opačném případě zvolíme algoritmus\r\nSELECT, který je sice složitý, ale má vynikající výsledky.',	'2012-11-23 22:43:39',	'0000-00-00 00:00:00'),
(7,	'Osm návrhových přikázání',	'osm-navrhovych-prikazani',	'Právě mám rozečtenou knihu, která popisuje návrhové vzory v PHP. Mimo jiné autor popisuje pravidla při návrhu softwaru, která jsou prokládána velkým množstvím ukázek a vysvětlivek. Celkem je na třiceti stranách knihy (kde je rozebírán návrh) schován následující seznam pravidel.\r\n\r\n1) Přístup k údajům vždy v rámci třídy zapouzdřete a poskytněte metody, pomocí nichž lze dané údaje získat.\r\n2) Svá rozhraní navrhujte tak, aby je bylo možné později rozšířit.\r\n3) V metodách tříd nezapouzdřujte jen údaje, ale také algoritmy, díky čemuž budou komplexní operace implementované centrálně na jednom místě.\r\n4) Znovupoužitelnost kódu je lepší než duplicitní kód.\r\n5) Vyvarujte se monolitickým strukturám a rozložte je na co nejmenší části, které mohou být implementované nezávisle na sobě. Pokud používáte rozsáhlé příkazy <code>if/elseif/else</code> nebo <code>switch</code>, popřemýšlejte, zda by se nedaly nahradit zaměnitelnými třídami.\r\n6) Dědění vede k neflexibilním strukturám. Na kombinaci různých funkcí používejte raději kompozice objektů.\r\n7) Vždy programujte vůči rozhraní, a nikdy ne vůči konkrétní implementaci.\r\n8) Vyhýbejte se těsným závislostem mezi jednotlivými třídami aplikace a vždy upřednostňujte volné vazby tříd.\r\n\r\nDalší seznam který všichni znají, ale málokdo ho úplně dodržuje. (-:',	'2012-12-25 23:01:14',	'2012-12-25 23:01:14'),
(9,	'Návrhový vzor Singleton',	'navrhovy-vzor-singleton',	'Návrhový vzor Singleton je velmi známý. Má za úkol zajistit, že bude z určité třídy existovat pouze jedna instance. K této instanci poskytne globální přístupový bod. Jednoduché zadání, ale samotná implementace může být v PHP zákeřná. Proč? Tak prvně záleží na tom, jak budeme u návrhu striktní.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n}\r\n\\--\r\n\r\nTakovouto třídu lze totiž rovnou prohlásit za návrhový vzor Singleton. Dává to smysl, protože můžeme zavolat:\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = Object::getInstance();\r\n\\--\r\n\r\nTím se pokusíme vytvořit dvě instance této třídy, ve skutečnosti se však vytvoří jen jedna. Tyto objekty jsou identické, což lze dokázat jednoduchou zkouškou:\r\n\r\n/--code php\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\'; //TRUE\r\n} else {\r\n	echo \'$obj1 !== $obj2\';\r\n}\r\n\\--\r\n\r\nSingleton to je a nikdo nemůže říct ne. Jak jsem však již psal, záleží na tom, jak budeme u návrhu striktní, protože by to nebylo PHP, kdyby neexistovalo několik otazníků a háčků. Pravděpodobně spoustu lidí totiž napadne, že metoda <code>getInstance()</code> je sice hezká, ale vůbec ji nemusím použít. V takovém případě celý princip Singletona padá.\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = new Object();\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nTo je jasné, zatím ve třídě neexistuje žádný mechanismus, který by zakázal používání konstruktoru. K tomu je potřeba pouze malá úprava třídy.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n}\r\n\\--\r\n\r\nV tento moment již nepůjde objekt vytvořit pomocí operátoru <code>new</code>. Případný pokus skončí fatální chybou. Nebylo by to však PHP, kdyby neexistovalo několik dalších otazníků a háčků. S ledovým klidem si totiž mohu první vytvořený objekt naklonovat a tím opět získám dvě nezávislé instance jedné třídy. Ale to jsem přece nechtěl!\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = clone $obj1;\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nProti tomuto postupu se mohu bránit opět podobným způsobem jako u konstruktoru.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	private function __clone() {}\r\n}\r\n\\--\r\n\r\nPokus o naklonování již vytvořené instance pomocí metody <code>getInstance()</code> skončí opět fatální chybou. Jenže nebylo by to PHP, kdyby... Co se stane, když vytoření objekt serializuji a pak ho zase deserializuji?\r\n\r\n/--code php\r\n$obj1 = Object::getInstance();\r\n$obj2 = unserialize(serialize($obj1));\r\n\r\nif($obj1 === $obj2) {\r\n	echo \'$obj1 === $obj2\';\r\n} else {\r\n	echo \'$obj1 !== $obj2\'; //TRUE\r\n}\r\n\\--\r\n\r\nTo už začíná být poněkud otravné. Ale tak dobře, i to se dá ošéfovat.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	private function __clone() {}\r\n	private function __wakeup() {}\r\n}\r\n\\--\r\n\r\nToto už sice vrátí jen warning, ale víme o tom. Schválně jsem nepsal, že se to vše dá ošetřit, protože je to spíše zákaz (popř. upozornění). Je samozřejmě možné (lepší) vracet různé vyjímky atd. Stejně tak je spousta variant jak psát přítupové modifikátory k metodám. To jednoduše vše zaleží na tom, co od Singleton objektu očekáváme a kdo objekt používá, protože jak jsem již psal, úplně klidně stačí Singleton s jednou metodou <code>getInstance()</code>. Svoji funkci plní, tečka.\r\n\r\n/--code php\r\n<?php\r\nclass Object {\r\n	private static $instance = null;\r\n	public static function getInstance() {\r\n		if(self::$instance === null) {\r\n			self::$instance = new self;\r\n		}\r\n		return self::$instance;\r\n	}\r\n	protected function __construct() {}\r\n	public final function __clone() {\r\n		throw new Exception(\'Objekt nelze klonovat!\');\r\n	}\r\n	public final function __wakeup() {\r\n		throw new Exception(\'Objekt nelze deserializovat!\');\r\n	}\r\n}\r\n\\--',	'2012-12-26 20:38:01',	'0000-00-00 00:00:00'),
(10,	'Návrhový vzor Factory Method',	'navrhovy-vzor-factory-method',	'Návrhový vzor Factory Method má za úkol definovat rozhraní pro vytváření objektů s tím, že vlastní tvorbu instancí přenechává potomkům. Samotný návrhový vzor tedy tvoří například tyto dvě třídy.\r\n\r\n/--code php\r\n<?php\r\nabstract class ACreator {\r\n	protected $attribute;\r\n	public function __construct($attribute) {\r\n		$this->attribute = $attribute;\r\n	}\r\n	abstract public function createConcreteObject();\r\n}\r\n\\--\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteCreator extends ACreator {\r\n	public function createConcreteObject() {\r\n		$concreteObject = new ConcreteObject($this->attribute);\r\n		return $concreteObject;\r\n	}\r\n}\r\n\\--\r\n\r\nAby však tento vzor měl nějaký smysl, je potřeba ještě minimálně jedna třída od které se budou dělat instance (ConcreteObject).\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteObject implements IObject {\r\n	protected $attribute;\r\n	public function __construct($attribute) {\r\n		$this->attribute = $attribute;\r\n	}\r\n	public function test() {\r\n		echo $this->attribute;\r\n	}\r\n}\r\n\\--\r\n\r\nPřípadně jeho rozhraní:\r\n\r\n/--code php\r\n<?php\r\ninterface IObject {\r\n	public function test();\r\n}\r\n\\--\r\n\r\nVraťme se však na začátek. Vytvářet objekty všichni umí. Slouží k tomu známý operátor <code>new</code>. Na tom není nic divného, ale jen do chvíle, než se nad tím zamyslíte. Představte si rozsáhlou aplikaci, kde na každém rohu potřebujete vytvořit instanci určitého objektu. Takže jako vždy zavoláte operátor <code>new</code> a předáte všechny potřebné argumenty. A pak se to stane. Najednou zjistíte, že nutně potřebujete přidat do konstruktoru argument/y a máte týden co dělat. K tomu se právě hodí vytvořit si továrnu na tyto instance, kdy budeme pouze volat metodu pro její vytvoření, ale to jak se vytvoří necháme na továrně. Obecně se ve světě OOP velmi často dělá, že nějakou práci prostě necháme na někom jiném. Je to funkční a pohodlný přístup. :-)\r\n\r\nPokud tedy zapomenu na to, že existují nějaké třídy Creator, tak by použití třídy ConcreteObject vypadalo asi takto:\r\n\r\n/--code php\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance->test();\r\n\\--\r\n\r\nPři zapojení továrny je použití zdánlivě složitější.\r\n\r\n/--code php\r\n$factory = new ConcreteCreator(\'TEST\');\r\n$instance = $factory->createConcreteObject();\r\n$instance->test();\r\n\\--\r\n\r\nPřidaná hodnota tohoto postupu je však velká. Již nejsme vázání na konkrétní implementaci objektu ConcreteObject. Vlastně nás to vůbec nezajímá. Víme, že pro jeho tvorbu potřebuje továrna nějaký atribut a to, jestli pak ještě další tři přidá, nebo ne, nám může být úplně jedno. Kdo stále ještě nevěří, že je tento postup výhodný, nechť si vyzkouší vytvořit několik instancí stejného objektu (hloupý, ale názorný příklad).\r\n\r\n/--code php\r\n// pomocí operátoru new:\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n$instance = new ConcreteObject(\'TEST\');\r\n\r\n// pomocí továrny:\r\n$factory = new ConcreteCreator(\'TEST\');\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n\\--\r\n\r\nA teď přidejme nový atribut - aktuální rok.\r\n\r\n/--code php\r\n// pomocí operátoru new:\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\r\n\r\n// pomocí továrny:\r\n$factory = new ConcreteCreator(\'TEST\', date(\'Y\'));\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n$instance = $factory->createConcreteObject();\r\n\\--\r\n\r\nKrom toho, že by mě za chvíli přestalo bavit do každého konstruktoru kopírovat nový atribut, tak jsem také mohl udělat o hodně více chyb než u továrny. Pravdou je, že jsem musel upravit ještě pár tříd:\r\n\r\n/--code php\r\n<?php\r\nclass ConcreteObject implements IObject {\r\n	protected $attribute;\r\n	protected $year;\r\n	public function __construct($attribute, $year) {\r\n		$this->attribute = $attribute;\r\n		$this->year = $year;\r\n	}\r\n	// ...\r\n}\r\n\r\nabstract class ACreator {\r\n	protected $attribute;\r\n	protected $year;\r\n	public function __construct($attribute, $year) {\r\n		$this->attribute = $attribute;\r\n		$this->year = $year;\r\n	}\r\n	abstract public function createConcreteObject();\r\n}\r\n\r\nclass ConcreteCreator extends ACreator {\r\n	public function createConcreteObject() {\r\n		$concreteObject = new ConcreteObject($this->attribute, $this->year);\r\n		return $concreteObject;\r\n	}\r\n}\r\n\\--\r\n\r\nNicméně křivka výhod při používání továrny velmi rychle překoná svým stoupáním křivku lenosti při používání operátoru new.\r\n\r\nMimochodem vzpomeňte si na \"osm návrhových přikázání\":http://www.zeminem.cz/osm-navrhovych-prikazani, kde se také říká, že máme vždy programovat vůči rozhraní, a nikdy ne vůči konkrétní implementaci, což tento návrhový vzor perfektně splňuje.',	'2012-12-27 23:52:39',	'0000-00-00 00:00:00'),
(11,	'Nette 2.1-dev CliRouter',	'nette-2-1-dev-clirouter',	'Routování CLI((Command Line Interface)) aplikací je oblast, o které se v Nette moc nemluví. A když mluví, tak divně (nebo staře). Což na jednu stranu dává smysl, protože tato routa existuje už od roku 2009. Na druhou stranu je to zvláštní, protože je stále experimentální.\r\n\r\n> The unidirectional router for CLI.\r\n> \r\n> (experimental)\r\n\r\nDokonce se už mluvilo o tom, že se zruší. No snad se to nestane...\r\n\r\nProč o tom mluvím? Rád bych ukázal, jak se dá v nastávající verzi Nette tato routa použít. V nové verzi Nette se již routy nepíší do bootsrap.php jak tomu bylo (alespoň myslím) dříve. Tentokrát je v adresářové struktuře soubor router/**RouterFactory.php**, který se právě o routování postará. Tento soubor může vypadat například takto:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App;\r\n\r\nuse Nette,\r\n	Nette\\Application\\Routers\\RouteList,\r\n	Nette\\Application\\Routers\\Route,\r\n	Nette\\Application\\Routers\\CliRouter;\r\n\r\n/**\r\n * Router factory.\r\n */\r\nclass RouterFactory {\r\n\r\n	private $container;\r\n\r\n	public function __construct(Nette\\DI\\Container $container) {\r\n		$this->container = $container;\r\n	}\r\n\r\n	/**\r\n	 * @return \\Nette\\Application\\IRouter\r\n	 */\r\n	public function createRouter() {\r\n		$router = new RouteList();\r\n		if ($this->container->parameters[\'consoleMode\']) {\r\n			$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\r\n		} else {\r\n			$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\r\n			$router[] = new Route(\'user/<presenter>/<action>[/<id>]\', array(\r\n				\'module\' => \'User\',\r\n				\'presenter\' => \'Board\',\r\n				\'action\' => \'default\',\r\n			));\r\n			$router[] = new Route(\'<presenter>/<action>[/<id>]\', array(\r\n				\'module\' => \'Front\',\r\n				\'presenter\' => \'Homepage\',\r\n				\'action\' => \'default\',\r\n			));\r\n		}\r\n		return $router;\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nToto je reálná funkční ukázka (ze které jsem něco nepodstatného umazal). Jak je vidět, tak aplikaci mám rozdělenou na moduly, takže defaultní routa ukazuje do modulu Front, pak je k dispozici User modul, link na RSS a konečně CliRouter, který se naroutuje pouze v případě, že běží aplikace v konzolovém módu (CLI).\r\n\r\nPokud se teď přesunu k presenterové části modulu Cli, mohu zde umístit dvě třídy. Klasický BasePresenter, který bude pro jistotu kontrolovat, jestli se opravdu jedná o consoleMode například takto:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App\\CliModule;\r\n\r\nuse Nette;\r\n\r\nabstract class BasePresenter extends Nette\\Application\\UI\\Presenter {\r\n\r\n	public function startup() {\r\n		parent::startup();\r\n		if (!$this->context->parameters[\'consoleMode\']) {\r\n			throw new Nette\\Security\\AuthenticationException;\r\n		}\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nNo a pak už stačí jen CliPresenter, který bude dědit od BasePresenteru, takže vždy dojde ke kontrole. Zde stačí metoda action*(), která se spustí podle naroutování. V mém případě se tedy jedná o actionCron():\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App\\CliModule;\r\n\r\nuse Nette;\r\n\r\nclass CliPresenter extends BasePresenter {\r\n\r\n	public function actionCron() {\r\n		echo \'FUNGUJU!\';\r\n		$this->terminate();\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nA teď to nejdůležitější! Aplikace se spustí pomocí terminálu jednoduchým příkazem \"<code>php index.php</code>\". Samozřejmě je nutné ukázat na index Nette aplikace. No a samozřejmě se mohu odkázat i na jinou část aplikace dopsání parametru. Pokud bych chtěl podle výše uvedených souborů přejít na hlavní stránku, stačí napsat pouze \"<code>php index.php Fron:Homepage:default</code>\".',	'2013-03-17 22:02:36',	'0000-00-00 00:00:00'),
(44,	'Portál ZČU dočasně mimo provoz',	'portal-zcu-docasne-mimo-provoz',	'Zvolit správný titulek pro webovou stránku je naprosto klíčové.\r\nMnozí programátoři si to neuvědomují a ti ostatní chybují.\r\nTitulek je jedna z nejdůležitějších věcí, podle které se\r\nlidé rozhodují jestli na web vstoupit, nebo ne. Proto je třeba mít\r\n<code>title</code> tag na každé stránce jiný a je potřeba myslet\r\ni na stránky, které se zase až tak často nezobrazují.\r\nJe totiž docela smůla, když vás google bot indexuje během profylaxe\r\nserverů:\r\n\r\n[* http://www.zeminem.cz/img/pictures/portal.png *]\r\n\r\nWeb má poté odpuzující titulek, i když už dávno funguje.\r\nNutno však říct, že je to občas problém ohlídat.\r\nTak alespoň to pobaví... (-:',	'2013-07-28 21:58:42',	'0000-00-00 00:00:00'),
(45,	'Testování presenterů v Nette',	'testovani-presenteru-v-nette',	'Tak toto je přesně to téma o kterém se naustále mluví, ale tím to z velké části končí.\r\nNemá smysl zabývat se tím, jestli testovat, nebo ne. Na to už si každý přijde sám.\r\nV následujících odstavcích bych rád předvedl myšlenku jak si\r\nušetřit pár řádek kódu při testech (\\Nette\\Tester).\r\n\r\nNezbytná teorie\r\n===============\r\n\r\nPro testování presenterů je zapotřebí získat továrnu na presentery PresenterFactory\r\na následně daný presenter vyrobit. Například takto:\r\n\r\n/--code php\r\n$presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\r\n$this->presenter = $presenterFactory->createPresenter(\'Front:Homepage\');\r\n\\--\r\n\r\nK tomu je zapotřebí \\Nette\\DI\\Container, který získáme například v konstruktoru, nebo\r\npomocí inject anotace.\r\n\r\nNásledně je třeba vytvořit požadavek, ten spustit a testovat výslednou odpověď:\r\n\r\n/--code php\r\n$request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\r\n$response = $this->presenter->run($request);\r\n\\--\r\n\r\nPrávě nad vrácenou odpovědí lze spustit testovací sadu, která bude testovat, \r\nzda byla například získána textová odpověď a tedy jestli se jedná o šablonu:\r\n\r\n/--code php\r\n\\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\r\n\\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\r\n\\--\r\n\r\nJe také vhodné otestovat samotný HTML kód. Již mě to párkrát upozornilo na\r\nnevalidní kód, což se může stát, pokud se šablona skládá z hodně include částí.\r\nNevalidní ve smyslu například dvojité HTML ukončovací značky:\r\n\r\n/--code php\r\n$html = (string)$response->getSource();\r\n$dom = \\Tester\\DomQuery::fromHtml($html);\r\n\\Tester\\Assert::true($dom->has(\'title\'));\r\n\\--\r\n\r\nPsaní, psaní, psaní...\r\n======================\r\n\r\nPředchozí teorie je zapotřebí opakovat pro každý presenter. Už jen proto, že je třeba\r\nvytvořit pokaždé nový požadavek. Nicméně je jasné, že to po otestování FrontModule\r\nzačne být lehce kopírovací nuda.\r\n\r\nJe tedy vhodné vytvořit si třídu, která ušetří spoustu řádek.\r\nMůj první návrh vypadá přibližně takto:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Test;\r\n\r\nclass Presenter extends \\Nette\\Object {\r\n\r\n        private $container;\r\n        private $presenter;\r\n        private $presName;\r\n\r\n        public function __construct(\\Nette\\DI\\Container $container) {\r\n                $this->container = $container;\r\n        }\r\n\r\n        /**\r\n         * @param $presName string Fully qualified presenter name.\r\n         */\r\n        public function init($presName) {\r\n                $presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\r\n                $this->presenter = $presenterFactory->createPresenter($presName);\r\n                $this->presenter->autoCanonicalize = FALSE;\r\n                $this->presName = $presName;\r\n        }\r\n\r\n        public function test($action, $method = \'GET\', $params = array(), $post = array()) {\r\n                $params[\'action\'] = $action;\r\n                $request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\r\n                $response = $this->presenter->run($request);\r\n                return $response;\r\n        }\r\n\r\n        public function testAction($action, $method = \'GET\', $params = array(), $post = array()) {\r\n                $response = $this->test($action, $method, $params, $post);\r\n\r\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\r\n                \\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\r\n\r\n                $html = (string)$response->getSource();\r\n                $dom = \\Tester\\DomQuery::fromHtml($html);\r\n                \\Tester\\Assert::true($dom->has(\'title\'));\r\n\r\n                return $response;\r\n        }\r\n\r\n        public function testForm($action, $method = \'POST\', $post = array()) {\r\n                $response = $this->test($action, $method, $post);\r\n\r\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\RedirectResponse);\r\n\r\n                return $response;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nTestování samotných presenterů je pak již otázkou několika málo řádek:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Test;\r\n\r\n$container = require __DIR__ . \'/../bootstrap.php\';\r\n\r\nclass HomepagePresenterTest extends \\Tester\\TestCase {\r\n\r\n        public function __construct(\\Nette\\DI\\Container $container) {\r\n                $this->tester = new \\Test\\Presenter($container);\r\n        }\r\n\r\n        public function setUp() {\r\n                $this->tester->init(\'Front:Homepage\');\r\n        }\r\n\r\n        public function testRenderDefault() {\r\n                $this->tester->testAction(\'default\');\r\n        }\r\n\r\n}\r\n\r\nid(new HomepagePresenterTest($container))->run();\r\n\\--\r\n\r\nTakto chápu testování presenterů v Nette já. Dále budu směrovat testy tak, abych nemusel psát téměř nic\r\na měl jsem otestováno téměř všechno. Myslím si, že toto je jediná cesta jak se přinutit k testování.\r\nNelze se již vymlouvat na to, že je to spousta psaní navíc. Není.',	'2013-07-28 22:36:38',	'0000-00-00 00:00:00'),
(46,	'CRON validátor',	'cron-validator',	'A jak už to tak bývá, tak opět ohnutý pro Nette. Tentokráte inspirovaný řešením ISPConfigu.\r\n\r\nMůžeš tohle, nesmíš tamto\r\n=========================\r\n\r\nSamotný CRON zápis je velmi rozmanitý a proto se omezím pouze na základní požadavky:\r\n\r\n1)  obecně jsou povolené znaky <code>0-9</code>, <code>čárka</code>, <code>*</code>, <code>-</code>, <code>/</code>\r\n2)  <code>čárka</code>, <code>-</code> a <code>/</code> nesmí být nikdy vedle sebe\r\n3)  <code>x</code>, <code>x-y</code>, <code>x/y</code>, <code>x-y/z</code>, <code>*/x</code>, kde x,y,z jsou čísla z povolených časových rozsahů\r\n4)  povolený rozsah pro minuty: <strong>0-59</strong>\r\n5)  povolený rozsah pro hodiny: <strong>0-23</strong>\r\n6)  povolený rozsah pro dny měsíce: <strong>1-31</strong>\r\n7)  povolený rozsah pro měsíce: <strong>1-12</strong>\r\n8)  povolený rozsah pro dny v týdnu: <strong>0-6</strong>\r\n\r\nTo je myslím slušný výčet pravidel pro zvalidování jednoho příkazu.\r\nÚkolem tohoto článku není ukázat jak tvořit a zpracovávat formulář, ale bude vhodné\r\numístit sem celý kód alespoň vytvoření:\r\n\r\n/--code php\r\n/**\r\n  * @return Nette\\Application\\UI\\Form\r\n  */\r\nprotected function createComponentAddCron() {\r\n	$form = new Nette\\Application\\UI\\Form;\r\n	$form->addProtection();\r\n	$form->addText(\'minutes\', \'Minuty:\')\r\n		->addRule(\\Fresh\\ValidateCron::MINUTES, \'Nevalidní CRON zápis - minuty.\');\r\n	$form->addText(\'hours\', \'Hodiny:\')\r\n		->addRule(\\Fresh\\ValidateCron::HOURS, \'Nevalidní CRON zápis - hodiny.\');\r\n	$form->addText(\'mdays\', \'Dny měsíce:\')\r\n		->addRule(\\Fresh\\ValidateCron::MDAYS, \'Nevalidní CRON zápis - mdays.\');\r\n	$form->addText(\'months\', \'Měsíce:\')\r\n		->addRule(\\Fresh\\ValidateCron::MONTHS, \'Nevalidní CRON zápis - měsíce.\');\r\n	$form->addText(\'wdays\', \'Dny v týdnu:\')\r\n		->addRule(\\Fresh\\ValidateCron::WDAYS, \'Nevalidní CRON zápis - wdays.\');\r\n	$form->addText(\'command\', \'Příkaz:\')\r\n		->setRequired(\'Vyplňte prosím příkaz, který bude CRON spouštět.\');\r\n	$form->addSubmit(\'save\', \'Přidat nový CRON\');\r\n	$form->onSuccess[] = $this->addCronSucceeded;\r\n	return $form;\r\n}\r\n\\--\r\n\r\nA rovnou bez hloupých povídání celý validátor:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Fresh;\r\n\r\n/**\r\n * Class ValidateCron - inspired by ISPConfig\r\n * @package Fresh\r\n */\r\nclass ValidateCron extends \\Nette\\Object {\r\n\r\n        const MINUTES = \'\\Fresh\\ValidateCron::validateMinutes\';\r\n        const HOURS = \'\\Fresh\\ValidateCron::validateHours\';\r\n        const MDAYS = \'\\Fresh\\ValidateCron::validateMdays\';\r\n        const MONTHS = \'\\Fresh\\ValidateCron::validateMonths\';\r\n        const WDAYS = \'\\Fresh\\ValidateCron::validateWdays\';\r\n\r\n        public static function validateMinutes(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 59);\r\n        }\r\n\r\n        public static function validateHours(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 23);\r\n        }\r\n\r\n        public static function validateMdays(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 31);\r\n        }\r\n\r\n        public static function validateMonths(\\Nette\\Forms\\IControl $control) {\r\n                if($control->getValue() != \'@reboot\') { // allow value @reboot in month field\r\n                        return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 12);\r\n                } else {\r\n                        return TRUE;\r\n                }\r\n        }\r\n\r\n        public static function validateWdays(\\Nette\\Forms\\IControl $control) {\r\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 6);\r\n        }\r\n\r\n        private static function validateTimeFormat($value, $min_entry = 0, $max_entry = 0) {\r\n                if (preg_match(\"\'^[0-9\\-\\,\\/\\*]+$\'\", $value) == false) { // allowed characters are 0-9, comma, *, -, /\r\n                        return FALSE;\r\n                } elseif (preg_match(\"\'[\\-\\,\\/][\\-\\,\\/]\'\", $value) == true) { // comma, - and / never stand together\r\n                        return FALSE;\r\n                }\r\n                $time_list = explode(\",\", $value);\r\n                foreach ($time_list as $entry) {\r\n                        // possible value combinations:\r\n                        // x               =>      ^(\\d+)$\r\n                        // x-y             =>      ^(\\d+)\\-(\\d+)$\r\n                        // x/y             =>      ^(\\d+)\\/([1-9]\\d*)$\r\n                        // x-y/z           =>      ^(\\d+)\\-(\\d+)\\/([1-9]\\d*)$\r\n                        // */x             =>      ^\\*\\/([1-9]\\d*)$\r\n                        // combined regex  =>      ^(\\d+|\\*)(\\-(\\d+))?(\\/([1-9]\\d*))?$\r\n                        if (preg_match(\"\'^(((\\d+)(\\-(\\d+))?)|\\*)(\\/([1-9]\\d*))?$\'\", $entry, $matches) == false) {\r\n                                return FALSE;\r\n                        }\r\n                        // matches contains:\r\n                        // 1       =>      * or value or x-y range\r\n                        // 2       =>      unused\r\n                        // 3       =>      value if [1] != *\r\n                        // 4       =>      empty if no range was used\r\n                        // 5       =>      2nd value of range if [1] != * and range was used\r\n                        // 6       =>      empty if step was not used\r\n                        // 7       =>      step\r\n                        if ($matches[1] == \"*\") {\r\n                                // not to check\r\n                        } else {\r\n                                if ($matches[3] < $min_entry || $matches[3] > $max_entry) { // check if value is in allowed range\r\n                                        return FALSE;\r\n                                } elseif (isset($matches[4]) && ($matches[5] < $min_entry || $matches[5] > $max_entry || $matches[5] <= $matches[3])) {\r\n                                        // check if value is in allowed range and not less or equal to first value\r\n                                        return FALSE;\r\n                                }\r\n                        }\r\n                        if (isset($matches[6]) && ($matches[7] < 2 || $matches[7] > $max_entry - 1)) { // check if step value is valid\r\n                                return FALSE;\r\n                        }\r\n                } // end foreach entry loop\r\n                return TRUE;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nValidátorem navrácené errory lze vykreslit například takto ručně (nově v DEV Nette):\r\n\r\n/--code html\r\n{form $form}\r\n\r\n<ul class=\"error\" n:if=\"$form->allErrors\">\r\n        <li n:foreach=\"$form->allErrors as $error\">{$error}</li>\r\n</ul>\r\n\r\n...\r\n\r\n{/form}\r\n\\--',	'2013-07-28 22:53:32',	'0000-00-00 00:00:00'),
(47,	'Třída pro připojení k FIO API',	'trida-pro-pripojeni-k-fio-api',	'Další užitečný úryvek, který je škoda nechat ležet v Git repozitářích.\r\nA opět uzpůsobený pro používání s Nette FW.\r\n\r\nNedávno jsem psal o tom, jak používat CLI router v Nette (http://www.zeminem.cz/nette-2-1-dev-clirouter).\r\nPrávě pomocí tohoto routeru je vhodné kontrolovat bankovní výpisy - například pomocí cronu:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App\\CliModule;\r\n\r\nuse Nette;\r\nuse Nette\\Diagnostics\\Debugger;\r\n\r\n/**\r\n * Class CliPresenter\r\n * @package App\\CliModule\r\n */\r\nclass CliPresenter extends BasePresenter {\r\n\r\n        /** @var \\Fio @inject */\r\n        public $fio;\r\n        ...\r\n\r\n        public function actionCron() {\r\n                $this->checkFio(); // FIO vs. nezaplacené objednávky\r\n                ...\r\n                $this->terminate();\r\n        }\r\n\r\n        /**\r\n         * Zkontroluje bankovní účet, porovná s databází a zaplacené objednávky změní na status PAID.\r\n         */\r\n        private function checkFio() {\r\n                try {\r\n                        $transactions = $this->fio->transactions();\r\n                        $unpaid = $this->orders->selectUnpaidOrders(); //získání nezaplacených objednávek\r\n                        //array_intersect() - zde samotné zpracování\r\n                        ...\r\n                } catch (\\Exception $exc) {\r\n                        Debugger::log($exc->getMessage() . \' FILE: \' . $exc->getFile() . \' on line: \' . $exc->getLine(), Debugger::WARNING);\r\n                        echo $exc->getMessage() . EOL;\r\n                }\r\n        }\r\n}\r\n\\--\r\n\r\nK tomu se hodí právě následující třída:\r\n\r\n/--code php\r\n<?php\r\n\r\n/**\r\n * Class Fio\r\n */\r\nclass Fio extends \\Nette\\Object {\r\n\r\n        private $token;\r\n        private $rest_url = \'https://www.fio.cz/ib_api/rest/\';\r\n\r\n        /**\r\n         * @param string $token SECURE\r\n         */\r\n        public function __construct($token) {\r\n                $this->token = $token;\r\n        }\r\n\r\n        /**\r\n         * Pohyby na účtu za určené období.\r\n         * JSON only!\r\n         * @param string $from\r\n         * @param string $to\r\n         */\r\n        public function transactions($from = \'-1 month\', $to = \'now\') {\r\n                $from = \\Nette\\DateTime::from($from)->format(\'Y-m-d\');\r\n                $to = \\Nette\\DateTime::from($to)->format(\'Y-m-d\');\r\n                $url = $this->rest_url . \'periods/\' . $this->token . \'/\' . $from . \'/\' . $to . \'/transactions.json\';\r\n                return $this->parseJSON($this->download($url));\r\n        }\r\n\r\n        /**\r\n         * Oficiální výpisy pohybů z účtu.\r\n         * JSON only!\r\n         * @param $id\r\n         * @param null $year\r\n         * @return array|mixed\r\n         */\r\n        public function transactionsByID($id, $year = NULL) {\r\n                if ($year === NULL) {\r\n                        $year = date(\'Y\');\r\n                }\r\n                $url = $this->rest_url . \'by-id/\' . $this->token . \'/\' . $year . \'/\' . $id . \'/transactions.json\';\r\n                return $this->parseJSON($this->download($url));\r\n        }\r\n\r\n        /**\r\n         * Pohyby na účtu od posledního stažení.\r\n         * JSON only!\r\n         * @return array|mixed\r\n         */\r\n        public function transactionsLast() {\r\n                $url = $this->rest_url . \'last\' . $this->token . \'/transactions.json\';\r\n                return $this->parseJSON($this->download($url));\r\n        }\r\n\r\n        /**\r\n         * @param $url\r\n         * @return mixed\r\n         * @throws \\Exception\r\n         */\r\n        private function download($url) {\r\n                if (!extension_loaded(\'curl\')) {\r\n                        throw new \\Exception(\'Curl extension, does\\\'t loaded.\');\r\n                }\r\n                $curl = curl_init();\r\n                curl_setopt($curl, CURLOPT_URL, $url);\r\n                curl_setopt($curl, CURLOPT_HEADER, FALSE);\r\n                curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\r\n                curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\r\n                curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);\r\n                $result = curl_exec($curl);\r\n                return $result;\r\n                //return file_get_contents($url); //ALTERNATIVE\r\n        }\r\n\r\n        /**\r\n         * @param $data\r\n         * @return array|mixed\r\n         */\r\n        private function parseJSON($data) {\r\n                $json = json_decode($data);\r\n                if($json === NULL) {\r\n                        //Moc ryhlé požadavky na Fio API\r\n                        throw new \\Exception(\'Fio API overheated. Please wait...\');\r\n                        //Když se posílá stále moc požadavků, tak se to z Exception nikdy nevyhrabe. Musí se opravdu počkat.\r\n                }\r\n                if(!$json->accountStatement->transactionList) {\r\n                        return $json; // There are no transactions (header only)\r\n                }\r\n                $payments = array();\r\n                foreach ($json->accountStatement->transactionList->transaction as $row) {\r\n                        $out = array();\r\n                        foreach ($row as $column) {\r\n                                if ($column) {\r\n                                        $out[$column->id] = $column->value; //v $column->name je název položky\r\n                                        /*\r\n                                         * 0  - Datum\r\n                                         * 1  - Částka (!)\r\n                                         * 5  - Variabilní symbol (!)\r\n                                         * 14 - Měna (!)\r\n                                         * Hodnoty (!) se musí použít ke kontrole správnosti...\r\n                                         */\r\n                                }\r\n                        }\r\n                        array_push($payments, $out);\r\n                }\r\n                return $payments;\r\n        }\r\n\r\n}\r\n\\--\r\n\r\nS tím, že je zapotřebí předat FIO klíč z neonu. FIO třída se automaticky injectuje, tzn. že i konstruktor\r\ntéto třídy bude doplněn automaticky. Je jen zapotřebí přidat do neonu onu konfiguraci:\r\n\r\n/--code neon\r\nparameters:\r\n	fio_token: \'\' #token pro přístup do FIO banky\r\n    \r\n...\r\n\r\nservices:\r\n	- Fresh\\Fio(token: %fio_token%)\r\n    \r\n...\r\n\\--\r\n\r\nBylo by vhodné upozornit na fakt, že se jedná pouze o read-only přístup, tzn. že neexistují žádné funkce\r\npro zápis (ačkoliv existuje něco jako datumová zarážka). Díky tomu je možné použít takovéto nízkoúrovňové\r\nzabezpečení pomocí jednoho tokenu.',	'2013-07-29 10:36:44',	'0000-00-00 00:00:00'),
(49,	'Using fulltext searching with InnoDB',	'using-fulltext-searching-with-innodb',	'Sometimes is quite useful to use InnoDB engine. \r\nUnfortunately InnoDB is good for tables with foreign keys, but useless for fulltext search. \r\nYou can\'t create fulltext index on InnoDB tables, but you can create this index on MyISAM tables. \r\nUnfortunately you can\'t create foreign keys on MyISAM. It\'s starting to be quite embarassing. \r\nLet me show you how to search via fulltext on InnoDB tables.\r\n\r\nIn fact it\'s not possible to use fulltext index on InnoDB tables, \r\nbut there is possible workaround. At first you need a classic InnoDB structure. \r\nFor example database of  blog:\r\n\r\n/--code sql\r\nSET NAMES utf8;\r\nSET foreign_key_checks = 0;\r\nSET time_zone = \'SYSTEM\';\r\nSET sql_mode = \'NO_AUTO_VALUE_ON_ZERO\';\r\n\r\nDROP TABLE IF EXISTS `posts`;\r\nCREATE TABLE `posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` text NOT NULL,\r\n  `body` text NOT NULL,\r\n  `date` datetime NOT NULL,\r\n  `release_date` datetime NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `title_3` (`title`(200))\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nDROP TABLE IF EXISTS `tags`;\r\nCREATE TABLE `tags` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(50) NOT NULL,\r\n  `color` varchar(6) NOT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nDROP TABLE IF EXISTS `posts_tags`;\r\nCREATE TABLE `posts_tags` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `tag_id` int(11) NOT NULL,\r\n  `post_id` int(11) NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  KEY `tag_id` (`tag_id`),\r\n  KEY `post_id` (`post_id`),\r\n  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),\r\n  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\\--\r\n\r\nNow we have pretty simple database structure with InnoDB tables with foreign keys. \r\nIt would be nice to be able search on database table **posts** using fulltext search:\r\n\r\n/--code sql\r\nSELECT *\r\nFROM posts\r\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE);\r\n\\--\r\n\r\nBut it is not possible. It returns something like:\r\n>   Error in query: The used table type doesn\'t support FULLTEXT indexes\r\n\r\nLet\'s create another one table with triggers and fulltext indexes. \r\nWe need to create mirror table. For example:\r\n\r\n/--code sql\r\nDROP TABLE IF EXISTS `mirror_posts`;\r\nCREATE TABLE `mirror_posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` text NOT NULL,\r\n  `body` text NOT NULL,\r\n  PRIMARY KEY (`id`),\r\n  FULLTEXT KEY `title_body` (`title`,`body`),\r\n  FULLTEXT KEY `title` (`title`),\r\n  FULLTEXT KEY `body` (`body`)\r\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\r\n\\--\r\n\r\nAnd than we need to create triggers:\r\n\r\n/--code sql\r\nDELIMITER ;;\r\n\r\nCREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW\r\nINSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body);;\r\n\r\nCREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW\r\nUPDATE mirror_posts SET\r\n    id = NEW.id,\r\n    title = NEW.title,\r\n    body = NEW.body\r\nWHERE id = OLD.id;;\r\n\r\nCREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW\r\nDELETE FROM mirror_posts WHERE id = OLD.id;;\r\n\\--\r\n\r\nIt means, that we copy all of events and data from table **posts** to the table **mirror_posts**.\r\nFinally we can use more complex fulltext search feature:\r\n\r\n/--code sql\r\nSELECT *\r\nFROM mirror_posts\r\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE)\r\nORDER BY 5 * MATCH(title) AGAINST (\'something\') + MATCH(body) AGAINST (\'something\') DESC;\r\n\\--\r\n\r\nAs I said, this is just workaround, not solution. \r\nSometimes it\'s bad practice, because you need copy of indexed columns. \r\nBut it works. And for small blogs it\'s sufficient.',	'2013-07-29 21:37:51',	'0000-00-00 00:00:00'),
(50,	'Problémy fulltextu v Nette',	'problemy-fulltextu-v-nette',	'Nedávno jsem psal o tom, jak využívat fulltext indexy na InnoDB tabulkách (http://www.zeminem.cz/using-fulltext-searching-with-innodb).\r\nNení to nic převratného, ale každý den se to také nedělá. Zmínil jsem také, jak vyhledávat, což\r\nbylo řešení \"Jakuba Vrány .{target:_blank}\":http://php.vrana.cz/fulltextove-vyhledavani-v-mysql.php.\r\n\r\nV diskusi pod článkem zmíňka o tom, jak ošetřit případ, kdy databáze nevrací výsledky pro slova,\r\nkterá jsou kratší než je hodnota **ft_min_word_len**. Implementace pro Nette nebude nijak zvlášť\r\nrozdílná, avšak i zde existuje minimálně jedna zrádnost.\r\n\r\nNette, ty jedna zrádná bestie...\r\n================================\r\n\r\nPro dotazování využívám databázovou vrstvu \\Nette\\Database, což je rozšíření (nadstavba) pro PDO.\r\nS oblibou také využívám fluid zápis a spoléhám na automatické ošetření vstupů. A zde je právě kámen úrazu.\r\nNette je místy až příliš důkladné (což je dobře), ale v tomto případě to znemožňuje korektní\r\npoužití **REGEXP**.\r\n\r\nBěžný kód pro fultextové dotazování může vypadat takto:\r\n\r\n/--code php\r\n/** @var Nette\\Database\\SelectionFactory @inject */\r\npublic $sf;\r\n    \r\n$this->sf->table(\'mirror_posts\')\r\n	->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)\", $search)\r\n	->order(\"5 * MATCH(title) AGAINST (?) + MATCH(body) AGAINST (?) DESC\", $search, $search)\r\n	->limit(50);\r\n\\--\r\n\r\nCož vygeneruje přibližně přesně následující:\r\n\r\n/--code sql\r\nSELECT `id`, `title`, `body` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE)) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nBohužel tento dotaz nevrátí nic. Je to právě kvůli hodnotě **ft_min_word_len**, kterou mám nastavenou\r\nna 4. Takže můžu změnit tuto hodnotu, a nebo pro všechny slova, která jsou kratší než 4 znaky\r\nposkládám složitější dotaz:\r\n\r\n/--code php\r\n$where = \"\";\r\n//$ft_min_word_len = mysql_result(mysql_query(\"SHOW VARIABLES LIKE \'ft_min_word_len\'\"), 0, 1);\r\n$ft_min_word_len = 4;\r\npreg_match_all(\"~[\\\\pL\\\\pN_]+(\'[\\\\pL\\\\pN_]+)*~u\", stripslashes($search), $matches);\r\nforeach ($matches[0] as $part) {\r\n	if (iconv_strlen($part, \"utf-8\") < $ft_min_word_len) {\r\n		$regexp = \"REGEXP \'[[:<:]]\" . addslashes($part) . \"[[:>:]]\'\";\r\n		$where .= \" OR (title $regexp OR body $regexp)\";\r\n	}\r\n}\r\n\\--\r\n\r\nA doplníme fluidní dotaz:\r\n\r\n/--code php\r\n...\r\n->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)$where\", $search) //přidáno $where\r\n...\r\n\\--\r\n\r\nNyní budu vyhledávat stejný výraz a to automaticky poskládaným dotazem:\r\n\r\n/--code sql\r\nSELECT `id` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE) OR (`title` REGEXP \'[[:<:]]`api`[[:>:]]\' OR `body` REGEXP \'[[:<:]]`api`[[:>:]]\')) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nBohužel, ani tento dotaz nevrátí strávný výsledek, ačkoliv se tváří, že by měl.\r\nDůvodem jsou zpětné uvozovky v regulárním výrazu **\'\'[[:<:]]`api`[[:>:]]\'\'**.\r\n\r\nŘešení je zřejmě několik. Například poskládat si tento dotaz sám. Ovšem to není ta nejbezpečnější cesta.\r\nEscapování je zrádné a zrovna vyhledávání je jedna z nejvíce používaných věcí, kdy se uživatel\r\npřímo ptá databáze. Existuje však vyčůranější způsob.\r\n\r\nCo jsem tak vypozoroval, tak Nette se sice o escapování snaží, ale neescapuje výraz zapsaný pomocí\r\n<em>strtoupper()</em>. Tzn. že stačí změnit tvorbu výrazu:\r\n\r\n/--code php\r\n$regexp = \"REGEXP \'[[:<:]]\" . addslashes(strtoupper($part)) . \"[[:>:]]\'\";\r\n\\--\r\n\r\nA dotaz se následně poskládá strávně:\r\n\r\n/--code sql\r\nSELECT `id`, `title`, `body` \r\nFROM `mirror_posts` \r\nWHERE (MATCH(`title`, `body`) AGAINST (\'api\' IN BOOLEAN MODE) OR (`title` REGEXP \'[[:<:]]API[[:>:]]\' OR `body` REGEXP \'[[:<:]]API[[:>:]]\')) \r\nORDER BY 5 * MATCH(`title`) AGAINST (\'api\') + MATCH(`body`) AGAINST (\'api\') DESC \r\nLIMIT 50\r\n\\--\r\n\r\nTo že je část výrazu jiná než ve skutečnosti nevadí. Nevím jestli je case-insensitive chování\r\nvlastnost REGEXP, ale tabulkou s postfixem **_ci** se také nic nezkazí.\r\n\r\nJen mě tak napadá, proč se to chová tak zvláštně. Uspokojuji se tím, že zpětná uvozovka\r\nnení úplně součástí escapování, takže se není čeho bát (a první regulár v PHP také nepustí vše),\r\nale je to divné.',	'2013-07-30 22:15:33',	'0000-00-00 00:00:00'),
(51,	'Routování v Nette - prakticky',	'routovani-v-nette-prakticky',	'V následujícím článku se budu opírat o teorii napsanou v \"dokumentaci\":http://doc.nette.org/cs/routing.\r\nJelikož jsem se však Nette učil sám, tak vím jak je těžké routování pochopit\r\na zvlášť potom z dokumentace, která spíše ukazuje fičury, než jak na to. A vzhledem k tomu, že mi\r\npod rukama prošlo velké množství velmi různorodých aplikací, kád bych zde uvedl příklady\r\nadresářové struktury, rout pro daný praktický problém a vzniklé URL adresy.\r\nZačíná přehlídka několika možných rout. Myslím si, že celá řada příkladů bude užitečnější, než teorie.\r\n\r\nZáklad všeho je porozumět tomu, jak se v Nette vytváří \"odkazy\":http://doc.nette.org/cs/presenters#toc-vytvareni-odkazu.\r\nOd toho se velmi podobně sestavují obecné routy tak, aby alespoň jedna seděla svým tvarem na daný odkaz.\r\n\r\nZačněme jednoduchou statickou stránkou, která má tuto jednoduchou adresářovou strukturu (dev Nette):\r\n\r\n/--code\r\napp/\r\n├─── config/\r\n├─── model/\r\n├─── presenters/\r\n│     └── HomepagePresenter.php\r\n│\r\n├─── router/\r\n├─── templates/\r\n│     ├── Homepage/\r\n│     │    ├── kontakt.latte   (zde jednotlivé stránky statického webu)\r\n│     │    └── ...\r\n│     └── @layout.latte\r\n│\r\n└─── bootstrap.php\r\n\\--\r\n\r\nTo znamená, že ne každou stránku se budu odkazovat přibližně jako <code>Homepage:kontakt</code>. Samozřejmě \r\nvždy se záměnou šablony (v tomto případě kontakt - kontakt.latte). To je dost triviální a stačilo by například:\r\n\r\n/--code php\r\n$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\r\n\\--\r\n\r\nTo je sice funkční, bohužel je to spíše teoretická routa, protože výsledek je otřesný:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/homepage/kontakt\r\n\\--\r\n\r\nTuto routu píšu téměř všude. Je to routa velmi obecná a říká přibličně následující:\r\nBude-li se někdo odkazovat ve tvaru **bla:blabla**, pochop **bla** jako presenter a hledej tedy soubor BlaPresenter.php\r\na **blabla** bude šablona presenteru, hledej ji tedy ve složce **bla/blabla.latte** a sestav URL která bude přesně v tomto tvaru.\r\nHomepage:default pouze říká co je výchozí hodnota a co se má hledat, pokud nebude specifikována konkrétní šablona.\r\n\r\nPro takto malý web je mnohem lepší specifikovat konkrétnější routu, která přijde **před** onu obecnou:\r\n\r\n/--code php\r\n$router[] = new Route(\'<action>\', \'Homepage:default\');\r\n\\--\r\n\r\nCož udělá téměř to samé, jen vypustí z URL nadbytečnou informaci o presenteru. Vždy používáme HomepagePresenter, jen\r\nse mění cílová šablona podle URL:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/kontakt\r\n\\--\r\n\r\nVýsledná sada rout pro takovouto malou statickou stránku by tedy mohla vypadat takto:\r\n\r\n/--code php\r\npublic function createRouter() {\r\n	$router = new RouteList();\r\n	$router[] = new Route(\'<action>\', \'Homepage:default\');\r\n	$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\r\n	return $router;\r\n}\r\n\\--\r\n\r\nDále je vhodné používat např. soubor <code>sitemap.xml</code>. Pokud ho také umístím do stejného adresáře\r\njako šablony, routa je opět jednoduchá:\r\n\r\n/--code php\r\n$router[] = new Route(\'sitemap.xml\', \'Homepage:sitemap\');\r\n\\--\r\n\r\nHledá se šablona <code>sitemap.latte</code> a výsledná URL je tak jak má být:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/sitemap.xml\r\n\\--\r\n\r\nTo samé lze udělal pro RSS. Trošku složitější routování přichází vždy když chcete udělat něco speciálního.\r\nNapříklad to, aby číslo za URL udávalo číslo stránky v paginatoru:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/2\r\n\\--\r\n\r\n/--code php\r\n$router[] = new Route(\"[<paginator-page [1|2]>]\", array(\r\n	\'presenter\' => \'Homepage\',\r\n	\'action\' => \'default\',\r\n	\'paginator-page\' => 1\r\n));\r\n\\--\r\n\r\nZde už je nutné druhý parametr rozepsat a více specifikovat. Toto akceptuje pouze konkrétní čísla.\r\na jako druhou specialitu lze napsat takovou routu, která bude tvořit URL z názvů článků:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/using-fulltext-searching-with-innodb\r\n\\--\r\n\r\n/--code php\r\n$router[] = new Route(\'<id>\', array(\r\n	\'presenter\' => \'Single\',\r\n	\'action\' => \'article\',\r\n	\'id\' => array(\r\n		Route::FILTER_IN => function ($url) {\r\n			return $this->posts->getIdByUrl($url);\r\n		},\r\n		Route::FILTER_OUT => function ($id) {\r\n			return $this->posts->getUrlById($id);\r\n		},\r\n	),\r\n));\r\n\\--\r\n\r\nA není úplně na škodu vytvořit routu, která bude řešit napríklad vyhledávání:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/search/fio%20api\r\n\\--\r\n\r\n/--code php\r\n$router[] = new Route(\'search[/<search>]\', \'Search:default\');\r\n\\--\r\n\r\nToto jsou jednoduché routy pro jednoduchou adresářovou strukturu. Lehce složitější jsou pro\r\nmodulární strukturu, kdy je zapotřebí specifikovat modul:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/rss.xml\r\n\\--\r\n\r\n/--code php\r\n$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\r\n\\--\r\n\r\nChová se to stejně jako u předchozího příkladu se sitemap.xml, v tomto příkladu však routa hledá\r\nBlogPresenter.php ve složce FrontModule a šablonu rss.latte, také v tomto modulu. U rout pro\r\nmodulární aplikace již raději rozepisuji druhý parametr, protože je to přehlednější. Následující routa\r\nzvládne jazykové mutace pro FrontModule, jinak je to opět ta nejobecnější routa vůbec:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/en/site/kontakt\r\n\\--\r\n\r\n/--code php\r\n$router[] = new Route(\'[<lang cs|sk|en>/]<presenter>/<action>[/<id>]\', array(\r\n	\'module\' => \'Front\',\r\n	\'presenter\' => \'Homepage\',\r\n	\'action\' => \'default\',\r\n));\r\n\\--\r\n\r\nTo samé, ale opět o trošku náročnější. Tentokrát pro UserModule, který je na jiné URL, než FrontModule:\r\n\r\n/--code\r\nhttp://www.zeminem.cz/user/en/setting/password\r\n\\--\r\n\r\n/--code php\r\n$router[] = new Route(\'user/[<lang cs|sk|en>/]<presenter>/<action>[/<id [0-9]+>]\', array(\r\n	\'module\' => \'User\',\r\n	\'presenter\' => \'Board\',\r\n	\'action\' => \'default\',\r\n));\r\n\\--\r\n\r\nA na závěr ještě poslední přehled možných rout jako příklady toho co je možné.\r\n\r\n/--code php\r\n$router[] = new Route(\'sitemap.xml\', \'Front:Export:sitemap\');\r\n$router[] = new Route(\'kategorie/<category>\', \'Front:Product:default\');\r\n$router[] = new Route(\'produkt/<product>\', \'Front:Product:detail\');\r\n$router[] = new Route(\'\', \'Front:Product:default\');\r\n$router[] = new Route(\'admin/sign-<action>\', \'Admin:Sign:\');\r\n$router[] = new Route(\'registrace/\', \'Front:Register:new\');\r\n$router[] = new Route(\'index.php\', \'Homepage:default\', Route::ONE_WAY);\r\n$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\r\n$router[] = new \\App\\RestRouter(\'api[/<presenter>[/<id>]]\', array( //vyžaduje speciální objekt (není součástí Nette)\r\n	\'module\' => \'Rest\',\r\n	\'presenter\' => \'Resource\',\r\n	\'action\' => \'get\',\r\n), \\App\\RestRouter::RESTFUL);\r\n\\--\r\n\r\nJe zcela zřejmé, že se všechny konstrukce stále opakují, proto považuji za opravdu důležité\r\nperfektně pochopit tvorbu odkazů a následně je to možná trochu o experimentování, ale s\r\ntouto sadou příkladů bude myslím jednoduché najít podobnou routu, jaká je zrovna potřeba.\r\n\r\nJak na v posledním příkladu zmíněný CLI router se dočtete zde: http://www.zeminem.cz/nette-2-1-dev-clirouter\r\n\r\nV článku jsem většinou pozměnil domény, abych neprozrazoval strukturu jiných webů. (-:',	'2013-08-04 12:19:19',	'0000-00-00 00:00:00'),
(52,	'Fluent interface a PCRE',	'fluent-interface-a-pcre',	'Na následujících řádcích předvedu dvě věci. První je úžasný nápad jak vytvářet regulární výrazy pomocí fluent zápisu (\"inspirace .{target:_blank}\":https://github.com/VerbalExpressions/PHPVerbalExpressions/blob/master/VerbalExpressions.php), což je druhá věc o které bych se rád zmínil.\r\n\r\nRegulární výrazy jsou peklo\r\n=======================\r\nAčkoliv znám pár lidí, které regulární výrazy umí, je jich opravdu pár. A nikdo z nich o sobě neřekne, že je umí. Následuje příklad velmi triviálního výrazu, který je ovšem dosti špatný, což je dobře, protože se k tomu vrátím později:\r\n\r\n/--code\r\n/^(http)(s)?(\\:\\/\\/)(www\\.)?([^ ]*)(\\.)([^ ]*)(\\/)?$/\r\n\\--\r\n\r\nTento výraz akceptuje přibližně tvar URL. Je však zřejmé, že je to zápis, který je nesmírně náročný na vymyšlení a extrémně náchylný ke tvoření chyb. Proto je vhodné si jeho tvorbu zjednodušit například nějakou třídou:\r\n\r\n/--code php\r\n<?php\r\n\r\nclass Regexp {\r\n\r\n	private $regexp = \'\';\r\n\r\n	public function has($value) {\r\n		$this->regexp .= \"(\" . preg_quote($value, \'/\') . \")\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function maybe($value) {\r\n		$this->regexp .= \"(\" . preg_quote($value, \'/\') . \")?\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function anythingBut($value) {\r\n		$this->regexp .= \"([^\" . preg_quote($value, \'/\') . \"]*)\";\r\n		//return $this;   -   potřebné pro fluent interface\r\n	}\r\n\r\n	public function __toString() {\r\n		return \"/^$this->regexp$/\";\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nS tím, že její použití je prosté:\r\n\r\n/--code php\r\n$regexp = new Regexp();\r\n$regexp->then(\'http\');\r\n$regexp->maybe(\'s\');\r\n$regexp->then(\'://\');\r\n$regexp->maybe(\'www.\');\r\n$regexp->anythingBut(\' \');\r\n$regexp->then(\'.\');\r\n$regexp->anythingBut(\' \');\r\n$regexp->maybe(\'/\');\r\necho $regexp . \'<br>\';\r\necho preg_match($regexp, \'http://www.zeminem.cz/\') ? \'P\' : \'F\';\r\necho preg_match($regexp, \'https://www.zeminem.cz/\') ? \'P\' : \'F\';\r\n\\--\r\n\r\nNemusím však říkat, že to minimálně vypadá naprosto otřesně. Spousta psaní, až moc objektové chování. Elegantnější řešení přináší právě fluent interface.\r\n\r\nFluent interfaces, regulární peklo chladne\r\n===================================\r\nFluent interface je způsob jak řetězit metody za sebe. Používá se poměrně často, ušetří spoustu zbytečného psaní a velmi prospívá srozumitelnosti kódu. Nevýhodou je, že se musí v každé metodě vrátit objekt <code>return $this;</code>, na což se nesmí zapomenout. Každopádně výsledek je skvostný:\r\n\r\n/--code php\r\n$regexp = new Regexp();\r\n$regexp->then(\'http\')\r\n		->maybe(\'s\')\r\n		->then(\'://\')\r\n		->maybe(\'www.\')\r\n		->anythingBut(\' \')\r\n		->then(\'.\')\r\n		->anythingBut(\' \')\r\n		->maybe(\'/\');\r\necho $regexp . \'<br>\';\r\necho preg_match($regexp, \'http://www.zeminem.cz/\') ? \'P\' : \'F\';\r\necho preg_match($regexp, \'https://www.zeminem.cz/\') ? \'P\' : \'F\';\r\n\\--\r\n\r\nTeprve zde vynikne to, jak je důležité správně (čti stručně a jasně) pojmenovávat metody. Díky fluent interfaces lze programovat téměř ve větách, které jsou naprosto srozumitelné.\r\n\r\nNe, peklo je opět peklem\r\n=====================\r\nAčkoliv by se mohlo zdát, že díky objektu, který pomáhá tvořit regulární výrazy je jejich kompozice jednoduchou záležitostí, není tomu tak. Vrátím se k původnímu výrazu, který není dobrý. Proč? V reálném světě je kontrola, resp. předpis, který musí daná adresa mít daleko složitější. Například <code>http</code> nemusí být vůbec přítomno, pokud však je, musí následovat možná <code>s</code> a zcela určitě <code>://</code>. To samé s doménou. Ta může být jen určitý počet znaků dlouhá, může obsahovat tečky (ale ne neomezené množství), samotná TLD má také určitá pravidla (minimálně co se týče délky) a to nemluvím o parametrech za adresou, které jsou téměř bez limitu.\r\n\r\nZkuste si takový objekt napsat. Ve výsledku se i nadále budou regulární výrazy psát ručně, nebo se ve složitějších případech vůbec používat nebudou.',	'2013-08-10 22:31:21',	'0000-00-00 00:00:00'),
(53,	'RSS a Sitemap jednoduše a rychle',	'rss-a-sitemap-jednoduse-a-rychle',	'Pár článků zpět jsem ukazoval několik příkladů, jak tvořit různé routy. Ukazoval jsem routy pro RSS i sitemap.xml. Nikde jsem však zatím neukazoval jak je to jednoduše realizovatelné. Dokonce tak jednoduše, že je škoda tyto soubory nevyužít na jakémkoliv webu, protože mají poměrně velký potenciál.\r\n\r\nZačněme HomepagePresenterem (DEV Nette):\r\n\r\n/--code php\r\n<?php\r\n\r\nclass HomepagePresenter extends BasePresenter {\r\n\r\n	/** @var \\Model\\Posts @inject */\r\n	public $posts;\r\n\r\n	public function renderRss() {\r\n		$this->template->posts = $this->posts->getAllPosts()->order(\'date DESC\')->limit(50);\r\n	}\r\n\r\n	public function renderSitemap() {\r\n		$this->template->sitemap = $this->posts->getAllPosts();\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nTímto říkám, že do šablon <code>rss.latte</code> a <code>sitemap.latte</code> předávám všechny články, nebo jen některé, protože nechci dělat dump celé databáze pro RSS.\r\n\r\nPro úplnost ještě \\Model\\Posts:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace Model;\r\n\r\nclass Posts extends \\Nette\\Object {\r\n\r\n	/** @var \\Nette\\Database\\SelectionFactory @inject */\r\n	public $sf;\r\n\r\n	/**\r\n	 * @return Nette\\Database\\Table\\Selection\r\n	 */\r\n	public function getAllPosts() {\r\n		return $this->sf->table(\'posts\');\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nA následují samotné šablony, které musí dodržovat určitý formát, takže se lehce odlišují od normálních šablon. Sitemap.latte:\r\n\r\n/--code html\r\n{contentType application/xml}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\r\n	{foreach $sitemap as $s}\r\n		<url>\r\n			<loc>{link //Single:article $s->id}</loc>\r\n		</url>\r\n	{/foreach}\r\n</urlset>\r\n\\--\r\n\r\nRss.latte:\r\n\r\n/--code html\r\n{contentType application/xml}\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<rss version=\"2.0\">\r\n	<channel>\r\n		<title>Martin Zlámal [BLOG]</title>\r\n		<link>{link //:Homepage:default}</link>\r\n		<description>Nejnovější články na blogu.</description>\r\n		<language>cs</language>\r\n\r\n		<item n:foreach=\"$posts as $post\">\r\n			<title>{$post->title}</title>\r\n			<link>{link //:Single:article $post->id}</link>\r\n			<description>{$post->body|texy|striptags}</description>\r\n		</item>\r\n	</channel>\r\n</rss>\r\n\\--\r\n\r\nA pro úplnou úplnost i router:\r\n\r\n/--code php\r\n<?php\r\n\r\nnamespace App;\r\nuse Nette;\r\nuse Nette\\Application\\Routers\\Route;\r\nuse Nette\\Application\\Routers\\RouteList;\r\nuse Nette\\Application\\Routers\\SimpleRouter;\r\n\r\nclass RouterFactory {\r\n\r\n	/**\r\n	 * @return \\Nette\\Application\\IRouter\r\n	 */\r\n	public function createRouter() {\r\n		$router = new RouteList();\r\n		$router[] = new Route(\'sitemap.xml\', \'Homepage:sitemap\');\r\n		// na RSS se dá odkazovat normálně bez routeru, nebo:\r\n		$router[] = new Route(\'rss.xml\', \'Homepage:rss\');\r\n		//...\r\n		$router[] = new Route(\'<presenter>/<action>[/<id>]\', \'Homepage:default\');\r\n		return $router;\r\n	}\r\n\r\n}\r\n\\--\r\n\r\nJednoduché a na pár řádek. Jen vědět jak na to... (-:',	'2013-08-10 23:10:22',	'0000-00-00 00:00:00'),
(54,	'AJAX upload souborů v Nette pomocí Fine Uploaderu',	'ajax-upload-souboru-v-nette-pomoci-fine-uploaderu',	'A je zde další ukázka vlastní práce, která se může hodit i někomu dalšímu. Tentokrát půjde o ajaxové\r\nnahrávání souborů v Nette pomocí \"Fine Uploaderu .{target:_blank}\":http://fineuploader.com/.\r\nObecně to není moc jednoduchá sranda, ale uvidíte, že to zase není taková věda...\r\n\r\nA jak už to tak dělávám, lepší než spoustu povídání je spousta ukázek. Prvně je potřeba nalinkovat\r\nsoubory Fine Uploaderu, nette.ajaxu a vlastního javascriptového souboru:\r\n\r\n/--code html\r\n<script src=\"{$basePath}/js/jquery.fineuploader-3.7.0.min.js\"></script>\r\n<script src=\"{$basePath}/js/nette.ajax.js\"></script>\r\n<script src=\"{$basePath}/js/main.js\"></script>\r\n\\--\r\n\r\nPoužití samotného Fine Uploaderu je nesmírně jednoduché. Nejdříve je třeba vytvořit element na který\r\nse uploader později zavěsí a případně tlačítko na upload, pokud nechceme soubory uploadovat rovnou:\r\n\r\n/--code html\r\n<div id=\"image-uploader\"{ifset $selected} data-id=\"{$selected}\"{/ifset}></div>\r\n<div id=\"triggerUpload\">Nahrát obrázky</div>\r\n\\--\r\n\r\nPřichází na řadu samotné oživení uploaderu pomocí javascriptu (soubor main.js):\r\n\r\n/--code javascript\r\n$(function () {\r\n	if ($(\'#image-uploader\').length != 0) { //test existence elementu\r\n		$.nette.ext(\'uploader\', {\r\n			complete: function () { //zavěšení na konec ajaxového požadavku\r\n				var uploader = $(\'#image-uploader\').fineUploader({\r\n					request: {\r\n						endpoint: \'product/default/\' + $(\'#image-uploader\').data(\'id\') + \'?do=upload\'\r\n					},\r\n					text: {\r\n						uploadButton: \'Klikněte, nebo Přetáhněte obrázky\',\r\n						cancelButton: \'zrušit\',\r\n						failUpload: \'Nahrání obrázku se nezdařilo\',\r\n						dragZone: \'Přetáhněte soubory sem\',\r\n						dropProcessing: \'Zpracovávám přetažené soubory...\',\r\n						formatProgress: \'{percent}% z {total_size}\',\r\n						waitingForResponse: \'Zpracovávám...\'\r\n					},\r\n					autoUpload: false,\r\n					failedUploadTextDisplay: {\r\n						mode: \'custom\',\r\n						maxChars: 70,\r\n						responseProperty: \'error\',\r\n						enableTooltip: true\r\n					}\r\n				});\r\n				$(\'#triggerUpload\').click(function () {\r\n					uploader.fineUploader(\'uploadStoredFiles\');\r\n				});\r\n			}\r\n		});\r\n	}\r\n\r\n	$.nette.init(); //inicializace nette.ajax\r\n});\r\n\\--\r\n\r\nProtože jsem v mém případě donačítal tento upload element ajaxově, musel jsem script pro uploader\r\nzavěsit na nette.ajax událost complete. Tato obálka se dá smazat a spouštět klasicky\r\npři události document.ready. Je zde spoustu, pro samotnou funkčnost, zbytečného kódu.\r\nPodstatný je pouze request:endpoint, který ukazuje na URL adresu aplikace, kde čeká Nette handle.\r\nTen může vypadat například takto:\r\n\r\n/--code php\r\npublic function handleUpload($id) {\r\n	$allowedExtensions = array(\"jpeg\", \"jpg\", \"png\", \"gif\"); //například pro obrázky\r\n	$uploader = new \\qqFileUploader($allowedExtensions);\r\n	//...\r\n	try {\r\n		$result = $uploader->handleUpload(__DIR__ . \'/../../../www/uploads/\' . $id . \'/default\', NULL);\r\n		$result[\'uploadName\'] = $uploader->getUploadName();\r\n		//...\r\n	} catch (\\Exception $exc) {\r\n		$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse(array(\r\n			\'error\' => $exc->getMessage(),\r\n		)));\r\n	}\r\n	$this->invalidateControl();\r\n	$this->sendResponse(new \\Nette\\Application\\Responses\\JsonResponse($result));\r\n}\r\n\\--\r\n\r\nOpět jsem vypustil části, které nejsou úplně důležité pro samotnou funkčnost. Jde pouze o to mít\r\npřipravenou handle metodu, která převezme například ID, důležité však je, že spouští metodu handleUpload()\r\na odesílá JSON odpověď a to jak errorovou, tak normální, což je následně na straně klienta vyhodnoceno\r\njako úspěšný upload.\r\n\r\nV kódu je zmíněna také třída qqFileUploader. Tu naleznete například na \"GitHubu .{target:_blank}\":https://github.com/Widen/fine-uploader-server a nejenom pro PHP. Já jsem si tuto třídu obohatil pouze\r\no webalize názvů souborů.\r\n\r\nA to je vlastně úplně celé. Stačí tedy spustit Fine Uploader na straně klienta například\r\npodle oficiálních návodů, endpoint nastavit na nějaký handle v aplikaci a ten správně použit.\r\nTo konkrétně obnáší odeslání JSON odpovědi o úspěšném zpracování obrázku.',	'2013-08-21 22:14:44',	'0000-00-00 00:00:00'),
(55,	'Důležitost titulku podruhé (a naposled)',	'dulezitost-titulku-podruhe-a-naposled',	'Také bych mohl začít slovy: \"Jsem to ale trouba.\" V následujících několika odstavcích bych rád navázal na článek, kde jsem upozorňoval na to, jak je <code>title</code> tag důležitý (http://www.zeminem.cz/portal-zcu-docasne-mimo-provoz). Což jsem si ostatně nechtěně vyzkoušel.\r\n\r\nJak málo stačí k umístění ve vyhledávači\r\n========================================\r\nTag <code>title</code> je jeden z nejvíce důležitých prvků na webové stránce. Zároveň je však jeden z nejvíce opomíjených. Proč se však opět vracím k již dávno vyřešenému problému? Krátce poté co jsem napsal onen osudný článek, mohl jsem pozorovat krásný efekt o kterém jsem psal. Vytvořil jsem totiž článek, jehož URL adresa měla změní <code>...cz/portal-zcu-docasne-mimo-provoz</code> a ve vyhledávači jsem vystupoval s titulkem <code>Portál ZČU dočasně mimo provoz | Martin Zlámal</code>.\r\n\r\nS tímto článkem jsem se okamžitě dostal na první stránku ve vyhledávači a dodnes pozoruji ve statistikách doslova tisíce zobrazení (což je na velikost mého bezvýznamného blogu opravdu hodně) na různé kombinace slov **portal** a **zcu**. Celkem jsem napočítal 7 variant což už chce zapojit fantazii pro spojení dvou slov tolika způsoby.\r\n\r\nJenže není zobrazení jako zobrazení\r\n===================================\r\nMožná by z toho měl kde kdo radost, ale mě osobně to moc nenadchlo. Je třeba se zamyslet nad tím, jaká je z tohoto zobrazení asi návštěvnost, když jsem jednak na pozici až pod tím správným portálem a pak má článek takový titulek, na který nikdo z vyhledávání dobrovolně nepřistoupí. Mizivou.\r\n\r\nOproti tomu naopak články, které byly napsány vyloženě z důvodu zájmu (http://www.zeminem.cz/routovani-v-nette-prakticky) mají mnohem větší procento prokliků. A to nelze srovnávat počty zobrazení jednotlivých článků. Každopádně zdaleka největšího CTR dosahují články, ve jsou popsány návrhové vzory v PHP (např. http://www.zeminem.cz/navrhovy-vzor-factory-method).\r\n\r\nRád bych z tohoto pozorování vyvodil jednoduchý závěr, který je však myslím více než jasný. Nemá smysl psát o jakémkoliv nápadu, ale má smysl psát o tématech, o které je evidentní zájem, což lze ve statistikách snadno pozorovat. Snad jen jednou za čas je zajímavé vybočit z řady a sledovat reakce návštěvníků.',	'2013-10-21 23:20:36',	'0000-00-00 00:00:00'),
(56,	'LaTeX šablona',	'latex-sablona',	'Všiml si také někdo, že většina uživatelů WYSIWYG textového editoru typu Word v něm menšinu času píší a většinu času se snaží ohnout editor tak, aby dělal to co má? Tak přesně toto mě přestalo bavit a začal jsem všechny práce sázet v LaTeXu. Pro psaní mám vytvořenou následující šablonu, kterou s výhodou používám a zatím jsou na ní od kontrolujících dobré ohlasy (pokud si toho někdo všiml).\r\n\r\n/--code tex\r\n\\documentclass[12pt]{article} % use larger type; default would be 10pt\r\n\\usepackage[czech]{babel}\r\n\\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)\r\n\r\n%%% PAGE DIMENSIONS\r\n\\usepackage{geometry} % to change the page dimensions\r\n% \\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}\r\n\\geometry{a4paper}\r\n\r\n\\usepackage{graphicx} % support the \\includegraphics command and options\r\n\\usepackage{wrapfig} % support the wrapfigure section\r\n\r\n\\usepackage{hyperref} % links in \\tableofcontents\r\n\\hypersetup{\r\n	colorlinks,\r\n	citecolor=black,\r\n	filecolor=black,\r\n	linkcolor=black,\r\n	urlcolor=black\r\n}\r\n\r\n% \\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent\r\n\r\n%%% PACKAGES\r\n\\usepackage{booktabs} % for much better looking tables\r\n\\usepackage{array} % for better arrays (eg matrices) in maths\r\n%\\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)\r\n\\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim\r\n\\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float\r\n% These packages are all incorporated in the memoir class to one degree or another...\r\n\\usepackage{tikz} % graphs\r\n\\usepackage{pgfplots}\r\n\\usepackage{float}\r\n\r\n%%% HEADERS & FOOTERS\r\n\\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry\r\n\\pagestyle{fancy} % options: empty , plain , fancy\r\n\\renewcommand{\\headrulewidth}{0pt} % customise the layout...\r\n\\lhead{}\\chead{}\\rhead{}\r\n\\lfoot{}\\cfoot{\\thepage}\\rfoot{}\r\n\r\n%%% SECTION TITLE APPEARANCE\r\n\\usepackage{sectsty}\r\n\\allsectionsfont{\\sffamily\\mdseries\\upshape} % (See the fntguide.pdf for font help)\r\n% (This matches ConTeXt defaults)\r\n\r\n%%% ToC (table of contents) APPEARANCE\r\n\\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC\r\n\\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents\r\n\\renewcommand{\\cftsecfont}{\\rmfamily\\mdseries\\upshape}\r\n\\renewcommand{\\cftsecpagefont}{\\rmfamily\\mdseries\\upshape} % No bold!\r\n\\newcommand{\\bigsize}{\\fontsize{35pt}{20pt}\\selectfont}\r\n\r\n%%% END Article customizations\r\n\r\n\\begin{document}\r\n\r\n	...\r\n\r\n\\end{document}\r\n\\--\r\n\r\nJsem relativně LaTeX nováčkem, proto by mě zajímalo. Používáte nějakou jinou šablonu? Lepší?',	'2013-10-21 23:42:14',	'0000-00-00 00:00:00');

DELIMITER ;;

CREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW
INSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.slug, NEW.body);;

CREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW
UPDATE mirror_posts SET
    id = NEW.id,
    title = NEW.title,
    slug = NEW.slug,
    body = NEW.body
WHERE id = OLD.id;;

CREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW
DELETE FROM mirror_posts WHERE id = OLD.id;;

DELIMITER ;

DROP TABLE IF EXISTS `posts_tags`;
CREATE TABLE `posts_tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_id` int(11) NOT NULL,
  `post_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `tag_id` (`tag_id`),
  KEY `post_id` (`post_id`),
  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),
  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `posts_tags` (`id`, `tag_id`, `post_id`) VALUES
(98,	42,	10),
(99,	42,	9),
(101,	41,	11),
(102,	42,	11),
(105,	41,	45),
(106,	42,	45),
(107,	44,	45),
(108,	42,	46),
(109,	41,	46),
(110,	41,	47),
(111,	42,	47),
(114,	45,	49),
(115,	43,	4),
(119,	41,	50),
(120,	42,	50),
(121,	45,	50),
(123,	41,	51),
(130,	42,	52),
(131,	46,	52),
(132,	41,	53),
(136,	41,	54),
(137,	47,	54),
(138,	48,	54),
(139,	49,	55),
(141,	50,	56);

DROP TABLE IF EXISTS `tags`;
CREATE TABLE `tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `color` varchar(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `tags` (`id`, `name`, `color`) VALUES
(41,	'nette',	'106dcf'),
(42,	'php',	'aa16b1'),
(43,	'html',	'1c7640'),
(44,	'tester',	'9f1857'),
(45,	'sql',	'7608de'),
(46,	'pcre',	'a69d02'),
(47,	'javascript',	'a4423a'),
(48,	'ajax',	'706753'),
(49,	'úvaha',	'9a94a8'),
(50,	'latex',	'c51cdd');

DROP TABLE IF EXISTS `users`;
CREATE TABLE `users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(100) NOT NULL,
  `password` varchar(100) NOT NULL,
  `role` varchar(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `users` (`id`, `username`, `password`, `role`) VALUES
(1,	'martin',	'$2a$07$edgpvjdh2tlm7h58u4wcse3rEan/kBrKgLhVpXkc68bfH.393ibHq',	'admin');

-- 2013-10-24 21:00:23
