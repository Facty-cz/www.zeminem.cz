-- Adminer 3.6.2 MySQL dump

SET NAMES utf8;
SET foreign_key_checks = 0;
SET time_zone = 'SYSTEM';
SET sql_mode = 'NO_AUTO_VALUE_ON_ZERO';

DROP TABLE IF EXISTS `posts`;
CREATE TABLE `posts` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` text NOT NULL,
  `body` text NOT NULL,
  `date` datetime NOT NULL,
  `release_date` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `title_3` (`title`(200))
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `posts` (`id`, `title`, `body`, `date`, `release_date`) VALUES
(2,	'Asymetrická šifra s veřejným klíčem',	'O veřejné distribuci klíčů jsem již dříve psal. Pojďme se však podívat nejen na samotnou distribuci, ale i na myšlenku asymetrického šifrování. Prvně je však třeba vysvětlit několik důležitých věcí. Začněme tím, co vlastně znamená asymetrická šifra. Před myšlenkou asymetrického šifrování, jejíž autorem je Whitfield Diffie, se používalo výhradně šifrování symetrické, což znamená, že proces dešifrování zakódované zprávy je přesně opačný k procesu šifrování. Asymetrické šifrování však zavádí myšlenku použití jiného klíče na šifrování a jiného na dešifrování.\r\n\r\nJak to vyřešit? Jak je možné použít jiný klíč na šifrování a jiný na dešifrování? Již existoval koncept, který umožňoval výměnu  klíčů veřejně (a bezpečně). Stále byl však na principu synchronní komunikace odesílatele a příjemce, což nebylo optimální řešení a proto byl vymyšlen způsob jak tento problém obejít. Myšlenka byla jednoduchá. Příjemce musí vytvořit veřejný klíč, který následně zveřejní tak, aby byl veřejný opravdu pro všechny. V tomto případě je jasné, že by to nemělo smysl, pokud by se nepoužívala jednosměrná funkce šifrování, což je další pravidlo. A zároveň opět onen příjemce musí mít svůj tajný klíč, který dokáže informaci zašifrovanou veřejným klíčem dešifrovat. Z toho je patrná ta asymetričnost šifry. Nepoužívám stejný klíč na zašifrování a dešifrování jako u jiných šifer.\r\n\r\nTomuto systému se říká RSA (Ronald Riverst, Adi Shamir, Leonard Adleman). Pojďme se na něj teď podívat matematicky, protože teorie je moc obecná (a matematika zase složitá). Odesílatel zprávy si musí zvolit dvě velmi velká prvočísla (A, B). Tyto prvočísla mezi sebou vynásobí a dostane další ještě větší číslo (AB). Násobení je zcela triviální jednosměrná operace a systém RSA si zakládá na tom, že faktorizovat velké číslo je v reálním čase prakticky nemožné. Dále si odesílatel zvolí číslo C a to uveřejní společně s číslem AB. Toto jsou informace, které má každý k dispozici. Pro šifrování je nutné zprávu převést na číslo M (například binárně). Toto číslo se poté dosadí podle vzorce \"šifra\"= M^C (mod AB). Zpětně se pak informace dá velmi snadno dostat obráceným postupem se znalostí onoho součinu prvočísel zvolených na začátku. Bez znalosti těchto prvočísel je dešifrování téměř nemožné, což však také není úplně pravda viz poslední odstavec.\r\n\r\nJe zřejmé, že úspěch šifry spočívá ve zvolení dostatečně velkých prvočísel a mocnitele C, který by vzhledem k prvočíslům neměl mít žádného společného dělitele. Resp. přesněji čísla C a (A-1) * (B-1). Při představení RSA byl pro jeho reprezentaci uveřejněn zašifrovaný text s veřejným klíčem. Soutěžním úkolem bylo faktorizovat veřejný klíč na dvě složky a poté zprávu dešifrovat. Faktorizace trvala ve výsledku celkem 17 let, kdy tým 600 dobrovolníků oznámil 26. dubna 1994 činitele veřejného klíče. A jaký že byl ten klíč?\r\n\r\n/--code\r\nN = 114 381 625 757 888 867 669 235 779 976 146 612 010 218 296 721 242 362 562 561 842 935 706 935 245 733 897 830 597 123 563 958 705 058 989 075 147 599 290 026 879 543 541\r\n\\--\r\n\r\nDílčí prvočísla si nechám jako tajemství? (-:',	'2012-09-07 22:29:58',	'2012-09-07 22:29:58'),
(3,	'Lovec matematik',	'Znáte následující hádanku?\r\n\r\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Tam zastřelil medvěda. Jakou měl medvěd barvu?\r\n\r\nŘešení je více než jednoduché. Stačí si představit sférický trojúhelník vycházející ze severního pólu, který má všechny strany dlouhé 10 km (tedy každý úhel má 90°). Vzhledem k severnímu pólu je zřejmé, že medvěd musí být bílý. Existuje však ještě jiné řešení této hádanky čistě z geometrického (matematického chcete-li) hlediska? Vypusťme tedy medvěda a zamysleme se nad následující hádankou:\r\n\r\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Měl však smůlu a tak nic neulovil.\r\n\r\nJedno řešení už známe. Zamyslete se ještě jednou nad druhým řešením. Přesuňme se na jižní polokouli do libovolného bodu vzdáleného 11 591,55 m od jižního pólu. Pokud šel lovec nejprve 10 km na jih, dorazil do druhého bodu vzdáleného 1591,55 m od jižního pólu. Ze základní matematiky jistě všichni znají vzorec pro obvod kruhu O = 2&pi;r. Dosazením do vzorce zjistíme velmi zajímavou skutečnost. Obvod kruhu, tedy délka cesty na západ je dlouhá přibližně přesně 10 km. Lovec se tedy dostane na stejný bod vzdálený 1591,55 m od pólu a cestou na sever dojde do úplného začátku stejně tak jako tomu bylo při využití sférického trojúhelníku na opačné straně planety.\r\n\r\nPokud nebyl lovec matematik a neuvědomoval si tuto skutečnost, muselo být poměrně vyčerpávající dorazit po třiceti kilometrech do stejného místa...',	'2012-09-15 21:50:26',	'2012-09-15 21:50:26'),
(4,	'Tabulkový masakr',	'Určitě znáte HTML a tím pádem znáte i tabulky. Pro jistotu připomenutí.\nTabulka se v HTML tvoří párovým tagem <code>&lt;table&gt;&lt;/table&gt;</code>, její řádky jsou <code>&lt;tr&gt;&lt;/tr&gt;</code> a buňky <code>&lt;td&gt;&lt;/td&gt;</code>. Buňky mají volitelné atributy <code>rowspan</code> a <code>colspan</code>. Tyto atributy určují, kolik bude buňka zabírat místa v řádce, resp. ve sloupci. Tyto znalosti stačí k pochopení pojmu \"tabulkový paradox\".\n\nPodívejte se na \"první ukázku .{target:_blank}\":http://demo.zeminem.cz/tabulkovy-paradox.php, kde je vidět co se stane, když roztáhneme buňku **A2** na tři řádky a zároveň roztáhneme buňku **B1** na tři sloupce podle následujícího kódu:\n/--code html\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n	<tr>\n		<td width=\"33%\">A1</td>\n		<td width=\"33%\" rowspan=\"4\">A2</td>\n		<td width=\"33%\">A3</td>\n	</tr>\n	<tr>\n		<td colspan=\"3\">B1</td>\n	</tr>\n	<tr>\n		<td>C1</td>\n		<td>C3</td>\n	</tr>\n	<tr>\n		<td>D1</td>\n		<td>D3</td>\n	</tr>\n</table>\n\\--\nTam kde by měla být buňka **B2** vzniká krásné okénko do Narnie, které je společné jako pro druhý sloupec, tak pro druhý řádek.\n\nDůsledkem neopatrného zacházení se spojováním sloupců může být výsledek viditelný ve \"druhé ukázce .{target:_blank}\":http://demo.zeminem.cz/tabulkovy-paradox.php. Za domácí úkol se pokuste napsat alespoň jednu tabulku bez nahlédnutí do zdrojového kódu... :-)\n\nA poslední perlička vyvracející tvrzení, že párový element <code>&lt;tr&gt;&lt;/tr&gt;</code> vytváří v tabulce novou řádku. Podívejte se na následující kód. Hádám, že už je vám jasné co se stane.\n/--code html\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\n</table>\n\\--\nVýsledek je vidět ve \"třetí ukázce .{target:_blank}\":http://demo.zeminem.cz/tabulkovy-paradox.php.\n\nVyzkoušejte, že se tabulkový paradox vykresluje ve všech prohlížečích stejně. Mám to tedy chápat tak, že tolik oblíbený Chrome je stejný shit jako IE? Kdepak... Jedná se opravdu o paradox, který by sice měl (prapodivné) řešení((výsledek potlačující paradox, vyvolávající další spory)), ale pak by byl porušen význam některých atributů buňek tabulky.',	'2012-10-06 22:58:12',	'0000-00-00 00:00:00'),
(6,	'Výpočet mediánu',	'Zadání\n======\n\nNajděte v dostupné literatuře nebo vymyslete co nejlepší algoritmus pro výpočet mediánu.\nNezapomeňte na citaci zdrojů. Kritéria kvality v sestupném pořadí jsou: výpočetní složitost, \njednoduchost a implementační nenáročnost, paměťová spotřeba.\n\nDefinice\n========\n\nMedián je hodnota, která dělí seřazenou posloupnost na dvě stejně velké (co se množství týče)\nčásti. Důležitou vlastností mediánu je skutečnost, že není ovlivněn žádnou extrémní hodnotou,\njako je tomu například u průměru.\n\nAnalýza problému\n================\n\nExistuje několik způsobů jak daný problém vyřešit. První řešení bude velmi přímočaré. Jedná se\ntotiž o způsob, který zřejmě napadne každého jako první.\n\nPřímočaré řešení\n----------------\n\nToto řešení vlastně ani není tak hledání mediánu jako hledání algoritmicky nejrychlejšího způsobu\njako seřadit danou posloupnost čísel, protože pokud již máme seřazenou posloupnost, stačí zvolit\nprostřední prvek a získáme požadovaný medián. Tento poslední krok můžeme přirozeně vykonat\nse složitostí O(1). Seřadit posloupnost je možné lineárně logaritmickou složitostí O(NlogN) avšak\ns dodatečnou pamětí. Dodatečné paměti je samozřejmě možné se vyhnout, například použitím\nřadicího algoritmu Quicksort, vystavujeme se však nebezpečí kvadratické složitosti v nejhorším\npřípadě.\n\nPři zpětném pohledu je jasné, že nejvíce času strávíme řazením posloupnosti. Přitom řazení\nnebylo v zadání. Je to opravdu nutné? Následující algoritmy uvažují vstupní neseřazenou posloupnost\nstejně jako přímočaré řešení, ale nebudou vynakládat všechen svůj drahocený čas k\nřazení.\n\nAlgoritmus FIND\n---------------\n\nMetoda FIND je mnohem promyšlenější. Využívá techniky \"rozděl a panuj\", což je samo o sobě\nvelmi silná zbraň. FIND se chová velmi podobně jako již zmíněný Quicksort (oba algoritmy vymyslel\nTony Hoare) s tím, že hledá k-té nejmenší číslo, což je pouze zobecnění problému hledání\nmediánu.\n\nPři hledání postupujeme tak, že neseřazenou posloupnost projíždíme zleva, dokud nenalezneme\nprvek, který je větší (nebo roven) než námi zvolený pivot. Poté projíždíme posloupnost\nzprava, dokud nenarazíme na prvek, který je menší (nebo roven) pivotu. V tuto chvíli máme k\ndispozici dva prvky, a oba jsou na špatné straně, takže je prohodíme. V procesu zkoumání výměn\npokračujeme tak dlouho, dokud se nestřetneme. Tím je zajištěno, že jsou menší prvky než pivot\numístěny na levé straně a prvky větší než pivot zase na pravé.\n\nTím však ještě není medián určen, protože pivot byl zvolen (například) náhodně. Můžou\ntotiž nastat tři případy. V nejideálnější situaci je opravdu pivot mediánem a celý proces hledání\nmůžeme úspěšně ukončit. Může se však stát, že pivot nebude uprostřed posloupnosti, tedy byl\nzvolen nešťastně a není mediánem. V tom případě musíme hledat (např. rekurzivně) medián v\nhorní, popř. dolní části posloupnosti v závislosti na umístění aktuálního pivota. Jinak řečeno pokud\nbyl pivot moc malý, upravíme spodní mez posloupnosti. Pokud byl pivot naopak velký,\nupravíme horní mez posloupnosti a cel ý postup opakujeme. Pokud je pivot \"tak akorát\", pak je\nnaším mediánem.\n\nOčekávaný čas metody FIND je 4n, je nutné však připomenout, že je celé hledání založeno na\nQuicksortu, takže může složitost klesnout do kvadratické třídy. Existuje však i lineární řešení viz\nnásledující odstavce.\n\nAlgoritmus SELECT\n-----------------\n\nSELECT je svým chováním velmi podobný metodě FIND, ale dokáže eliminovat problém se\nšpatným zvolením pivota. Postupuje se následovně. Nejdříve rozdělíme neseřazenou posloupnost\nna pět částí s tím, že jedna nemusí být úplná. Následně najdeme medián každé skupiny. Z\nnalezených mediánů najdeme jeden celkový medián. Zde se však nesmíme ukvapit a použít tento\nmedián jako výsledný. Zatím to totiž byl pouze poměrně spolehlivý odhad vhodného pivota pro\ndělení celé posloupnosti.\n\nOpět mohou nastat tři příklady tzn. pivot je rovnou mediánem, pivot je větší, nebo je pivot\nmenší než medián. Při neshodě pivota s mediánem voláme SELECT rekurzivně do té doby,\nnež dostaneme požadovaný prvek. Postup hledání se může zdát dost zamotaný a rekurze na\npřehlednosti nepřidává, nicméně tento algoritmus má složitost O(n).\n\nSrovnání zmíněných algoritmů\n============================\n\nHledání mediánu pomocí přímočaré metody vede k seřazení posloupnosti (což nebylo zadáno).\nKromě toho získáme nejlepší složitost O(NlogN), což nemusí být úplně špatné vzhledem k nejhor\nší složitosti Quicksortu O(n^2), ale spotřebujeme více paměti. Oproti tomu algoritmus FIND\nnezabere více paměti než je nutné, jeho složitost však může být také kvadratická. Jednoznačně\nnejlepší řešení se zdá být metoda vyhledávání SELECT, která nejenže nespotřebuje dodatečnou\npaměť, ale navíc si udržuje lineární složitost což je alespoň podle běžně dostupné literatury\nnejlepší možné řešení.\n\nZávěr\n=====\n\nNezáleží-li nám na složitosti, nebo paměťové náročnosti, zvolíme přímočarou metodu hledání\nmediánu, která je nejjednodužší na implementaci a pochopení. V opačném případě zvolíme algoritmus\nSELECT, který je sice složitý, ale má vynikající výsledky.',	'2012-11-23 22:43:39',	'0000-00-00 00:00:00'),
(7,	'Osm návrhových přikázání',	'Právě mám rozečtenou knihu, která popisuje návrhové vzory v PHP. Mimo jiné autor popisuje pravidla při návrhu softwaru, která jsou prokládána velkým množstvím ukázek a vysvětlivek. Celkem je na třiceti stranách knihy (kde je rozebírán návrh) schován následující seznam pravidel.\r\n\r\n1) Přístup k údajům vždy v rámci třídy zapouzdřete a poskytněte metody, pomocí nichž lze dané údaje získat.\r\n2) Svá rozhraní navrhujte tak, aby je bylo možné později rozšířit.\r\n3) V metodách tříd nezapouzdřujte jen údaje, ale také algoritmy, díky čemuž budou komplexní operace implementované centrálně na jednom místě.\r\n4) Znovupoužitelnost kódu je lepší než duplicitní kód.\r\n5) Vyvarujte se monolitickým strukturám a rozložte je na co nejmenší části, které mohou být implementované nezávisle na sobě. Pokud používáte rozsáhlé příkazy <code>if/elseif/else</code> nebo <code>switch</code>, popřemýšlejte, zda by se nedaly nahradit zaměnitelnými třídami.\r\n6) Dědění vede k neflexibilním strukturám. Na kombinaci různých funkcí používejte raději kompozice objektů.\r\n7) Vždy programujte vůči rozhraní, a nikdy ne vůči konkrétní implementaci.\r\n8) Vyhýbejte se těsným závislostem mezi jednotlivými třídami aplikace a vždy upřednostňujte volné vazby tříd.\r\n\r\nDalší seznam který všichni znají, ale málokdo ho úplně dodržuje. (-:',	'2012-12-25 23:01:14',	'2012-12-25 23:01:14'),
(9,	'Návrhový vzor Singleton',	'Návrhový vzor Singleton je velmi známý. Má za úkol zajistit, že bude z určité třídy existovat pouze jedna instance. K této instanci poskytne globální přístupový bod. Jednoduché zadání, ale samotná implementace může být v PHP zákeřná. Proč? Tak prvně záleží na tom, jak budeme u návrhu striktní.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n}\n\\--\n\nTakovouto třídu lze totiž rovnou prohlásit za návrhový vzor Singleton. Dává to smysl, protože můžeme zavolat:\n\n/--code php\n$obj1 = Object::getInstance();\n$obj2 = Object::getInstance();\n\\--\n\nTím se pokusíme vytvořit dvě instance této třídy, ve skutečnosti se však vytvoří jen jedna. Tyto objekty jsou identické, což lze dokázat jednoduchou zkouškou:\n\n/--code php\nif($obj1 === $obj2) {\n	echo \'$obj1 === $obj2\'; //TRUE\n} else {\n	echo \'$obj1 !== $obj2\';\n}\n\\--\n\nSingleton to je a nikdo nemůže říct ne. Jak jsem však již psal, záleží na tom, jak budeme u návrhu striktní, protože by to nebylo PHP, kdyby neexistovalo několik otazníků a háčků. Pravděpodobně spoustu lidí totiž napadne, že metoda <code>getInstance()</code> je sice hezká, ale vůbec ji nemusím použít. V takovém případě celý princip Singletona padá.\n\n/--code php\n$obj1 = Object::getInstance();\n$obj2 = new Object();\n\nif($obj1 === $obj2) {\n	echo \'$obj1 === $obj2\';\n} else {\n	echo \'$obj1 !== $obj2\'; //TRUE\n}\n\\--\n\nTo je jasné, zatím ve třídě neexistuje žádný mechanismus, který by zakázal používání konstruktoru. K tomu je potřeba pouze malá úprava třídy.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n	protected function __construct() {}\n}\n\\--\n\nV tento moment již nepůjde objekt vytvořit pomocí operátoru <code>new</code>. Případný pokus skončí fatální chybou. Nebylo by to však PHP, kdyby neexistovalo několik dalších otazníků a háčků. S ledovým klidem si totiž mohu první vytvořený objekt naklonovat a tím opět získám dvě nezávislé instance jedné třídy. Ale to jsem přece nechtěl!\n\n/--code php\n$obj1 = Object::getInstance();\n$obj2 = clone $obj1;\n\nif($obj1 === $obj2) {\n	echo \'$obj1 === $obj2\';\n} else {\n	echo \'$obj1 !== $obj2\'; //TRUE\n}\n\\--\n\nProti tomuto postupu se mohu bránit opět podobným způsobem jako u konstruktoru.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n	protected function __construct() {}\n	private function __clone() {}\n}\n\\--\n\nPokus o naklonování již vytvořené instance pomocí metody <code>getInstance()</code> skončí opět fatální chybou. Jenže nebylo by to PHP, kdyby... Co se stane, když vytoření objekt serializuji a pak ho zase deserializuji?\n\n/--code php\n$obj1 = Object::getInstance();\n$obj2 = unserialize(serialize($obj1));\n\nif($obj1 === $obj2) {\n	echo \'$obj1 === $obj2\';\n} else {\n	echo \'$obj1 !== $obj2\'; //TRUE\n}\n\\--\n\nTo už začíná být poněkud otravné. Ale tak dobře, i to se dá ošéfovat.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n	protected function __construct() {}\n	private function __clone() {}\n	private function __wakeup() {}\n}\n\\--\n\nToto už sice vrátí jen warning, ale víme o tom. Schválně jsem nepsal, že se to vše dá ošetřit, protože je to spíše zákaz (popř. upozornění). Je samozřejmě možné (lepší) vracet různé vyjímky atd. Stejně tak je spousta variant jak psát přítupové modifikátory k metodám. To jednoduše vše zaleží na tom, co od Singleton objektu očekáváme a kdo objekt používá, protože jak jsem již psal, úplně klidně stačí Singleton s jednou metodou <code>getInstance()</code>. Svoji funkci plní, tečka.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n	protected function __construct() {}\n	public final function __clone() {\n		throw new Exception(\'Objekt nelze klonovat!\');\n	}\n	public final function __wakeup() {\n		throw new Exception(\'Objekt nelze deserializovat!\');\n	}\n}\n\\--',	'2012-12-26 20:38:01',	'0000-00-00 00:00:00'),
(10,	'Návrhový vzor Factory Method',	'Návrhový vzor Factory Method má za úkol definovat rozhraní pro vytváření objektů s tím, že vlastní tvorbu instancí přenechává potomkům. Samotný návrhový vzor tedy tvoří například tyto dvě třídy.\n\n/--code php\n<?php\nabstract class ACreator {\n	protected $attribute;\n	public function __construct($attribute) {\n		$this->attribute = $attribute;\n	}\n	abstract public function createConcreteObject();\n}\n\\--\n\n/--code php\n<?php\nclass ConcreteCreator extends ACreator {\n	public function createConcreteObject() {\n		$concreteObject = new ConcreteObject($this->attribute);\n		return $concreteObject;\n	}\n}\n\\--\n\nAby však tento vzor měl nějaký smysl, je potřeba ještě minimálně jedna třída od které se budou dělat instance (ConcreteObject).\n\n/--code php\n<?php\nclass ConcreteObject implements IObject {\n	protected $attribute;\n	public function __construct($attribute) {\n		$this->attribute = $attribute;\n	}\n	public function test() {\n		echo $this->attribute;\n	}\n}\n\\--\n\nPřípadně jeho rozhraní:\n\n/--code php\n<?php\ninterface IObject {\n	public function test();\n}\n\\--\n\nVraťme se však na začátek. Vytvářet objekty všichni umí. Slouží k tomu známý operátor <code>new</code>. Na tom není nic divného, ale jen do chvíle, než se nad tím zamyslíte. Představte si rozsáhlou aplikaci, kde na každém rohu potřebujete vytvořit instanci určitého objektu. Takže jako vždy zavoláte operátor <code>new</code> a předáte všechny potřebné argumenty. A pak se to stane. Najednou zjistíte, že nutně potřebujete přidat do konstruktoru argument/y a máte týden co dělat. K tomu se právě hodí vytvořit si továrnu na tyto instance, kdy budeme pouze volat metodu pro její vytvoření, ale to jak se vytvoří necháme na továrně. Obecně se ve světě OOP velmi často dělá, že nějakou práci prostě necháme na někom jiném. Je to funkční a pohodlný přístup. :-)\n\nPokud tedy zapomenu na to, že existují nějaké třídy Creator, tak by použití třídy ConcreteObject vypadalo asi takto:\n\n/--code php\n$instance = new ConcreteObject(\'TEST\');\n$instance->test();\n\\--\n\nPři zapojení továrny je použití zdánlivě složitější.\n\n/--code php\n$factory = new ConcreteCreator(\'TEST\');\n$instance = $factory->createConcreteObject();\n$instance->test();\n\\--\n\nPřidaná hodnota tohoto postupu je však velká. Již nejsme vázání na konkrétní implementaci objektu ConcreteObject. Vlastně nás to vůbec nezajímá. Víme, že pro jeho tvorbu potřebuje továrna nějaký atribut a to, jestli pak ještě další tři přidá, nebo ne, nám může být úplně jedno. Kdo stále ještě nevěří, že je tento postup výhodný, nechť si vyzkouší vytvořit několik instancí stejného objektu (hloupý, ale názorný příklad).\n\n/--code php\n// pomocí operátoru new:\n$instance = new ConcreteObject(\'TEST\');\n$instance = new ConcreteObject(\'TEST\');\n$instance = new ConcreteObject(\'TEST\');\n$instance = new ConcreteObject(\'TEST\');\n$instance = new ConcreteObject(\'TEST\');\n\n// pomocí továrny:\n$factory = new ConcreteCreator(\'TEST\');\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n\\--\n\nA teď přidejme nový atribut - aktuální rok.\n\n/--code php\n// pomocí operátoru new:\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n\n// pomocí továrny:\n$factory = new ConcreteCreator(\'TEST\', date(\'Y\'));\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n\\--\n\nKrom toho, že by mě za chvíli přestalo bavit do každého konstruktoru kopírovat nový atribut, tak jsem také mohl udělat o hodně více chyb než u továrny. Pravdou je, že jsem musel upravit ještě pár tříd:\n\n/--code php\n<?php\nclass ConcreteObject implements IObject {\n	protected $attribute;\n	protected $year;\n	public function __construct($attribute, $year) {\n		$this->attribute = $attribute;\n		$this->year = $year;\n	}\n	// ...\n}\n\nabstract class ACreator {\n	protected $attribute;\n	protected $year;\n	public function __construct($attribute, $year) {\n		$this->attribute = $attribute;\n		$this->year = $year;\n	}\n	abstract public function createConcreteObject();\n}\n\nclass ConcreteCreator extends ACreator {\n	public function createConcreteObject() {\n		$concreteObject = new ConcreteObject($this->attribute, $this->year);\n		return $concreteObject;\n	}\n}\n\\--\n\nNicméně křivka výhod při používání továrny velmi rychle překoná svým stoupáním křivku lenosti při používání operátoru new.\n\nMimochodem vzpomeňte si na \"osm návrhových přikázání\":http://www.zeminem.cz/osm-navrhovych-prikazani, kde se také říká, že máme vždy programovat vůči rozhraní, a nikdy ne vůči konkrétní implementaci, což tento návrhový vzor perfektně splňuje.',	'2012-12-27 23:52:39',	'0000-00-00 00:00:00'),
(11,	'Nette 2.1-dev CliRouter',	'Routování CLI((Command Line Interface)) aplikací je oblast, o které se v Nette moc nemluví. A když mluví, tak divně (nebo staře). Což na jednu stranu dává smysl, protože tato routa existuje už od roku 2009. Na druhou stranu je to zvláštní, protože je stále experimentální.\n\n> The unidirectional router for CLI.\n> \n> (experimental)\n\nDokonce se už mluvilo o tom, že se zruší. No snad se to nestane...\n\nProč o tom mluvím? Rád bych ukázal, jak se dá v nastávající verzi Nette tato routa použít. V nové verzi Nette se již routy nepíší do bootsrap.php jak tomu bylo (alespoň myslím) dříve. Tentokrát je v adresářové struktuře soubor router/**RouterFactory.php**, který se právě o routování postará. Tento soubor může vypadat například takto:\n\n/--code php\n<?php\n\nnamespace App;\n\nuse Nette,\n	Nette\\Application\\Routers\\RouteList,\n	Nette\\Application\\Routers\\Route,\n	Nette\\Application\\Routers\\CliRouter;\n\n/**\n * Router factory.\n */\nclass RouterFactory {\n\n	private $container;\n\n	public function __construct(Nette\\DI\\Container $container) {\n		$this->container = $container;\n	}\n\n	/**\n	 * @return \\Nette\\Application\\IRouter\n	 */\n	public function createRouter() {\n		$router = new RouteList();\n		if ($this->container->parameters[\'consoleMode\']) {\n			$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\n		} else {\n			$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\n			$router[] = new Route(\'user/<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'User\',\n				\'presenter\' => \'Board\',\n				\'action\' => \'default\',\n			));\n			$router[] = new Route(\'<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'Front\',\n				\'presenter\' => \'Homepage\',\n				\'action\' => \'default\',\n			));\n		}\n		return $router;\n	}\n\n}\n\\--\n\nToto je reálná funkční ukázka (ze které jsem něco nepodstatného umazal). Jak je vidět, tak aplikaci mám rozdělenou na moduly, takže defaultní routa ukazuje do modulu Front, pak je k dispozici User modul, link na RSS a konečně CliRouter, který se naroutuje pouze v případě, že běží aplikace v konzolovém módu (CLI).\n\nPokud se teď přesunu k presenterové části modulu Cli, mohu zde umístit dvě třídy. Klasický BasePresenter, který bude pro jistotu kontrolovat, jestli se opravdu jedná o consoleMode například takto:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nabstract class BasePresenter extends Nette\\Application\\UI\\Presenter {\n\n	public function startup() {\n		parent::startup();\n		if (!$this->context->parameters[\'consoleMode\']) {\n			throw new Nette\\Security\\AuthenticationException;\n		}\n	}\n\n}\n\\--\n\nNo a pak už stačí jen CliPresenter, který bude dědit od BasePresenteru, takže vždy dojde ke kontrole. Zde stačí metoda action*(), která se spustí podle naroutování. V mém případě se tedy jedná o actionCron():\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nclass CliPresenter extends BasePresenter {\n\n	public function actionCron() {\n		echo \'FUNGUJU!\';\n		$this->terminate();\n	}\n\n}\n\\--\n\nA teď to nejdůležitější! Aplikace se spustí pomocí terminálu jednoduchým příkazem \"<code>php index.php</code>\". Samozřejmě je nutné ukázat na index Nette aplikace. No a samozřejmě se mohu odkázat i na jinou část aplikace dopsání parametru. Pokud bych chtěl podle výše uvedených souborů přejít na hlavní stránku, stačí napsat pouze \"<code>php index.php Fron:Homepage:default</code>\".',	'2013-03-17 22:02:36',	'0000-00-00 00:00:00'),
(43,	'Testovací titulek',	'Tělo s použitím **texy**.',	'2013-07-28 14:05:25',	'2013-12-31 23:00:00');

DROP TABLE IF EXISTS `posts_tags`;
CREATE TABLE `posts_tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_id` int(11) NOT NULL,
  `post_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `tag_id` (`tag_id`),
  KEY `post_id` (`post_id`),
  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),
  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `posts_tags` (`id`, `tag_id`, `post_id`) VALUES
(98,	42,	10),
(99,	42,	9),
(100,	43,	4),
(101,	41,	11),
(102,	42,	11);

DROP TABLE IF EXISTS `tags`;
CREATE TABLE `tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `color` varchar(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `tags` (`id`, `name`, `color`) VALUES
(41,	'nette',	'106dcf'),
(42,	'php',	'aa16b1'),
(43,	'html',	'1c7640');

-- 2013-07-28 18:13:35
