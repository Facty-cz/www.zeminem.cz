-- Adminer 3.6.2 MySQL dump

SET NAMES utf8;
SET foreign_key_checks = 0;
SET time_zone = 'SYSTEM';
SET sql_mode = 'NO_AUTO_VALUE_ON_ZERO';

DROP TABLE IF EXISTS `mirror_posts`;
CREATE TABLE `mirror_posts` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` text NOT NULL,
  `body` text NOT NULL,
  PRIMARY KEY (`id`),
  FULLTEXT KEY `title_body` (`title`,`body`),
  FULLTEXT KEY `title` (`title`),
  FULLTEXT KEY `body` (`body`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

INSERT INTO `mirror_posts` (`id`, `title`, `body`) VALUES
(2,	'Asymetrická šifra s veřejným klíčem',	'O veřejné distribuci klíčů jsem již dříve psal. Pojďme se však podívat nejen na samotnou distribuci, ale i na myšlenku asymetrického šifrování. Prvně je však třeba vysvětlit několik důležitých věcí. Začněme tím, co vlastně znamená asymetrická šifra. Před myšlenkou asymetrického šifrování, jejíž autorem je Whitfield Diffie, se používalo výhradně šifrování symetrické, což znamená, že proces dešifrování zakódované zprávy je přesně opačný k procesu šifrování. Asymetrické šifrování však zavádí myšlenku použití jiného klíče na šifrování a jiného na dešifrování.\r\n\r\nJak to vyřešit? Jak je možné použít jiný klíč na šifrování a jiný na dešifrování? Již existoval koncept, který umožňoval výměnu  klíčů veřejně (a bezpečně). Stále byl však na principu synchronní komunikace odesílatele a příjemce, což nebylo optimální řešení a proto byl vymyšlen způsob jak tento problém obejít. Myšlenka byla jednoduchá. Příjemce musí vytvořit veřejný klíč, který následně zveřejní tak, aby byl veřejný opravdu pro všechny. V tomto případě je jasné, že by to nemělo smysl, pokud by se nepoužívala jednosměrná funkce šifrování, což je další pravidlo. A zároveň opět onen příjemce musí mít svůj tajný klíč, který dokáže informaci zašifrovanou veřejným klíčem dešifrovat. Z toho je patrná ta asymetričnost šifry. Nepoužívám stejný klíč na zašifrování a dešifrování jako u jiných šifer.\r\n\r\nTomuto systému se říká RSA (Ronald Riverst, Adi Shamir, Leonard Adleman). Pojďme se na něj teď podívat matematicky, protože teorie je moc obecná (a matematika zase složitá). Odesílatel zprávy si musí zvolit dvě velmi velká prvočísla (A, B). Tyto prvočísla mezi sebou vynásobí a dostane další ještě větší číslo (AB). Násobení je zcela triviální jednosměrná operace a systém RSA si zakládá na tom, že faktorizovat velké číslo je v reálním čase prakticky nemožné. Dále si odesílatel zvolí číslo C a to uveřejní společně s číslem AB. Toto jsou informace, které má každý k dispozici. Pro šifrování je nutné zprávu převést na číslo M (například binárně). Toto číslo se poté dosadí podle vzorce \"šifra\"= M^C (mod AB). Zpětně se pak informace dá velmi snadno dostat obráceným postupem se znalostí onoho součinu prvočísel zvolených na začátku. Bez znalosti těchto prvočísel je dešifrování téměř nemožné, což však také není úplně pravda viz poslední odstavec.\r\n\r\nJe zřejmé, že úspěch šifry spočívá ve zvolení dostatečně velkých prvočísel a mocnitele C, který by vzhledem k prvočíslům neměl mít žádného společného dělitele. Resp. přesněji čísla C a (A-1) * (B-1). Při představení RSA byl pro jeho reprezentaci uveřejněn zašifrovaný text s veřejným klíčem. Soutěžním úkolem bylo faktorizovat veřejný klíč na dvě složky a poté zprávu dešifrovat. Faktorizace trvala ve výsledku celkem 17 let, kdy tým 600 dobrovolníků oznámil 26. dubna 1994 činitele veřejného klíče. A jaký že byl ten klíč?\r\n\r\n/--code\r\nN = 114 381 625 757 888 867 669 235 779 976 146 612 010 218 296 721 242 362 562 561 842 935 706 935 245 733 897 830 597 123 563 958 705 058 989 075 147 599 290 026 879 543 541\r\n\\--\r\n\r\nDílčí prvočísla si nechám jako tajemství? (-:'),
(3,	'Lovec matematik',	'Znáte následující hádanku?\r\n\r\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Tam zastřelil medvěda. Jakou měl medvěd barvu?\r\n\r\nŘešení je více než jednoduché. Stačí si představit sférický trojúhelník vycházející ze severního pólu, který má všechny strany dlouhé 10 km (tedy každý úhel má 90°). Vzhledem k severnímu pólu je zřejmé, že medvěd musí být bílý. Existuje však ještě jiné řešení této hádanky čistě z geometrického (matematického chcete-li) hlediska? Vypusťme tedy medvěda a zamysleme se nad následující hádankou:\r\n\r\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Měl však smůlu a tak nic neulovil.\r\n\r\nJedno řešení už známe. Zamyslete se ještě jednou nad druhým řešením. Přesuňme se na jižní polokouli do libovolného bodu vzdáleného 11 591,55 m od jižního pólu. Pokud šel lovec nejprve 10 km na jih, dorazil do druhého bodu vzdáleného 1591,55 m od jižního pólu. Ze základní matematiky jistě všichni znají vzorec pro obvod kruhu O = 2&pi;r. Dosazením do vzorce zjistíme velmi zajímavou skutečnost. Obvod kruhu, tedy délka cesty na západ je dlouhá přibližně přesně 10 km. Lovec se tedy dostane na stejný bod vzdálený 1591,55 m od pólu a cestou na sever dojde do úplného začátku stejně tak jako tomu bylo při využití sférického trojúhelníku na opačné straně planety.\r\n\r\nPokud nebyl lovec matematik a neuvědomoval si tuto skutečnost, muselo být poměrně vyčerpávající dorazit po třiceti kilometrech do stejného místa...'),
(4,	'Tabulkový masakr',	'Určitě znáte HTML a tím pádem znáte i tabulky. Pro jistotu připomenutí.\nTabulka se v HTML tvoří párovým tagem <code>&lt;table&gt;&lt;/table&gt;</code>, její řádky jsou <code>&lt;tr&gt;&lt;/tr&gt;</code> a buňky <code>&lt;td&gt;&lt;/td&gt;</code>. Buňky mají volitelné atributy <code>rowspan</code> a <code>colspan</code>. Tyto atributy určují, kolik bude buňka zabírat místa v řádce, resp. ve sloupci. Tyto znalosti stačí k pochopení pojmu \"tabulkový paradox\".\n\nPodívejte se na \"první ukázku\":http://www.zeminem.cz/demo/tabulkovy-masakr1, kde je vidět co se stane, když roztáhneme buňku **A2** na tři řádky a zároveň roztáhneme buňku **B1** na tři sloupce podle následujícího kódu:\n/--code html\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n	<tr>\n		<td width=\"33%\">A1</td>\n		<td width=\"33%\" rowspan=\"4\">A2</td>\n		<td width=\"33%\">A3</td>\n	</tr>\n	<tr>\n		<td colspan=\"3\">B1</td>\n	</tr>\n	<tr>\n		<td>C1</td>\n		<td>C3</td>\n	</tr>\n	<tr>\n		<td>D1</td>\n		<td>D3</td>\n	</tr>\n</table>\n\\--\nTam kde by měla být buňka **B2** vzniká krásné okénko do Narnie, které je společné jako pro druhý sloupec, tak pro druhý řádek.\n\nDůsledkem neopatrného zacházení se spojováním sloupců může být výsledek viditelný ve \"druhé ukázce\":http://www.zeminem.cz/demo/tabulkovy-masakr2. Za domácí úkol se pokuste napsat alespoň jednu tabulku bez nahlédnutí do zdrojového kódu... :-)\n\nA poslední perlička vyvracející tvrzení, že párový element <code>&lt;tr&gt;&lt;/tr&gt;</code> vytváří v tabulce novou řádku. Podívejte se na následující kód. Hádám, že už je vám jasné co se stane.\n/--code html\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\n</table>\n\\--\nVýsledek je vidět ve \"třetí ukázce\":http://www.zeminem.cz/demo/tabulkovy-masakr3.\n\nVyzkoušejte, že se tabulkový paradox vykresluje ve všech prohlížečích stejně. Mám to tedy chápat tak, že tolik oblíbený Chrome je stejný shit jako IE? Kdepak... Jedná se opravdu o paradox, který by sice měl (prapodivné) řešení((výsledek potlačující paradox, vyvolávající další spory)), ale pak by byl porušen význam některých atributů buňek tabulky.'),
(6,	'Výpočet mediánu',	'Zadání\n======\n\nNajděte v dostupné literatuře nebo vymyslete co nejlepší algoritmus pro výpočet mediánu.\nNezapomeňte na citaci zdrojů. Kritéria kvality v sestupném pořadí jsou: výpočetní složitost, \njednoduchost a implementační nenáročnost, paměťová spotřeba.\n\nDefinice\n========\n\nMedián je hodnota, která dělí seřazenou posloupnost na dvě stejně velké (co se množství týče)\nčásti. Důležitou vlastností mediánu je skutečnost, že není ovlivněn žádnou extrémní hodnotou,\njako je tomu například u průměru.\n\nAnalýza problému\n================\n\nExistuje několik způsobů jak daný problém vyřešit. První řešení bude velmi přímočaré. Jedná se\ntotiž o způsob, který zřejmě napadne každého jako první.\n\nPřímočaré řešení\n----------------\n\nToto řešení vlastně ani není tak hledání mediánu jako hledání algoritmicky nejrychlejšího způsobu\njako seřadit danou posloupnost čísel, protože pokud již máme seřazenou posloupnost, stačí zvolit\nprostřední prvek a získáme požadovaný medián. Tento poslední krok můžeme přirozeně vykonat\nse složitostí O(1). Seřadit posloupnost je možné lineárně logaritmickou složitostí O(NlogN) avšak\ns dodatečnou pamětí. Dodatečné paměti je samozřejmě možné se vyhnout, například použitím\nřadicího algoritmu Quicksort, vystavujeme se však nebezpečí kvadratické složitosti v nejhorším\npřípadě.\n\nPři zpětném pohledu je jasné, že nejvíce času strávíme řazením posloupnosti. Přitom řazení\nnebylo v zadání. Je to opravdu nutné? Následující algoritmy uvažují vstupní neseřazenou posloupnost\nstejně jako přímočaré řešení, ale nebudou vynakládat všechen svůj drahocený čas k\nřazení.\n\nAlgoritmus FIND\n---------------\n\nMetoda FIND je mnohem promyšlenější. Využívá techniky \"rozděl a panuj\", což je samo o sobě\nvelmi silná zbraň. FIND se chová velmi podobně jako již zmíněný Quicksort (oba algoritmy vymyslel\nTony Hoare) s tím, že hledá k-té nejmenší číslo, což je pouze zobecnění problému hledání\nmediánu.\n\nPři hledání postupujeme tak, že neseřazenou posloupnost projíždíme zleva, dokud nenalezneme\nprvek, který je větší (nebo roven) než námi zvolený pivot. Poté projíždíme posloupnost\nzprava, dokud nenarazíme na prvek, který je menší (nebo roven) pivotu. V tuto chvíli máme k\ndispozici dva prvky, a oba jsou na špatné straně, takže je prohodíme. V procesu zkoumání výměn\npokračujeme tak dlouho, dokud se nestřetneme. Tím je zajištěno, že jsou menší prvky než pivot\numístěny na levé straně a prvky větší než pivot zase na pravé.\n\nTím však ještě není medián určen, protože pivot byl zvolen (například) náhodně. Můžou\ntotiž nastat tři případy. V nejideálnější situaci je opravdu pivot mediánem a celý proces hledání\nmůžeme úspěšně ukončit. Může se však stát, že pivot nebude uprostřed posloupnosti, tedy byl\nzvolen nešťastně a není mediánem. V tom případě musíme hledat (např. rekurzivně) medián v\nhorní, popř. dolní části posloupnosti v závislosti na umístění aktuálního pivota. Jinak řečeno pokud\nbyl pivot moc malý, upravíme spodní mez posloupnosti. Pokud byl pivot naopak velký,\nupravíme horní mez posloupnosti a cel ý postup opakujeme. Pokud je pivot \"tak akorát\", pak je\nnaším mediánem.\n\nOčekávaný čas metody FIND je 4n, je nutné však připomenout, že je celé hledání založeno na\nQuicksortu, takže může složitost klesnout do kvadratické třídy. Existuje však i lineární řešení viz\nnásledující odstavce.\n\nAlgoritmus SELECT\n-----------------\n\nSELECT je svým chováním velmi podobný metodě FIND, ale dokáže eliminovat problém se\nšpatným zvolením pivota. Postupuje se následovně. Nejdříve rozdělíme neseřazenou posloupnost\nna pět částí s tím, že jedna nemusí být úplná. Následně najdeme medián každé skupiny. Z\nnalezených mediánů najdeme jeden celkový medián. Zde se však nesmíme ukvapit a použít tento\nmedián jako výsledný. Zatím to totiž byl pouze poměrně spolehlivý odhad vhodného pivota pro\ndělení celé posloupnosti.\n\nOpět mohou nastat tři příklady tzn. pivot je rovnou mediánem, pivot je větší, nebo je pivot\nmenší než medián. Při neshodě pivota s mediánem voláme SELECT rekurzivně do té doby,\nnež dostaneme požadovaný prvek. Postup hledání se může zdát dost zamotaný a rekurze na\npřehlednosti nepřidává, nicméně tento algoritmus má složitost O(n).\n\nSrovnání zmíněných algoritmů\n============================\n\nHledání mediánu pomocí přímočaré metody vede k seřazení posloupnosti (což nebylo zadáno).\nKromě toho získáme nejlepší složitost O(NlogN), což nemusí být úplně špatné vzhledem k nejhor\nší složitosti Quicksortu O(n^2), ale spotřebujeme více paměti. Oproti tomu algoritmus FIND\nnezabere více paměti než je nutné, jeho složitost však může být také kvadratická. Jednoznačně\nnejlepší řešení se zdá být metoda vyhledávání SELECT, která nejenže nespotřebuje dodatečnou\npaměť, ale navíc si udržuje lineární složitost což je alespoň podle běžně dostupné literatury\nnejlepší možné řešení.\n\nZávěr\n=====\n\nNezáleží-li nám na složitosti, nebo paměťové náročnosti, zvolíme přímočarou metodu hledání\nmediánu, která je nejjednodužší na implementaci a pochopení. V opačném případě zvolíme algoritmus\nSELECT, který je sice složitý, ale má vynikající výsledky.'),
(7,	'Osm návrhových přikázání',	'Právě mám rozečtenou knihu, která popisuje návrhové vzory v PHP. Mimo jiné autor popisuje pravidla při návrhu softwaru, která jsou prokládána velkým množstvím ukázek a vysvětlivek. Celkem je na třiceti stranách knihy (kde je rozebírán návrh) schován následující seznam pravidel.\r\n\r\n1) Přístup k údajům vždy v rámci třídy zapouzdřete a poskytněte metody, pomocí nichž lze dané údaje získat.\r\n2) Svá rozhraní navrhujte tak, aby je bylo možné později rozšířit.\r\n3) V metodách tříd nezapouzdřujte jen údaje, ale také algoritmy, díky čemuž budou komplexní operace implementované centrálně na jednom místě.\r\n4) Znovupoužitelnost kódu je lepší než duplicitní kód.\r\n5) Vyvarujte se monolitickým strukturám a rozložte je na co nejmenší části, které mohou být implementované nezávisle na sobě. Pokud používáte rozsáhlé příkazy <code>if/elseif/else</code> nebo <code>switch</code>, popřemýšlejte, zda by se nedaly nahradit zaměnitelnými třídami.\r\n6) Dědění vede k neflexibilním strukturám. Na kombinaci různých funkcí používejte raději kompozice objektů.\r\n7) Vždy programujte vůči rozhraní, a nikdy ne vůči konkrétní implementaci.\r\n8) Vyhýbejte se těsným závislostem mezi jednotlivými třídami aplikace a vždy upřednostňujte volné vazby tříd.\r\n\r\nDalší seznam který všichni znají, ale málokdo ho úplně dodržuje. (-:'),
(9,	'Návrhový vzor Singleton',	'Návrhový vzor Singleton je velmi známý. Má za úkol zajistit, že bude z určité třídy existovat pouze jedna instance. K této instanci poskytne globální přístupový bod. Jednoduché zadání, ale samotná implementace může být v PHP zákeřná. Proč? Tak prvně záleží na tom, jak budeme u návrhu striktní.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n}\n\\--\n\nTakovouto třídu lze totiž rovnou prohlásit za návrhový vzor Singleton. Dává to smysl, protože můžeme zavolat:\n\n/--code php\n$obj1 = Object::getInstance();\n$obj2 = Object::getInstance();\n\\--\n\nTím se pokusíme vytvořit dvě instance této třídy, ve skutečnosti se však vytvoří jen jedna. Tyto objekty jsou identické, což lze dokázat jednoduchou zkouškou:\n\n/--code php\nif($obj1 === $obj2) {\n	echo \'$obj1 === $obj2\'; //TRUE\n} else {\n	echo \'$obj1 !== $obj2\';\n}\n\\--\n\nSingleton to je a nikdo nemůže říct ne. Jak jsem však již psal, záleží na tom, jak budeme u návrhu striktní, protože by to nebylo PHP, kdyby neexistovalo několik otazníků a háčků. Pravděpodobně spoustu lidí totiž napadne, že metoda <code>getInstance()</code> je sice hezká, ale vůbec ji nemusím použít. V takovém případě celý princip Singletona padá.\n\n/--code php\n$obj1 = Object::getInstance();\n$obj2 = new Object();\n\nif($obj1 === $obj2) {\n	echo \'$obj1 === $obj2\';\n} else {\n	echo \'$obj1 !== $obj2\'; //TRUE\n}\n\\--\n\nTo je jasné, zatím ve třídě neexistuje žádný mechanismus, který by zakázal používání konstruktoru. K tomu je potřeba pouze malá úprava třídy.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n	protected function __construct() {}\n}\n\\--\n\nV tento moment již nepůjde objekt vytvořit pomocí operátoru <code>new</code>. Případný pokus skončí fatální chybou. Nebylo by to však PHP, kdyby neexistovalo několik dalších otazníků a háčků. S ledovým klidem si totiž mohu první vytvořený objekt naklonovat a tím opět získám dvě nezávislé instance jedné třídy. Ale to jsem přece nechtěl!\n\n/--code php\n$obj1 = Object::getInstance();\n$obj2 = clone $obj1;\n\nif($obj1 === $obj2) {\n	echo \'$obj1 === $obj2\';\n} else {\n	echo \'$obj1 !== $obj2\'; //TRUE\n}\n\\--\n\nProti tomuto postupu se mohu bránit opět podobným způsobem jako u konstruktoru.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n	protected function __construct() {}\n	private function __clone() {}\n}\n\\--\n\nPokus o naklonování již vytvořené instance pomocí metody <code>getInstance()</code> skončí opět fatální chybou. Jenže nebylo by to PHP, kdyby... Co se stane, když vytoření objekt serializuji a pak ho zase deserializuji?\n\n/--code php\n$obj1 = Object::getInstance();\n$obj2 = unserialize(serialize($obj1));\n\nif($obj1 === $obj2) {\n	echo \'$obj1 === $obj2\';\n} else {\n	echo \'$obj1 !== $obj2\'; //TRUE\n}\n\\--\n\nTo už začíná být poněkud otravné. Ale tak dobře, i to se dá ošéfovat.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n	protected function __construct() {}\n	private function __clone() {}\n	private function __wakeup() {}\n}\n\\--\n\nToto už sice vrátí jen warning, ale víme o tom. Schválně jsem nepsal, že se to vše dá ošetřit, protože je to spíše zákaz (popř. upozornění). Je samozřejmě možné (lepší) vracet různé vyjímky atd. Stejně tak je spousta variant jak psát přítupové modifikátory k metodám. To jednoduše vše zaleží na tom, co od Singleton objektu očekáváme a kdo objekt používá, protože jak jsem již psal, úplně klidně stačí Singleton s jednou metodou <code>getInstance()</code>. Svoji funkci plní, tečka.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n	protected function __construct() {}\n	public final function __clone() {\n		throw new Exception(\'Objekt nelze klonovat!\');\n	}\n	public final function __wakeup() {\n		throw new Exception(\'Objekt nelze deserializovat!\');\n	}\n}\n\\--'),
(10,	'Návrhový vzor Factory Method',	'Návrhový vzor Factory Method má za úkol definovat rozhraní pro vytváření objektů s tím, že vlastní tvorbu instancí přenechává potomkům. Samotný návrhový vzor tedy tvoří například tyto dvě třídy.\n\n/--code php\n<?php\nabstract class ACreator {\n	protected $attribute;\n	public function __construct($attribute) {\n		$this->attribute = $attribute;\n	}\n	abstract public function createConcreteObject();\n}\n\\--\n\n/--code php\n<?php\nclass ConcreteCreator extends ACreator {\n	public function createConcreteObject() {\n		$concreteObject = new ConcreteObject($this->attribute);\n		return $concreteObject;\n	}\n}\n\\--\n\nAby však tento vzor měl nějaký smysl, je potřeba ještě minimálně jedna třída od které se budou dělat instance (ConcreteObject).\n\n/--code php\n<?php\nclass ConcreteObject implements IObject {\n	protected $attribute;\n	public function __construct($attribute) {\n		$this->attribute = $attribute;\n	}\n	public function test() {\n		echo $this->attribute;\n	}\n}\n\\--\n\nPřípadně jeho rozhraní:\n\n/--code php\n<?php\ninterface IObject {\n	public function test();\n}\n\\--\n\nVraťme se však na začátek. Vytvářet objekty všichni umí. Slouží k tomu známý operátor <code>new</code>. Na tom není nic divného, ale jen do chvíle, než se nad tím zamyslíte. Představte si rozsáhlou aplikaci, kde na každém rohu potřebujete vytvořit instanci určitého objektu. Takže jako vždy zavoláte operátor <code>new</code> a předáte všechny potřebné argumenty. A pak se to stane. Najednou zjistíte, že nutně potřebujete přidat do konstruktoru argument/y a máte týden co dělat. K tomu se právě hodí vytvořit si továrnu na tyto instance, kdy budeme pouze volat metodu pro její vytvoření, ale to jak se vytvoří necháme na továrně. Obecně se ve světě OOP velmi často dělá, že nějakou práci prostě necháme na někom jiném. Je to funkční a pohodlný přístup. :-)\n\nPokud tedy zapomenu na to, že existují nějaké třídy Creator, tak by použití třídy ConcreteObject vypadalo asi takto:\n\n/--code php\n$instance = new ConcreteObject(\'TEST\');\n$instance->test();\n\\--\n\nPři zapojení továrny je použití zdánlivě složitější.\n\n/--code php\n$factory = new ConcreteCreator(\'TEST\');\n$instance = $factory->createConcreteObject();\n$instance->test();\n\\--\n\nPřidaná hodnota tohoto postupu je však velká. Již nejsme vázání na konkrétní implementaci objektu ConcreteObject. Vlastně nás to vůbec nezajímá. Víme, že pro jeho tvorbu potřebuje továrna nějaký atribut a to, jestli pak ještě další tři přidá, nebo ne, nám může být úplně jedno. Kdo stále ještě nevěří, že je tento postup výhodný, nechť si vyzkouší vytvořit několik instancí stejného objektu (hloupý, ale názorný příklad).\n\n/--code php\n// pomocí operátoru new:\n$instance = new ConcreteObject(\'TEST\');\n$instance = new ConcreteObject(\'TEST\');\n$instance = new ConcreteObject(\'TEST\');\n$instance = new ConcreteObject(\'TEST\');\n$instance = new ConcreteObject(\'TEST\');\n\n// pomocí továrny:\n$factory = new ConcreteCreator(\'TEST\');\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n\\--\n\nA teď přidejme nový atribut - aktuální rok.\n\n/--code php\n// pomocí operátoru new:\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n\n// pomocí továrny:\n$factory = new ConcreteCreator(\'TEST\', date(\'Y\'));\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n\\--\n\nKrom toho, že by mě za chvíli přestalo bavit do každého konstruktoru kopírovat nový atribut, tak jsem také mohl udělat o hodně více chyb než u továrny. Pravdou je, že jsem musel upravit ještě pár tříd:\n\n/--code php\n<?php\nclass ConcreteObject implements IObject {\n	protected $attribute;\n	protected $year;\n	public function __construct($attribute, $year) {\n		$this->attribute = $attribute;\n		$this->year = $year;\n	}\n	// ...\n}\n\nabstract class ACreator {\n	protected $attribute;\n	protected $year;\n	public function __construct($attribute, $year) {\n		$this->attribute = $attribute;\n		$this->year = $year;\n	}\n	abstract public function createConcreteObject();\n}\n\nclass ConcreteCreator extends ACreator {\n	public function createConcreteObject() {\n		$concreteObject = new ConcreteObject($this->attribute, $this->year);\n		return $concreteObject;\n	}\n}\n\\--\n\nNicméně křivka výhod při používání továrny velmi rychle překoná svým stoupáním křivku lenosti při používání operátoru new.\n\nMimochodem vzpomeňte si na \"osm návrhových přikázání\":http://www.zeminem.cz/osm-navrhovych-prikazani, kde se také říká, že máme vždy programovat vůči rozhraní, a nikdy ne vůči konkrétní implementaci, což tento návrhový vzor perfektně splňuje.'),
(11,	'Nette 2.1-dev CliRouter',	'Routování CLI((Command Line Interface)) aplikací je oblast, o které se v Nette moc nemluví. A když mluví, tak divně (nebo staře). Což na jednu stranu dává smysl, protože tato routa existuje už od roku 2009. Na druhou stranu je to zvláštní, protože je stále experimentální.\n\n> The unidirectional router for CLI.\n> \n> (experimental)\n\nDokonce se už mluvilo o tom, že se zruší. No snad se to nestane...\n\nProč o tom mluvím? Rád bych ukázal, jak se dá v nastávající verzi Nette tato routa použít. V nové verzi Nette se již routy nepíší do bootsrap.php jak tomu bylo (alespoň myslím) dříve. Tentokrát je v adresářové struktuře soubor router/**RouterFactory.php**, který se právě o routování postará. Tento soubor může vypadat například takto:\n\n/--code php\n<?php\n\nnamespace App;\n\nuse Nette,\n	Nette\\Application\\Routers\\RouteList,\n	Nette\\Application\\Routers\\Route,\n	Nette\\Application\\Routers\\CliRouter;\n\n/**\n * Router factory.\n */\nclass RouterFactory {\n\n	private $container;\n\n	public function __construct(Nette\\DI\\Container $container) {\n		$this->container = $container;\n	}\n\n	/**\n	 * @return \\Nette\\Application\\IRouter\n	 */\n	public function createRouter() {\n		$router = new RouteList();\n		if ($this->container->parameters[\'consoleMode\']) {\n			$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\n		} else {\n			$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\n			$router[] = new Route(\'user/<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'User\',\n				\'presenter\' => \'Board\',\n				\'action\' => \'default\',\n			));\n			$router[] = new Route(\'<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'Front\',\n				\'presenter\' => \'Homepage\',\n				\'action\' => \'default\',\n			));\n		}\n		return $router;\n	}\n\n}\n\\--\n\nToto je reálná funkční ukázka (ze které jsem něco nepodstatného umazal). Jak je vidět, tak aplikaci mám rozdělenou na moduly, takže defaultní routa ukazuje do modulu Front, pak je k dispozici User modul, link na RSS a konečně CliRouter, který se naroutuje pouze v případě, že běží aplikace v konzolovém módu (CLI).\n\nPokud se teď přesunu k presenterové části modulu Cli, mohu zde umístit dvě třídy. Klasický BasePresenter, který bude pro jistotu kontrolovat, jestli se opravdu jedná o consoleMode například takto:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nabstract class BasePresenter extends Nette\\Application\\UI\\Presenter {\n\n	public function startup() {\n		parent::startup();\n		if (!$this->context->parameters[\'consoleMode\']) {\n			throw new Nette\\Security\\AuthenticationException;\n		}\n	}\n\n}\n\\--\n\nNo a pak už stačí jen CliPresenter, který bude dědit od BasePresenteru, takže vždy dojde ke kontrole. Zde stačí metoda action*(), která se spustí podle naroutování. V mém případě se tedy jedná o actionCron():\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nclass CliPresenter extends BasePresenter {\n\n	public function actionCron() {\n		echo \'FUNGUJU!\';\n		$this->terminate();\n	}\n\n}\n\\--\n\nA teď to nejdůležitější! Aplikace se spustí pomocí terminálu jednoduchým příkazem \"<code>php index.php</code>\". Samozřejmě je nutné ukázat na index Nette aplikace. No a samozřejmě se mohu odkázat i na jinou část aplikace dopsání parametru. Pokud bych chtěl podle výše uvedených souborů přejít na hlavní stránku, stačí napsat pouze \"<code>php index.php Fron:Homepage:default</code>\".'),
(43,	'Testovací titulek',	'Tělo s použitím **texy**.'),
(44,	'Portál ZČU dočasně mimo provoz',	'Zvolit správný titulek pro webovou stránku je naprosto klíčové.\nMnozí programátoři si to neuvědomují a ti ostatní chybují.\nTitulek je jedna z nejdůležitějších věcí, podle které se\nlidé rozhodují jestli na web vstoupit, nebo ne. Proto je třeba mít\n<code>title</code> tag na každé stránce jiný a je potřeba myslet\ni na stránky, které se zase až tak často nezobrazují.\nJe totiž docela smůla, když vás google bot indexuje během profylaxe\nserverů:\n\n[* http://www.zeminem.cz/img/pictures/portal.png *]\n\nWeb má poté odpuzující titulek, i když už dávno funguje.\nNutno však říct, že je to občas problém ohlídat.\nTak alespoň to pobaví... (-:'),
(45,	'Testování presenterů v Nette',	'Tak toto je přesně to téma o kterém se naustále mluví, ale tím to z velké části končí.\nNemá smysl zabývat se tím, jestli testovat, nebo ne. Na to už si každý přijde sám.\nV následujících odstavcích bych rád předvedl myšlenku jak si\nušetřit pár řádek kódu při testech (\\Nette\\Tester).\n\nNezbytná teorie\n===============\n\nPro testování presenterů je zapotřebí získat továrnu na presentery PresenterFactory\na následně daný presenter vyrobit. Například takto:\n\n/--code php\n$presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\n$this->presenter = $presenterFactory->createPresenter(\'Front:Homepage\');\n\\--\n\nK tomu je zapotřebí \\Nette\\DI\\Container, který získáme například v konstruktoru, nebo\npomocí inject anotace.\n\nNásledně je třeba vytvořit požadavek, ten spustit a testovat výslednou odpověď:\n\n/--code php\n$request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\n$response = $this->presenter->run($request);\n\\--\n\nPrávě nad vrácenou odpovědí lze spustit testovací sadu, která bude testovat, \nzda byla například získána textová odpověď a tedy jestli se jedná o šablonu:\n\n/--code php\n\\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\n\\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\n\\--\n\nJe také vhodné otestovat samotný HTML kód. Již mě to párkrát upozornilo na\nnevalidní kód, což se může stát, pokud se šablona skládá z hodně include částí.\nNevalidní ve smyslu například dvojité HTML ukončovací značky:\n\n/--code php\n$html = (string)$response->getSource();\n$dom = \\Tester\\DomQuery::fromHtml($html);\n\\Tester\\Assert::true($dom->has(\'title\'));\n\\--\n\nPsaní, psaní, psaní...\n======================\n\nPředchozí teorie je zapotřebí opakovat pro každý presenter. Už jen proto, že je třeba\nvytvořit pokaždé nový požadavek. Nicméně je jasné, že to po otestování FrontModule\nzačne být lehce kopírovací nuda.\n\nJe tedy vhodné vytvořit si třídu, která ušetří spoustu řádek.\nMůj první návrh vypadá přibližně takto:\n\n/--code php\n<?php\n\nnamespace Test;\n\nclass Presenter extends \\Nette\\Object {\n\n        private $container;\n        private $presenter;\n        private $presName;\n\n        public function __construct(\\Nette\\DI\\Container $container) {\n                $this->container = $container;\n        }\n\n        /**\n         * @param $presName string Fully qualified presenter name.\n         */\n        public function init($presName) {\n                $presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\n                $this->presenter = $presenterFactory->createPresenter($presName);\n                $this->presenter->autoCanonicalize = FALSE;\n                $this->presName = $presName;\n        }\n\n        public function test($action, $method = \'GET\', $params = array(), $post = array()) {\n                $params[\'action\'] = $action;\n                $request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\n                $response = $this->presenter->run($request);\n                return $response;\n        }\n\n        public function testAction($action, $method = \'GET\', $params = array(), $post = array()) {\n                $response = $this->test($action, $method, $params, $post);\n\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\n                \\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\n\n                $html = (string)$response->getSource();\n                $dom = \\Tester\\DomQuery::fromHtml($html);\n                \\Tester\\Assert::true($dom->has(\'title\'));\n\n                return $response;\n        }\n\n        public function testForm($action, $method = \'POST\', $post = array()) {\n                $response = $this->test($action, $method, $post);\n\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\RedirectResponse);\n\n                return $response;\n        }\n\n}\n\\--\n\nTestování samotných presenterů je pak již otázkou několika málo řádek:\n\n/--code php\n<?php\n\nnamespace Test;\n\n$container = require __DIR__ . \'/../bootstrap.php\';\n\nclass HomepagePresenterTest extends \\Tester\\TestCase {\n\n        public function __construct(\\Nette\\DI\\Container $container) {\n                $this->tester = new \\Test\\Presenter($container);\n        }\n\n        public function setUp() {\n                $this->tester->init(\'Front:Homepage\');\n        }\n\n        public function testRenderDefault() {\n                $this->tester->testAction(\'default\');\n        }\n\n}\n\nid(new HomepagePresenterTest($container))->run();\n\\--\n\nTakto chápu testování presenterů v Nette já. Dále budu směrovat testy tak, abych nemusel psát téměř nic\na měl jsem otestováno téměř všechno. Myslím si, že toto je jediná cesta jak se přinutit k testování.\nNelze se již vymlouvat na to, že je to spousta psaní navíc. Není.'),
(46,	'CRON validátor',	'A jak už to tak bývá, tak opět ohnutý pro Nette. Tentokráte inspirovaný řešením ISPConfigu.\n\nMůžeš tohle, nesmíš tamto\n=========================\n\nSamotný CRON zápis je velmi rozmanitý a proto se omezím pouze na základní požadavky:\n\n1)  obecně jsou povolené znaky <code>0-9</code>, <code>čárka</code>, <code>*</code>, <code>-</code>, <code>/</code>\n2)  <code>čárka</code>, <code>-</code> a <code>/</code> nesmí být nikdy vedle sebe\n3)  <code>x</code>, <code>x-y</code>, <code>x/y</code>, <code>x-y/z</code>, <code>*/x</code>, kde x,y,z jsou čísla z povolených časových rozsahů\n4)  povolený rozsah pro minuty: <strong>0-59</strong>\n5)  povolený rozsah pro hodiny: <strong>0-23</strong>\n6)  povolený rozsah pro dny měsíce: <strong>1-31</strong>\n7)  povolený rozsah pro měsíce: <strong>1-12</strong>\n8)  povolený rozsah pro dny v týdnu: <strong>0-6</strong>\n\nTo je myslím slušný výčet pravidel pro zvalidování jednoho příkazu.\nÚkolem tohoto článku není ukázat jak tvořit a zpracovávat formulář, ale bude vhodné\numístit sem celý kód alespoň vytvoření:\n\n/--code php\n/**\n  * @return Nette\\Application\\UI\\Form\n  */\nprotected function createComponentAddCron() {\n	$form = new Nette\\Application\\UI\\Form;\n	$form->addProtection();\n	$form->addText(\'minutes\', \'Minuty:\')\n		->addRule(\\Fresh\\ValidateCron::MINUTES, \'Nevalidní CRON zápis - minuty.\');\n	$form->addText(\'hours\', \'Hodiny:\')\n		->addRule(\\Fresh\\ValidateCron::HOURS, \'Nevalidní CRON zápis - hodiny.\');\n	$form->addText(\'mdays\', \'Dny měsíce:\')\n		->addRule(\\Fresh\\ValidateCron::MDAYS, \'Nevalidní CRON zápis - mdays.\');\n	$form->addText(\'months\', \'Měsíce:\')\n		->addRule(\\Fresh\\ValidateCron::MONTHS, \'Nevalidní CRON zápis - měsíce.\');\n	$form->addText(\'wdays\', \'Dny v týdnu:\')\n		->addRule(\\Fresh\\ValidateCron::WDAYS, \'Nevalidní CRON zápis - wdays.\');\n	$form->addText(\'command\', \'Příkaz:\')\n		->setRequired(\'Vyplňte prosím příkaz, který bude CRON spouštět.\');\n	$form->addSubmit(\'save\', \'Přidat nový CRON\');\n	$form->onSuccess[] = $this->addCronSucceeded;\n	return $form;\n}\n\\--\n\nA rovnou bez hloupých povídání celý validátor:\n\n/--code php\n<?php\n\nnamespace Fresh;\n\n/**\n * Class ValidateCron - inspired by ISPConfig\n * @package Fresh\n */\nclass ValidateCron extends \\Nette\\Object {\n\n        const MINUTES = \'\\Fresh\\ValidateCron::validateMinutes\';\n        const HOURS = \'\\Fresh\\ValidateCron::validateHours\';\n        const MDAYS = \'\\Fresh\\ValidateCron::validateMdays\';\n        const MONTHS = \'\\Fresh\\ValidateCron::validateMonths\';\n        const WDAYS = \'\\Fresh\\ValidateCron::validateWdays\';\n\n        public static function validateMinutes(\\Nette\\Forms\\IControl $control) {\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 59);\n        }\n\n        public static function validateHours(\\Nette\\Forms\\IControl $control) {\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 23);\n        }\n\n        public static function validateMdays(\\Nette\\Forms\\IControl $control) {\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 31);\n        }\n\n        public static function validateMonths(\\Nette\\Forms\\IControl $control) {\n                if($control->getValue() != \'@reboot\') { // allow value @reboot in month field\n                        return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 12);\n                } else {\n                        return TRUE;\n                }\n        }\n\n        public static function validateWdays(\\Nette\\Forms\\IControl $control) {\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 6);\n        }\n\n        private static function validateTimeFormat($value, $min_entry = 0, $max_entry = 0) {\n                if (preg_match(\"\'^[0-9\\-\\,\\/\\*]+$\'\", $value) == false) { // allowed characters are 0-9, comma, *, -, /\n                        return FALSE;\n                } elseif (preg_match(\"\'[\\-\\,\\/][\\-\\,\\/]\'\", $value) == true) { // comma, - and / never stand together\n                        return FALSE;\n                }\n                $time_list = explode(\",\", $value);\n                foreach ($time_list as $entry) {\n                        // possible value combinations:\n                        // x               =>      ^(\\d+)$\n                        // x-y             =>      ^(\\d+)\\-(\\d+)$\n                        // x/y             =>      ^(\\d+)\\/([1-9]\\d*)$\n                        // x-y/z           =>      ^(\\d+)\\-(\\d+)\\/([1-9]\\d*)$\n                        // */x             =>      ^\\*\\/([1-9]\\d*)$\n                        // combined regex  =>      ^(\\d+|\\*)(\\-(\\d+))?(\\/([1-9]\\d*))?$\n                        if (preg_match(\"\'^(((\\d+)(\\-(\\d+))?)|\\*)(\\/([1-9]\\d*))?$\'\", $entry, $matches) == false) {\n                                return FALSE;\n                        }\n                        // matches contains:\n                        // 1       =>      * or value or x-y range\n                        // 2       =>      unused\n                        // 3       =>      value if [1] != *\n                        // 4       =>      empty if no range was used\n                        // 5       =>      2nd value of range if [1] != * and range was used\n                        // 6       =>      empty if step was not used\n                        // 7       =>      step\n                        if ($matches[1] == \"*\") {\n                                // not to check\n                        } else {\n                                if ($matches[3] < $min_entry || $matches[3] > $max_entry) { // check if value is in allowed range\n                                        return FALSE;\n                                } elseif (isset($matches[4]) && ($matches[5] < $min_entry || $matches[5] > $max_entry || $matches[5] <= $matches[3])) {\n                                        // check if value is in allowed range and not less or equal to first value\n                                        return FALSE;\n                                }\n                        }\n                        if (isset($matches[6]) && ($matches[7] < 2 || $matches[7] > $max_entry - 1)) { // check if step value is valid\n                                return FALSE;\n                        }\n                } // end foreach entry loop\n                return TRUE;\n        }\n\n}\n\\--\n\nValidátorem navrácené errory lze vykreslit například takto ručně (nově v DEV Nette):\n\n/--code html\n{form $form}\n\n<ul class=\"error\" n:if=\"$form->allErrors\">\n        <li n:foreach=\"$form->allErrors as $error\">{$error}</li>\n</ul>\n\n...\n\n{/form}\n\\--'),
(47,	'Třída pro připojení k FIO API',	'Další užitečný úryvek, který je škoda nechat ležet v Git repozitářích.\nA opět uzpůsobený pro používání s Nette FW.\n\nNedávno jsem psal o tom, jak používat CLI router v Nette (http://www.zeminem.cz/nette-2-1-dev-clirouter).\nPrávě pomocí tohoto routeru je vhodné kontrolovat bankovní výpisy - například pomocí cronu:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\nuse Nette\\Diagnostics\\Debugger;\n\n/**\n * Class CliPresenter\n * @package App\\CliModule\n */\nclass CliPresenter extends BasePresenter {\n\n        /** @var \\Fio @inject */\n        public $fio;\n        ...\n\n        public function actionCron() {\n                $this->checkFio(); // FIO vs. nezaplacené objednávky\n                ...\n                $this->terminate();\n        }\n\n        /**\n         * Zkontroluje bankovní účet, porovná s databází a zaplacené objednávky změní na status PAID.\n         */\n        private function checkFio() {\n                try {\n                        $transactions = $this->fio->transactions();\n                        $unpaid = $this->orders->selectUnpaidOrders(); //získání nezaplacených objednávek\n                        //array_intersect() - zde samotné zpracování\n                        ...\n                } catch (\\Exception $exc) {\n                        Debugger::log($exc->getMessage() . \' FILE: \' . $exc->getFile() . \' on line: \' . $exc->getLine(), Debugger::WARNING);\n                        echo $exc->getMessage() . EOL;\n                }\n        }\n}\n\\--\n\nK tomu se hodí právě následující třída:\n\n/--code php\n<?php\n\n/**\n * Class Fio\n */\nclass Fio extends \\Nette\\Object {\n\n        private $token;\n        private $rest_url = \'https://www.fio.cz/ib_api/rest/\';\n\n        /**\n         * @param string $token SECURE\n         */\n        public function __construct($token) {\n                $this->token = $token;\n        }\n\n        /**\n         * Pohyby na účtu za určené období.\n         * JSON only!\n         * @param string $from\n         * @param string $to\n         */\n        public function transactions($from = \'-1 month\', $to = \'now\') {\n                $from = \\Nette\\DateTime::from($from)->format(\'Y-m-d\');\n                $to = \\Nette\\DateTime::from($to)->format(\'Y-m-d\');\n                $url = $this->rest_url . \'periods/\' . $this->token . \'/\' . $from . \'/\' . $to . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Oficiální výpisy pohybů z účtu.\n         * JSON only!\n         * @param $id\n         * @param null $year\n         * @return array|mixed\n         */\n        public function transactionsByID($id, $year = NULL) {\n                if ($year === NULL) {\n                        $year = date(\'Y\');\n                }\n                $url = $this->rest_url . \'by-id/\' . $this->token . \'/\' . $year . \'/\' . $id . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Pohyby na účtu od posledního stažení.\n         * JSON only!\n         * @return array|mixed\n         */\n        public function transactionsLast() {\n                $url = $this->rest_url . \'last\' . $this->token . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * @param $url\n         * @return mixed\n         * @throws \\Exception\n         */\n        private function download($url) {\n                if (!extension_loaded(\'curl\')) {\n                        throw new \\Exception(\'Curl extension, does\\\'t loaded.\');\n                }\n                $curl = curl_init();\n                curl_setopt($curl, CURLOPT_URL, $url);\n                curl_setopt($curl, CURLOPT_HEADER, FALSE);\n                curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);\n                $result = curl_exec($curl);\n                return $result;\n                //return file_get_contents($url); //ALTERNATIVE\n        }\n\n        /**\n         * @param $data\n         * @return array|mixed\n         */\n        private function parseJSON($data) {\n                $json = json_decode($data);\n                if($json === NULL) {\n                        //Moc ryhlé požadavky na Fio API\n                        throw new \\Exception(\'Fio API overheated. Please wait...\');\n                        //Když se posílá stále moc požadavků, tak se to z Exception nikdy nevyhrabe. Musí se opravdu počkat.\n                }\n                if(!$json->accountStatement->transactionList) {\n                        return $json; // There are no transactions (header only)\n                }\n                $payments = array();\n                foreach ($json->accountStatement->transactionList->transaction as $row) {\n                        $out = array();\n                        foreach ($row as $column) {\n                                if ($column) {\n                                        $out[$column->id] = $column->value; //v $column->name je název položky\n                                        /*\n                                         * 0  - Datum\n                                         * 1  - Částka (!)\n                                         * 5  - Variabilní symbol (!)\n                                         * 14 - Měna (!)\n                                         * Hodnoty (!) se musí použít ke kontrole správnosti...\n                                         */\n                                }\n                        }\n                        array_push($payments, $out);\n                }\n                return $payments;\n        }\n\n}\n\\--\n\nS tím, že je zapotřebí předat FIO klíč z neonu. FIO třída se automaticky injectuje, tzn. že i konstruktor\ntéto třídy bude doplněn automaticky. Je jen zapotřebí přidat do neonu onu konfiguraci:\n\n/--code neon\nparameters:\n	fio_token: \'\' #token pro přístup do FIO banky\n    \n...\n\nservices:\n	- Fresh\\Fio(token: %fio_token%)\n    \n...\n\\--\n\nBylo by vhodné upozornit na fakt, že se jedná pouze o read-only přístup, tzn. že neexistují žádné funkce\npro zápis (ačkoliv existuje něco jako datumová zarážka). Díky tomu je možné použít takovéto nízkoúrovňové\nzabezpečení pomocí jednoho tokenu.'),
(49,	'Using fulltext searching with InnoDB',	'Sometimes is quite useful to use InnoDB engine. \nUnfortunately InnoDB is good for tables with foreign keys, but useless for fulltext search. \nYou can\'t create fulltext index on InnoDB tables, but you can create this index on MyISAM tables. \nUnfortunately you can\'t create foreign keys on MyISAM. It\'s starting to be quite embarassing. \nLet me show you how to search via fulltext on InnoDB tables.\n\nIn fact it\'s not possible to use fulltext index on InnoDB tables, \nbut there is possible workaround. At first you need a classic InnoDB structure. \nFor example database of  blog:\n\n/--code sql\nSET NAMES utf8;\nSET foreign_key_checks = 0;\nSET time_zone = \'SYSTEM\';\nSET sql_mode = \'NO_AUTO_VALUE_ON_ZERO\';\n\nDROP TABLE IF EXISTS `posts`;\nCREATE TABLE `posts` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `title` text NOT NULL,\n  `body` text NOT NULL,\n  `date` datetime NOT NULL,\n  `release_date` datetime NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `title_3` (`title`(200))\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nDROP TABLE IF EXISTS `tags`;\nCREATE TABLE `tags` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(50) NOT NULL,\n  `color` varchar(6) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nDROP TABLE IF EXISTS `posts_tags`;\nCREATE TABLE `posts_tags` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `tag_id` int(11) NOT NULL,\n  `post_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `tag_id` (`tag_id`),\n  KEY `post_id` (`post_id`),\n  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),\n  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\\--\n\nNow we have pretty simple database structure with InnoDB tables with foreign keys. \nIt would be nice to be able search on database table **posts** using fulltext search:\n\n/--code sql\nSELECT *\nFROM posts\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE);\n\\--\n\nBut it is not possible. It returns something like:\n>   Error in query: The used table type doesn\'t support FULLTEXT indexes\n\nLet\'s create another one table with triggers and fulltext indexes. \nWe need to create mirror table. For example:\n\n/--code sql\nDROP TABLE IF EXISTS `mirror_posts`;\nCREATE TABLE `mirror_posts` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `title` text NOT NULL,\n  `body` text NOT NULL,\n  PRIMARY KEY (`id`),\n  FULLTEXT KEY `title_body` (`title`,`body`),\n  FULLTEXT KEY `title` (`title`),\n  FULLTEXT KEY `body` (`body`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\n\\--\n\nAnd than we need to create triggers:\n\n/--code sql\nDELIMITER ;;\n\nCREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW\nINSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body);;\n\nCREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW\nUPDATE mirror_posts SET\n    id = NEW.id,\n    title = NEW.title,\n    body = NEW.body\nWHERE id = OLD.id;;\n\nCREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW\nDELETE FROM mirror_posts WHERE id = OLD.id;;\n\\--\n\nIt means, that we copy all of events and data from table **posts** to the table **mirror_posts**.\nFinally we can use more complex fulltext search feature:\n\n/--code sql\nSELECT *\nFROM mirror_posts\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE)\nORDER BY 5 * MATCH(title) AGAINST (\'something\') + MATCH(body) AGAINST (\'something\') DESC;\n\\--\n\nAs I said, this is just workaround, not solution. \nSometimes it\'s bad practice, because you need copy of indexed columns. \nBut it works. And for small blogs it\'s sufficient.');

DROP TABLE IF EXISTS `posts`;
CREATE TABLE `posts` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` text NOT NULL,
  `body` text NOT NULL,
  `date` datetime NOT NULL,
  `release_date` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `title_3` (`title`(200))
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `posts` (`id`, `title`, `body`, `date`, `release_date`) VALUES
(2,	'Asymetrická šifra s veřejným klíčem',	'O veřejné distribuci klíčů jsem již dříve psal. Pojďme se však podívat nejen na samotnou distribuci, ale i na myšlenku asymetrického šifrování. Prvně je však třeba vysvětlit několik důležitých věcí. Začněme tím, co vlastně znamená asymetrická šifra. Před myšlenkou asymetrického šifrování, jejíž autorem je Whitfield Diffie, se používalo výhradně šifrování symetrické, což znamená, že proces dešifrování zakódované zprávy je přesně opačný k procesu šifrování. Asymetrické šifrování však zavádí myšlenku použití jiného klíče na šifrování a jiného na dešifrování.\r\n\r\nJak to vyřešit? Jak je možné použít jiný klíč na šifrování a jiný na dešifrování? Již existoval koncept, který umožňoval výměnu  klíčů veřejně (a bezpečně). Stále byl však na principu synchronní komunikace odesílatele a příjemce, což nebylo optimální řešení a proto byl vymyšlen způsob jak tento problém obejít. Myšlenka byla jednoduchá. Příjemce musí vytvořit veřejný klíč, který následně zveřejní tak, aby byl veřejný opravdu pro všechny. V tomto případě je jasné, že by to nemělo smysl, pokud by se nepoužívala jednosměrná funkce šifrování, což je další pravidlo. A zároveň opět onen příjemce musí mít svůj tajný klíč, který dokáže informaci zašifrovanou veřejným klíčem dešifrovat. Z toho je patrná ta asymetričnost šifry. Nepoužívám stejný klíč na zašifrování a dešifrování jako u jiných šifer.\r\n\r\nTomuto systému se říká RSA (Ronald Riverst, Adi Shamir, Leonard Adleman). Pojďme se na něj teď podívat matematicky, protože teorie je moc obecná (a matematika zase složitá). Odesílatel zprávy si musí zvolit dvě velmi velká prvočísla (A, B). Tyto prvočísla mezi sebou vynásobí a dostane další ještě větší číslo (AB). Násobení je zcela triviální jednosměrná operace a systém RSA si zakládá na tom, že faktorizovat velké číslo je v reálním čase prakticky nemožné. Dále si odesílatel zvolí číslo C a to uveřejní společně s číslem AB. Toto jsou informace, které má každý k dispozici. Pro šifrování je nutné zprávu převést na číslo M (například binárně). Toto číslo se poté dosadí podle vzorce \"šifra\"= M^C (mod AB). Zpětně se pak informace dá velmi snadno dostat obráceným postupem se znalostí onoho součinu prvočísel zvolených na začátku. Bez znalosti těchto prvočísel je dešifrování téměř nemožné, což však také není úplně pravda viz poslední odstavec.\r\n\r\nJe zřejmé, že úspěch šifry spočívá ve zvolení dostatečně velkých prvočísel a mocnitele C, který by vzhledem k prvočíslům neměl mít žádného společného dělitele. Resp. přesněji čísla C a (A-1) * (B-1). Při představení RSA byl pro jeho reprezentaci uveřejněn zašifrovaný text s veřejným klíčem. Soutěžním úkolem bylo faktorizovat veřejný klíč na dvě složky a poté zprávu dešifrovat. Faktorizace trvala ve výsledku celkem 17 let, kdy tým 600 dobrovolníků oznámil 26. dubna 1994 činitele veřejného klíče. A jaký že byl ten klíč?\r\n\r\n/--code\r\nN = 114 381 625 757 888 867 669 235 779 976 146 612 010 218 296 721 242 362 562 561 842 935 706 935 245 733 897 830 597 123 563 958 705 058 989 075 147 599 290 026 879 543 541\r\n\\--\r\n\r\nDílčí prvočísla si nechám jako tajemství? (-:',	'2012-09-07 22:29:58',	'2012-09-07 22:29:58'),
(3,	'Lovec matematik',	'Znáte následující hádanku?\r\n\r\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Tam zastřelil medvěda. Jakou měl medvěd barvu?\r\n\r\nŘešení je více než jednoduché. Stačí si představit sférický trojúhelník vycházející ze severního pólu, který má všechny strany dlouhé 10 km (tedy každý úhel má 90°). Vzhledem k severnímu pólu je zřejmé, že medvěd musí být bílý. Existuje však ještě jiné řešení této hádanky čistě z geometrického (matematického chcete-li) hlediska? Vypusťme tedy medvěda a zamysleme se nad následující hádankou:\r\n\r\nLovec ráno vyrazí na lov. Nejprve jde 10 km na jih, poté 10 km na západ a nakonec 10 km na sever. V cíli své cesty zjišťuje, že se vrátil na stejné místo, ze kterého ráno vyšel. Měl však smůlu a tak nic neulovil.\r\n\r\nJedno řešení už známe. Zamyslete se ještě jednou nad druhým řešením. Přesuňme se na jižní polokouli do libovolného bodu vzdáleného 11 591,55 m od jižního pólu. Pokud šel lovec nejprve 10 km na jih, dorazil do druhého bodu vzdáleného 1591,55 m od jižního pólu. Ze základní matematiky jistě všichni znají vzorec pro obvod kruhu O = 2&pi;r. Dosazením do vzorce zjistíme velmi zajímavou skutečnost. Obvod kruhu, tedy délka cesty na západ je dlouhá přibližně přesně 10 km. Lovec se tedy dostane na stejný bod vzdálený 1591,55 m od pólu a cestou na sever dojde do úplného začátku stejně tak jako tomu bylo při využití sférického trojúhelníku na opačné straně planety.\r\n\r\nPokud nebyl lovec matematik a neuvědomoval si tuto skutečnost, muselo být poměrně vyčerpávající dorazit po třiceti kilometrech do stejného místa...',	'2012-09-15 21:50:26',	'2012-09-15 21:50:26'),
(4,	'Tabulkový masakr',	'Určitě znáte HTML a tím pádem znáte i tabulky. Pro jistotu připomenutí.\nTabulka se v HTML tvoří párovým tagem <code>&lt;table&gt;&lt;/table&gt;</code>, její řádky jsou <code>&lt;tr&gt;&lt;/tr&gt;</code> a buňky <code>&lt;td&gt;&lt;/td&gt;</code>. Buňky mají volitelné atributy <code>rowspan</code> a <code>colspan</code>. Tyto atributy určují, kolik bude buňka zabírat místa v řádce, resp. ve sloupci. Tyto znalosti stačí k pochopení pojmu \"tabulkový paradox\".\n\nPodívejte se na \"první ukázku\":http://www.zeminem.cz/demo/tabulkovy-masakr1, kde je vidět co se stane, když roztáhneme buňku **A2** na tři řádky a zároveň roztáhneme buňku **B1** na tři sloupce podle následujícího kódu:\n/--code html\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n	<tr>\n		<td width=\"33%\">A1</td>\n		<td width=\"33%\" rowspan=\"4\">A2</td>\n		<td width=\"33%\">A3</td>\n	</tr>\n	<tr>\n		<td colspan=\"3\">B1</td>\n	</tr>\n	<tr>\n		<td>C1</td>\n		<td>C3</td>\n	</tr>\n	<tr>\n		<td>D1</td>\n		<td>D3</td>\n	</tr>\n</table>\n\\--\nTam kde by měla být buňka **B2** vzniká krásné okénko do Narnie, které je společné jako pro druhý sloupec, tak pro druhý řádek.\n\nDůsledkem neopatrného zacházení se spojováním sloupců může být výsledek viditelný ve \"druhé ukázce\":http://www.zeminem.cz/demo/tabulkovy-masakr2. Za domácí úkol se pokuste napsat alespoň jednu tabulku bez nahlédnutí do zdrojového kódu... :-)\n\nA poslední perlička vyvracející tvrzení, že párový element <code>&lt;tr&gt;&lt;/tr&gt;</code> vytváří v tabulce novou řádku. Podívejte se na následující kód. Hádám, že už je vám jasné co se stane.\n/--code html\n<table border=\"1\" cellpadding=\"6\" cellspacing=\"2\" width=\"400\">\n	<tr><td width=\"33%\" rowspan=\"4\">Řádka_1</td></tr>\n	<tr><td width=\"33%\" rowspan=\"3\">Řádka_1</td></tr>\n	<tr><td width=\"33%\" rowspan=\"2\">Řádka_1</td></tr>\n	<tr><td width=\"33%\" rowspan=\"1\">Řádka_1</td></tr>\n</table>\n\\--\nVýsledek je vidět ve \"třetí ukázce\":http://www.zeminem.cz/demo/tabulkovy-masakr3.\n\nVyzkoušejte, že se tabulkový paradox vykresluje ve všech prohlížečích stejně. Mám to tedy chápat tak, že tolik oblíbený Chrome je stejný shit jako IE? Kdepak... Jedná se opravdu o paradox, který by sice měl (prapodivné) řešení((výsledek potlačující paradox, vyvolávající další spory)), ale pak by byl porušen význam některých atributů buňek tabulky.',	'2012-10-06 22:58:12',	'0000-00-00 00:00:00'),
(6,	'Výpočet mediánu',	'Zadání\n======\n\nNajděte v dostupné literatuře nebo vymyslete co nejlepší algoritmus pro výpočet mediánu.\nNezapomeňte na citaci zdrojů. Kritéria kvality v sestupném pořadí jsou: výpočetní složitost, \njednoduchost a implementační nenáročnost, paměťová spotřeba.\n\nDefinice\n========\n\nMedián je hodnota, která dělí seřazenou posloupnost na dvě stejně velké (co se množství týče)\nčásti. Důležitou vlastností mediánu je skutečnost, že není ovlivněn žádnou extrémní hodnotou,\njako je tomu například u průměru.\n\nAnalýza problému\n================\n\nExistuje několik způsobů jak daný problém vyřešit. První řešení bude velmi přímočaré. Jedná se\ntotiž o způsob, který zřejmě napadne každého jako první.\n\nPřímočaré řešení\n----------------\n\nToto řešení vlastně ani není tak hledání mediánu jako hledání algoritmicky nejrychlejšího způsobu\njako seřadit danou posloupnost čísel, protože pokud již máme seřazenou posloupnost, stačí zvolit\nprostřední prvek a získáme požadovaný medián. Tento poslední krok můžeme přirozeně vykonat\nse složitostí O(1). Seřadit posloupnost je možné lineárně logaritmickou složitostí O(NlogN) avšak\ns dodatečnou pamětí. Dodatečné paměti je samozřejmě možné se vyhnout, například použitím\nřadicího algoritmu Quicksort, vystavujeme se však nebezpečí kvadratické složitosti v nejhorším\npřípadě.\n\nPři zpětném pohledu je jasné, že nejvíce času strávíme řazením posloupnosti. Přitom řazení\nnebylo v zadání. Je to opravdu nutné? Následující algoritmy uvažují vstupní neseřazenou posloupnost\nstejně jako přímočaré řešení, ale nebudou vynakládat všechen svůj drahocený čas k\nřazení.\n\nAlgoritmus FIND\n---------------\n\nMetoda FIND je mnohem promyšlenější. Využívá techniky \"rozděl a panuj\", což je samo o sobě\nvelmi silná zbraň. FIND se chová velmi podobně jako již zmíněný Quicksort (oba algoritmy vymyslel\nTony Hoare) s tím, že hledá k-té nejmenší číslo, což je pouze zobecnění problému hledání\nmediánu.\n\nPři hledání postupujeme tak, že neseřazenou posloupnost projíždíme zleva, dokud nenalezneme\nprvek, který je větší (nebo roven) než námi zvolený pivot. Poté projíždíme posloupnost\nzprava, dokud nenarazíme na prvek, který je menší (nebo roven) pivotu. V tuto chvíli máme k\ndispozici dva prvky, a oba jsou na špatné straně, takže je prohodíme. V procesu zkoumání výměn\npokračujeme tak dlouho, dokud se nestřetneme. Tím je zajištěno, že jsou menší prvky než pivot\numístěny na levé straně a prvky větší než pivot zase na pravé.\n\nTím však ještě není medián určen, protože pivot byl zvolen (například) náhodně. Můžou\ntotiž nastat tři případy. V nejideálnější situaci je opravdu pivot mediánem a celý proces hledání\nmůžeme úspěšně ukončit. Může se však stát, že pivot nebude uprostřed posloupnosti, tedy byl\nzvolen nešťastně a není mediánem. V tom případě musíme hledat (např. rekurzivně) medián v\nhorní, popř. dolní části posloupnosti v závislosti na umístění aktuálního pivota. Jinak řečeno pokud\nbyl pivot moc malý, upravíme spodní mez posloupnosti. Pokud byl pivot naopak velký,\nupravíme horní mez posloupnosti a cel ý postup opakujeme. Pokud je pivot \"tak akorát\", pak je\nnaším mediánem.\n\nOčekávaný čas metody FIND je 4n, je nutné však připomenout, že je celé hledání založeno na\nQuicksortu, takže může složitost klesnout do kvadratické třídy. Existuje však i lineární řešení viz\nnásledující odstavce.\n\nAlgoritmus SELECT\n-----------------\n\nSELECT je svým chováním velmi podobný metodě FIND, ale dokáže eliminovat problém se\nšpatným zvolením pivota. Postupuje se následovně. Nejdříve rozdělíme neseřazenou posloupnost\nna pět částí s tím, že jedna nemusí být úplná. Následně najdeme medián každé skupiny. Z\nnalezených mediánů najdeme jeden celkový medián. Zde se však nesmíme ukvapit a použít tento\nmedián jako výsledný. Zatím to totiž byl pouze poměrně spolehlivý odhad vhodného pivota pro\ndělení celé posloupnosti.\n\nOpět mohou nastat tři příklady tzn. pivot je rovnou mediánem, pivot je větší, nebo je pivot\nmenší než medián. Při neshodě pivota s mediánem voláme SELECT rekurzivně do té doby,\nnež dostaneme požadovaný prvek. Postup hledání se může zdát dost zamotaný a rekurze na\npřehlednosti nepřidává, nicméně tento algoritmus má složitost O(n).\n\nSrovnání zmíněných algoritmů\n============================\n\nHledání mediánu pomocí přímočaré metody vede k seřazení posloupnosti (což nebylo zadáno).\nKromě toho získáme nejlepší složitost O(NlogN), což nemusí být úplně špatné vzhledem k nejhor\nší složitosti Quicksortu O(n^2), ale spotřebujeme více paměti. Oproti tomu algoritmus FIND\nnezabere více paměti než je nutné, jeho složitost však může být také kvadratická. Jednoznačně\nnejlepší řešení se zdá být metoda vyhledávání SELECT, která nejenže nespotřebuje dodatečnou\npaměť, ale navíc si udržuje lineární složitost což je alespoň podle běžně dostupné literatury\nnejlepší možné řešení.\n\nZávěr\n=====\n\nNezáleží-li nám na složitosti, nebo paměťové náročnosti, zvolíme přímočarou metodu hledání\nmediánu, která je nejjednodužší na implementaci a pochopení. V opačném případě zvolíme algoritmus\nSELECT, který je sice složitý, ale má vynikající výsledky.',	'2012-11-23 22:43:39',	'0000-00-00 00:00:00'),
(7,	'Osm návrhových přikázání',	'Právě mám rozečtenou knihu, která popisuje návrhové vzory v PHP. Mimo jiné autor popisuje pravidla při návrhu softwaru, která jsou prokládána velkým množstvím ukázek a vysvětlivek. Celkem je na třiceti stranách knihy (kde je rozebírán návrh) schován následující seznam pravidel.\r\n\r\n1) Přístup k údajům vždy v rámci třídy zapouzdřete a poskytněte metody, pomocí nichž lze dané údaje získat.\r\n2) Svá rozhraní navrhujte tak, aby je bylo možné později rozšířit.\r\n3) V metodách tříd nezapouzdřujte jen údaje, ale také algoritmy, díky čemuž budou komplexní operace implementované centrálně na jednom místě.\r\n4) Znovupoužitelnost kódu je lepší než duplicitní kód.\r\n5) Vyvarujte se monolitickým strukturám a rozložte je na co nejmenší části, které mohou být implementované nezávisle na sobě. Pokud používáte rozsáhlé příkazy <code>if/elseif/else</code> nebo <code>switch</code>, popřemýšlejte, zda by se nedaly nahradit zaměnitelnými třídami.\r\n6) Dědění vede k neflexibilním strukturám. Na kombinaci různých funkcí používejte raději kompozice objektů.\r\n7) Vždy programujte vůči rozhraní, a nikdy ne vůči konkrétní implementaci.\r\n8) Vyhýbejte se těsným závislostem mezi jednotlivými třídami aplikace a vždy upřednostňujte volné vazby tříd.\r\n\r\nDalší seznam který všichni znají, ale málokdo ho úplně dodržuje. (-:',	'2012-12-25 23:01:14',	'2012-12-25 23:01:14'),
(9,	'Návrhový vzor Singleton',	'Návrhový vzor Singleton je velmi známý. Má za úkol zajistit, že bude z určité třídy existovat pouze jedna instance. K této instanci poskytne globální přístupový bod. Jednoduché zadání, ale samotná implementace může být v PHP zákeřná. Proč? Tak prvně záleží na tom, jak budeme u návrhu striktní.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n}\n\\--\n\nTakovouto třídu lze totiž rovnou prohlásit za návrhový vzor Singleton. Dává to smysl, protože můžeme zavolat:\n\n/--code php\n$obj1 = Object::getInstance();\n$obj2 = Object::getInstance();\n\\--\n\nTím se pokusíme vytvořit dvě instance této třídy, ve skutečnosti se však vytvoří jen jedna. Tyto objekty jsou identické, což lze dokázat jednoduchou zkouškou:\n\n/--code php\nif($obj1 === $obj2) {\n	echo \'$obj1 === $obj2\'; //TRUE\n} else {\n	echo \'$obj1 !== $obj2\';\n}\n\\--\n\nSingleton to je a nikdo nemůže říct ne. Jak jsem však již psal, záleží na tom, jak budeme u návrhu striktní, protože by to nebylo PHP, kdyby neexistovalo několik otazníků a háčků. Pravděpodobně spoustu lidí totiž napadne, že metoda <code>getInstance()</code> je sice hezká, ale vůbec ji nemusím použít. V takovém případě celý princip Singletona padá.\n\n/--code php\n$obj1 = Object::getInstance();\n$obj2 = new Object();\n\nif($obj1 === $obj2) {\n	echo \'$obj1 === $obj2\';\n} else {\n	echo \'$obj1 !== $obj2\'; //TRUE\n}\n\\--\n\nTo je jasné, zatím ve třídě neexistuje žádný mechanismus, který by zakázal používání konstruktoru. K tomu je potřeba pouze malá úprava třídy.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n	protected function __construct() {}\n}\n\\--\n\nV tento moment již nepůjde objekt vytvořit pomocí operátoru <code>new</code>. Případný pokus skončí fatální chybou. Nebylo by to však PHP, kdyby neexistovalo několik dalších otazníků a háčků. S ledovým klidem si totiž mohu první vytvořený objekt naklonovat a tím opět získám dvě nezávislé instance jedné třídy. Ale to jsem přece nechtěl!\n\n/--code php\n$obj1 = Object::getInstance();\n$obj2 = clone $obj1;\n\nif($obj1 === $obj2) {\n	echo \'$obj1 === $obj2\';\n} else {\n	echo \'$obj1 !== $obj2\'; //TRUE\n}\n\\--\n\nProti tomuto postupu se mohu bránit opět podobným způsobem jako u konstruktoru.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n	protected function __construct() {}\n	private function __clone() {}\n}\n\\--\n\nPokus o naklonování již vytvořené instance pomocí metody <code>getInstance()</code> skončí opět fatální chybou. Jenže nebylo by to PHP, kdyby... Co se stane, když vytoření objekt serializuji a pak ho zase deserializuji?\n\n/--code php\n$obj1 = Object::getInstance();\n$obj2 = unserialize(serialize($obj1));\n\nif($obj1 === $obj2) {\n	echo \'$obj1 === $obj2\';\n} else {\n	echo \'$obj1 !== $obj2\'; //TRUE\n}\n\\--\n\nTo už začíná být poněkud otravné. Ale tak dobře, i to se dá ošéfovat.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n	protected function __construct() {}\n	private function __clone() {}\n	private function __wakeup() {}\n}\n\\--\n\nToto už sice vrátí jen warning, ale víme o tom. Schválně jsem nepsal, že se to vše dá ošetřit, protože je to spíše zákaz (popř. upozornění). Je samozřejmě možné (lepší) vracet různé vyjímky atd. Stejně tak je spousta variant jak psát přítupové modifikátory k metodám. To jednoduše vše zaleží na tom, co od Singleton objektu očekáváme a kdo objekt používá, protože jak jsem již psal, úplně klidně stačí Singleton s jednou metodou <code>getInstance()</code>. Svoji funkci plní, tečka.\n\n/--code php\n<?php\nclass Object {\n	private static $instance = null;\n	public static function getInstance() {\n		if(self::$instance === null) {\n			self::$instance = new self;\n		}\n		return self::$instance;\n	}\n	protected function __construct() {}\n	public final function __clone() {\n		throw new Exception(\'Objekt nelze klonovat!\');\n	}\n	public final function __wakeup() {\n		throw new Exception(\'Objekt nelze deserializovat!\');\n	}\n}\n\\--',	'2012-12-26 20:38:01',	'0000-00-00 00:00:00'),
(10,	'Návrhový vzor Factory Method',	'Návrhový vzor Factory Method má za úkol definovat rozhraní pro vytváření objektů s tím, že vlastní tvorbu instancí přenechává potomkům. Samotný návrhový vzor tedy tvoří například tyto dvě třídy.\n\n/--code php\n<?php\nabstract class ACreator {\n	protected $attribute;\n	public function __construct($attribute) {\n		$this->attribute = $attribute;\n	}\n	abstract public function createConcreteObject();\n}\n\\--\n\n/--code php\n<?php\nclass ConcreteCreator extends ACreator {\n	public function createConcreteObject() {\n		$concreteObject = new ConcreteObject($this->attribute);\n		return $concreteObject;\n	}\n}\n\\--\n\nAby však tento vzor měl nějaký smysl, je potřeba ještě minimálně jedna třída od které se budou dělat instance (ConcreteObject).\n\n/--code php\n<?php\nclass ConcreteObject implements IObject {\n	protected $attribute;\n	public function __construct($attribute) {\n		$this->attribute = $attribute;\n	}\n	public function test() {\n		echo $this->attribute;\n	}\n}\n\\--\n\nPřípadně jeho rozhraní:\n\n/--code php\n<?php\ninterface IObject {\n	public function test();\n}\n\\--\n\nVraťme se však na začátek. Vytvářet objekty všichni umí. Slouží k tomu známý operátor <code>new</code>. Na tom není nic divného, ale jen do chvíle, než se nad tím zamyslíte. Představte si rozsáhlou aplikaci, kde na každém rohu potřebujete vytvořit instanci určitého objektu. Takže jako vždy zavoláte operátor <code>new</code> a předáte všechny potřebné argumenty. A pak se to stane. Najednou zjistíte, že nutně potřebujete přidat do konstruktoru argument/y a máte týden co dělat. K tomu se právě hodí vytvořit si továrnu na tyto instance, kdy budeme pouze volat metodu pro její vytvoření, ale to jak se vytvoří necháme na továrně. Obecně se ve světě OOP velmi často dělá, že nějakou práci prostě necháme na někom jiném. Je to funkční a pohodlný přístup. :-)\n\nPokud tedy zapomenu na to, že existují nějaké třídy Creator, tak by použití třídy ConcreteObject vypadalo asi takto:\n\n/--code php\n$instance = new ConcreteObject(\'TEST\');\n$instance->test();\n\\--\n\nPři zapojení továrny je použití zdánlivě složitější.\n\n/--code php\n$factory = new ConcreteCreator(\'TEST\');\n$instance = $factory->createConcreteObject();\n$instance->test();\n\\--\n\nPřidaná hodnota tohoto postupu je však velká. Již nejsme vázání na konkrétní implementaci objektu ConcreteObject. Vlastně nás to vůbec nezajímá. Víme, že pro jeho tvorbu potřebuje továrna nějaký atribut a to, jestli pak ještě další tři přidá, nebo ne, nám může být úplně jedno. Kdo stále ještě nevěří, že je tento postup výhodný, nechť si vyzkouší vytvořit několik instancí stejného objektu (hloupý, ale názorný příklad).\n\n/--code php\n// pomocí operátoru new:\n$instance = new ConcreteObject(\'TEST\');\n$instance = new ConcreteObject(\'TEST\');\n$instance = new ConcreteObject(\'TEST\');\n$instance = new ConcreteObject(\'TEST\');\n$instance = new ConcreteObject(\'TEST\');\n\n// pomocí továrny:\n$factory = new ConcreteCreator(\'TEST\');\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n\\--\n\nA teď přidejme nový atribut - aktuální rok.\n\n/--code php\n// pomocí operátoru new:\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n$instance = new ConcreteObject(\'TEST\', date(\'Y\'));\n\n// pomocí továrny:\n$factory = new ConcreteCreator(\'TEST\', date(\'Y\'));\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n\\--\n\nKrom toho, že by mě za chvíli přestalo bavit do každého konstruktoru kopírovat nový atribut, tak jsem také mohl udělat o hodně více chyb než u továrny. Pravdou je, že jsem musel upravit ještě pár tříd:\n\n/--code php\n<?php\nclass ConcreteObject implements IObject {\n	protected $attribute;\n	protected $year;\n	public function __construct($attribute, $year) {\n		$this->attribute = $attribute;\n		$this->year = $year;\n	}\n	// ...\n}\n\nabstract class ACreator {\n	protected $attribute;\n	protected $year;\n	public function __construct($attribute, $year) {\n		$this->attribute = $attribute;\n		$this->year = $year;\n	}\n	abstract public function createConcreteObject();\n}\n\nclass ConcreteCreator extends ACreator {\n	public function createConcreteObject() {\n		$concreteObject = new ConcreteObject($this->attribute, $this->year);\n		return $concreteObject;\n	}\n}\n\\--\n\nNicméně křivka výhod při používání továrny velmi rychle překoná svým stoupáním křivku lenosti při používání operátoru new.\n\nMimochodem vzpomeňte si na \"osm návrhových přikázání\":http://www.zeminem.cz/osm-navrhovych-prikazani, kde se také říká, že máme vždy programovat vůči rozhraní, a nikdy ne vůči konkrétní implementaci, což tento návrhový vzor perfektně splňuje.',	'2012-12-27 23:52:39',	'0000-00-00 00:00:00'),
(11,	'Nette 2.1-dev CliRouter',	'Routování CLI((Command Line Interface)) aplikací je oblast, o které se v Nette moc nemluví. A když mluví, tak divně (nebo staře). Což na jednu stranu dává smysl, protože tato routa existuje už od roku 2009. Na druhou stranu je to zvláštní, protože je stále experimentální.\n\n> The unidirectional router for CLI.\n> \n> (experimental)\n\nDokonce se už mluvilo o tom, že se zruší. No snad se to nestane...\n\nProč o tom mluvím? Rád bych ukázal, jak se dá v nastávající verzi Nette tato routa použít. V nové verzi Nette se již routy nepíší do bootsrap.php jak tomu bylo (alespoň myslím) dříve. Tentokrát je v adresářové struktuře soubor router/**RouterFactory.php**, který se právě o routování postará. Tento soubor může vypadat například takto:\n\n/--code php\n<?php\n\nnamespace App;\n\nuse Nette,\n	Nette\\Application\\Routers\\RouteList,\n	Nette\\Application\\Routers\\Route,\n	Nette\\Application\\Routers\\CliRouter;\n\n/**\n * Router factory.\n */\nclass RouterFactory {\n\n	private $container;\n\n	public function __construct(Nette\\DI\\Container $container) {\n		$this->container = $container;\n	}\n\n	/**\n	 * @return \\Nette\\Application\\IRouter\n	 */\n	public function createRouter() {\n		$router = new RouteList();\n		if ($this->container->parameters[\'consoleMode\']) {\n			$router[] = new CliRouter(array(\'action\' => \'Cli:Cli:cron\'));\n		} else {\n			$router[] = new Route(\'rss.xml\', \'Front:Blog:rss\');\n			$router[] = new Route(\'user/<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'User\',\n				\'presenter\' => \'Board\',\n				\'action\' => \'default\',\n			));\n			$router[] = new Route(\'<presenter>/<action>[/<id>]\', array(\n				\'module\' => \'Front\',\n				\'presenter\' => \'Homepage\',\n				\'action\' => \'default\',\n			));\n		}\n		return $router;\n	}\n\n}\n\\--\n\nToto je reálná funkční ukázka (ze které jsem něco nepodstatného umazal). Jak je vidět, tak aplikaci mám rozdělenou na moduly, takže defaultní routa ukazuje do modulu Front, pak je k dispozici User modul, link na RSS a konečně CliRouter, který se naroutuje pouze v případě, že běží aplikace v konzolovém módu (CLI).\n\nPokud se teď přesunu k presenterové části modulu Cli, mohu zde umístit dvě třídy. Klasický BasePresenter, který bude pro jistotu kontrolovat, jestli se opravdu jedná o consoleMode například takto:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nabstract class BasePresenter extends Nette\\Application\\UI\\Presenter {\n\n	public function startup() {\n		parent::startup();\n		if (!$this->context->parameters[\'consoleMode\']) {\n			throw new Nette\\Security\\AuthenticationException;\n		}\n	}\n\n}\n\\--\n\nNo a pak už stačí jen CliPresenter, který bude dědit od BasePresenteru, takže vždy dojde ke kontrole. Zde stačí metoda action*(), která se spustí podle naroutování. V mém případě se tedy jedná o actionCron():\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\n\nclass CliPresenter extends BasePresenter {\n\n	public function actionCron() {\n		echo \'FUNGUJU!\';\n		$this->terminate();\n	}\n\n}\n\\--\n\nA teď to nejdůležitější! Aplikace se spustí pomocí terminálu jednoduchým příkazem \"<code>php index.php</code>\". Samozřejmě je nutné ukázat na index Nette aplikace. No a samozřejmě se mohu odkázat i na jinou část aplikace dopsání parametru. Pokud bych chtěl podle výše uvedených souborů přejít na hlavní stránku, stačí napsat pouze \"<code>php index.php Fron:Homepage:default</code>\".',	'2013-03-17 22:02:36',	'0000-00-00 00:00:00'),
(43,	'Testovací titulek',	'Tělo s použitím **texy**.',	'2013-07-28 14:05:25',	'2013-12-31 23:00:00'),
(44,	'Portál ZČU dočasně mimo provoz',	'Zvolit správný titulek pro webovou stránku je naprosto klíčové.\nMnozí programátoři si to neuvědomují a ti ostatní chybují.\nTitulek je jedna z nejdůležitějších věcí, podle které se\nlidé rozhodují jestli na web vstoupit, nebo ne. Proto je třeba mít\n<code>title</code> tag na každé stránce jiný a je potřeba myslet\ni na stránky, které se zase až tak často nezobrazují.\nJe totiž docela smůla, když vás google bot indexuje během profylaxe\nserverů:\n\n[* http://www.zeminem.cz/img/pictures/portal.png *]\n\nWeb má poté odpuzující titulek, i když už dávno funguje.\nNutno však říct, že je to občas problém ohlídat.\nTak alespoň to pobaví... (-:',	'2013-07-28 21:58:42',	'0000-00-00 00:00:00'),
(45,	'Testování presenterů v Nette',	'Tak toto je přesně to téma o kterém se naustále mluví, ale tím to z velké části končí.\nNemá smysl zabývat se tím, jestli testovat, nebo ne. Na to už si každý přijde sám.\nV následujících odstavcích bych rád předvedl myšlenku jak si\nušetřit pár řádek kódu při testech (\\Nette\\Tester).\n\nNezbytná teorie\n===============\n\nPro testování presenterů je zapotřebí získat továrnu na presentery PresenterFactory\na následně daný presenter vyrobit. Například takto:\n\n/--code php\n$presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\n$this->presenter = $presenterFactory->createPresenter(\'Front:Homepage\');\n\\--\n\nK tomu je zapotřebí \\Nette\\DI\\Container, který získáme například v konstruktoru, nebo\npomocí inject anotace.\n\nNásledně je třeba vytvořit požadavek, ten spustit a testovat výslednou odpověď:\n\n/--code php\n$request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\n$response = $this->presenter->run($request);\n\\--\n\nPrávě nad vrácenou odpovědí lze spustit testovací sadu, která bude testovat, \nzda byla například získána textová odpověď a tedy jestli se jedná o šablonu:\n\n/--code php\n\\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\n\\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\n\\--\n\nJe také vhodné otestovat samotný HTML kód. Již mě to párkrát upozornilo na\nnevalidní kód, což se může stát, pokud se šablona skládá z hodně include částí.\nNevalidní ve smyslu například dvojité HTML ukončovací značky:\n\n/--code php\n$html = (string)$response->getSource();\n$dom = \\Tester\\DomQuery::fromHtml($html);\n\\Tester\\Assert::true($dom->has(\'title\'));\n\\--\n\nPsaní, psaní, psaní...\n======================\n\nPředchozí teorie je zapotřebí opakovat pro každý presenter. Už jen proto, že je třeba\nvytvořit pokaždé nový požadavek. Nicméně je jasné, že to po otestování FrontModule\nzačne být lehce kopírovací nuda.\n\nJe tedy vhodné vytvořit si třídu, která ušetří spoustu řádek.\nMůj první návrh vypadá přibližně takto:\n\n/--code php\n<?php\n\nnamespace Test;\n\nclass Presenter extends \\Nette\\Object {\n\n        private $container;\n        private $presenter;\n        private $presName;\n\n        public function __construct(\\Nette\\DI\\Container $container) {\n                $this->container = $container;\n        }\n\n        /**\n         * @param $presName string Fully qualified presenter name.\n         */\n        public function init($presName) {\n                $presenterFactory = $this->container->getByType(\'Nette\\Application\\IPresenterFactory\');\n                $this->presenter = $presenterFactory->createPresenter($presName);\n                $this->presenter->autoCanonicalize = FALSE;\n                $this->presName = $presName;\n        }\n\n        public function test($action, $method = \'GET\', $params = array(), $post = array()) {\n                $params[\'action\'] = $action;\n                $request = new \\Nette\\Application\\Request($this->presName, $method, $params, $post);\n                $response = $this->presenter->run($request);\n                return $response;\n        }\n\n        public function testAction($action, $method = \'GET\', $params = array(), $post = array()) {\n                $response = $this->test($action, $method, $params, $post);\n\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\TextResponse);\n                \\Tester\\Assert::true($response->getSource() instanceof \\Nette\\Templating\\ITemplate);\n\n                $html = (string)$response->getSource();\n                $dom = \\Tester\\DomQuery::fromHtml($html);\n                \\Tester\\Assert::true($dom->has(\'title\'));\n\n                return $response;\n        }\n\n        public function testForm($action, $method = \'POST\', $post = array()) {\n                $response = $this->test($action, $method, $post);\n\n                \\Tester\\Assert::true($response instanceof \\Nette\\Application\\Responses\\RedirectResponse);\n\n                return $response;\n        }\n\n}\n\\--\n\nTestování samotných presenterů je pak již otázkou několika málo řádek:\n\n/--code php\n<?php\n\nnamespace Test;\n\n$container = require __DIR__ . \'/../bootstrap.php\';\n\nclass HomepagePresenterTest extends \\Tester\\TestCase {\n\n        public function __construct(\\Nette\\DI\\Container $container) {\n                $this->tester = new \\Test\\Presenter($container);\n        }\n\n        public function setUp() {\n                $this->tester->init(\'Front:Homepage\');\n        }\n\n        public function testRenderDefault() {\n                $this->tester->testAction(\'default\');\n        }\n\n}\n\nid(new HomepagePresenterTest($container))->run();\n\\--\n\nTakto chápu testování presenterů v Nette já. Dále budu směrovat testy tak, abych nemusel psát téměř nic\na měl jsem otestováno téměř všechno. Myslím si, že toto je jediná cesta jak se přinutit k testování.\nNelze se již vymlouvat na to, že je to spousta psaní navíc. Není.',	'2013-07-28 22:36:38',	'0000-00-00 00:00:00'),
(46,	'CRON validátor',	'A jak už to tak bývá, tak opět ohnutý pro Nette. Tentokráte inspirovaný řešením ISPConfigu.\n\nMůžeš tohle, nesmíš tamto\n=========================\n\nSamotný CRON zápis je velmi rozmanitý a proto se omezím pouze na základní požadavky:\n\n1)  obecně jsou povolené znaky <code>0-9</code>, <code>čárka</code>, <code>*</code>, <code>-</code>, <code>/</code>\n2)  <code>čárka</code>, <code>-</code> a <code>/</code> nesmí být nikdy vedle sebe\n3)  <code>x</code>, <code>x-y</code>, <code>x/y</code>, <code>x-y/z</code>, <code>*/x</code>, kde x,y,z jsou čísla z povolených časových rozsahů\n4)  povolený rozsah pro minuty: <strong>0-59</strong>\n5)  povolený rozsah pro hodiny: <strong>0-23</strong>\n6)  povolený rozsah pro dny měsíce: <strong>1-31</strong>\n7)  povolený rozsah pro měsíce: <strong>1-12</strong>\n8)  povolený rozsah pro dny v týdnu: <strong>0-6</strong>\n\nTo je myslím slušný výčet pravidel pro zvalidování jednoho příkazu.\nÚkolem tohoto článku není ukázat jak tvořit a zpracovávat formulář, ale bude vhodné\numístit sem celý kód alespoň vytvoření:\n\n/--code php\n/**\n  * @return Nette\\Application\\UI\\Form\n  */\nprotected function createComponentAddCron() {\n	$form = new Nette\\Application\\UI\\Form;\n	$form->addProtection();\n	$form->addText(\'minutes\', \'Minuty:\')\n		->addRule(\\Fresh\\ValidateCron::MINUTES, \'Nevalidní CRON zápis - minuty.\');\n	$form->addText(\'hours\', \'Hodiny:\')\n		->addRule(\\Fresh\\ValidateCron::HOURS, \'Nevalidní CRON zápis - hodiny.\');\n	$form->addText(\'mdays\', \'Dny měsíce:\')\n		->addRule(\\Fresh\\ValidateCron::MDAYS, \'Nevalidní CRON zápis - mdays.\');\n	$form->addText(\'months\', \'Měsíce:\')\n		->addRule(\\Fresh\\ValidateCron::MONTHS, \'Nevalidní CRON zápis - měsíce.\');\n	$form->addText(\'wdays\', \'Dny v týdnu:\')\n		->addRule(\\Fresh\\ValidateCron::WDAYS, \'Nevalidní CRON zápis - wdays.\');\n	$form->addText(\'command\', \'Příkaz:\')\n		->setRequired(\'Vyplňte prosím příkaz, který bude CRON spouštět.\');\n	$form->addSubmit(\'save\', \'Přidat nový CRON\');\n	$form->onSuccess[] = $this->addCronSucceeded;\n	return $form;\n}\n\\--\n\nA rovnou bez hloupých povídání celý validátor:\n\n/--code php\n<?php\n\nnamespace Fresh;\n\n/**\n * Class ValidateCron - inspired by ISPConfig\n * @package Fresh\n */\nclass ValidateCron extends \\Nette\\Object {\n\n        const MINUTES = \'\\Fresh\\ValidateCron::validateMinutes\';\n        const HOURS = \'\\Fresh\\ValidateCron::validateHours\';\n        const MDAYS = \'\\Fresh\\ValidateCron::validateMdays\';\n        const MONTHS = \'\\Fresh\\ValidateCron::validateMonths\';\n        const WDAYS = \'\\Fresh\\ValidateCron::validateWdays\';\n\n        public static function validateMinutes(\\Nette\\Forms\\IControl $control) {\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 59);\n        }\n\n        public static function validateHours(\\Nette\\Forms\\IControl $control) {\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 23);\n        }\n\n        public static function validateMdays(\\Nette\\Forms\\IControl $control) {\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 31);\n        }\n\n        public static function validateMonths(\\Nette\\Forms\\IControl $control) {\n                if($control->getValue() != \'@reboot\') { // allow value @reboot in month field\n                        return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 1, 12);\n                } else {\n                        return TRUE;\n                }\n        }\n\n        public static function validateWdays(\\Nette\\Forms\\IControl $control) {\n                return \\Fresh\\ValidateCron::validateTimeFormat($control->getValue(), 0, 6);\n        }\n\n        private static function validateTimeFormat($value, $min_entry = 0, $max_entry = 0) {\n                if (preg_match(\"\'^[0-9\\-\\,\\/\\*]+$\'\", $value) == false) { // allowed characters are 0-9, comma, *, -, /\n                        return FALSE;\n                } elseif (preg_match(\"\'[\\-\\,\\/][\\-\\,\\/]\'\", $value) == true) { // comma, - and / never stand together\n                        return FALSE;\n                }\n                $time_list = explode(\",\", $value);\n                foreach ($time_list as $entry) {\n                        // possible value combinations:\n                        // x               =>      ^(\\d+)$\n                        // x-y             =>      ^(\\d+)\\-(\\d+)$\n                        // x/y             =>      ^(\\d+)\\/([1-9]\\d*)$\n                        // x-y/z           =>      ^(\\d+)\\-(\\d+)\\/([1-9]\\d*)$\n                        // */x             =>      ^\\*\\/([1-9]\\d*)$\n                        // combined regex  =>      ^(\\d+|\\*)(\\-(\\d+))?(\\/([1-9]\\d*))?$\n                        if (preg_match(\"\'^(((\\d+)(\\-(\\d+))?)|\\*)(\\/([1-9]\\d*))?$\'\", $entry, $matches) == false) {\n                                return FALSE;\n                        }\n                        // matches contains:\n                        // 1       =>      * or value or x-y range\n                        // 2       =>      unused\n                        // 3       =>      value if [1] != *\n                        // 4       =>      empty if no range was used\n                        // 5       =>      2nd value of range if [1] != * and range was used\n                        // 6       =>      empty if step was not used\n                        // 7       =>      step\n                        if ($matches[1] == \"*\") {\n                                // not to check\n                        } else {\n                                if ($matches[3] < $min_entry || $matches[3] > $max_entry) { // check if value is in allowed range\n                                        return FALSE;\n                                } elseif (isset($matches[4]) && ($matches[5] < $min_entry || $matches[5] > $max_entry || $matches[5] <= $matches[3])) {\n                                        // check if value is in allowed range and not less or equal to first value\n                                        return FALSE;\n                                }\n                        }\n                        if (isset($matches[6]) && ($matches[7] < 2 || $matches[7] > $max_entry - 1)) { // check if step value is valid\n                                return FALSE;\n                        }\n                } // end foreach entry loop\n                return TRUE;\n        }\n\n}\n\\--\n\nValidátorem navrácené errory lze vykreslit například takto ručně (nově v DEV Nette):\n\n/--code html\n{form $form}\n\n<ul class=\"error\" n:if=\"$form->allErrors\">\n        <li n:foreach=\"$form->allErrors as $error\">{$error}</li>\n</ul>\n\n...\n\n{/form}\n\\--',	'2013-07-28 22:53:32',	'0000-00-00 00:00:00'),
(47,	'Třída pro připojení k FIO API',	'Další užitečný úryvek, který je škoda nechat ležet v Git repozitářích.\nA opět uzpůsobený pro používání s Nette FW.\n\nNedávno jsem psal o tom, jak používat CLI router v Nette (http://www.zeminem.cz/nette-2-1-dev-clirouter).\nPrávě pomocí tohoto routeru je vhodné kontrolovat bankovní výpisy - například pomocí cronu:\n\n/--code php\n<?php\n\nnamespace App\\CliModule;\n\nuse Nette;\nuse Nette\\Diagnostics\\Debugger;\n\n/**\n * Class CliPresenter\n * @package App\\CliModule\n */\nclass CliPresenter extends BasePresenter {\n\n        /** @var \\Fio @inject */\n        public $fio;\n        ...\n\n        public function actionCron() {\n                $this->checkFio(); // FIO vs. nezaplacené objednávky\n                ...\n                $this->terminate();\n        }\n\n        /**\n         * Zkontroluje bankovní účet, porovná s databází a zaplacené objednávky změní na status PAID.\n         */\n        private function checkFio() {\n                try {\n                        $transactions = $this->fio->transactions();\n                        $unpaid = $this->orders->selectUnpaidOrders(); //získání nezaplacených objednávek\n                        //array_intersect() - zde samotné zpracování\n                        ...\n                } catch (\\Exception $exc) {\n                        Debugger::log($exc->getMessage() . \' FILE: \' . $exc->getFile() . \' on line: \' . $exc->getLine(), Debugger::WARNING);\n                        echo $exc->getMessage() . EOL;\n                }\n        }\n}\n\\--\n\nK tomu se hodí právě následující třída:\n\n/--code php\n<?php\n\n/**\n * Class Fio\n */\nclass Fio extends \\Nette\\Object {\n\n        private $token;\n        private $rest_url = \'https://www.fio.cz/ib_api/rest/\';\n\n        /**\n         * @param string $token SECURE\n         */\n        public function __construct($token) {\n                $this->token = $token;\n        }\n\n        /**\n         * Pohyby na účtu za určené období.\n         * JSON only!\n         * @param string $from\n         * @param string $to\n         */\n        public function transactions($from = \'-1 month\', $to = \'now\') {\n                $from = \\Nette\\DateTime::from($from)->format(\'Y-m-d\');\n                $to = \\Nette\\DateTime::from($to)->format(\'Y-m-d\');\n                $url = $this->rest_url . \'periods/\' . $this->token . \'/\' . $from . \'/\' . $to . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Oficiální výpisy pohybů z účtu.\n         * JSON only!\n         * @param $id\n         * @param null $year\n         * @return array|mixed\n         */\n        public function transactionsByID($id, $year = NULL) {\n                if ($year === NULL) {\n                        $year = date(\'Y\');\n                }\n                $url = $this->rest_url . \'by-id/\' . $this->token . \'/\' . $year . \'/\' . $id . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * Pohyby na účtu od posledního stažení.\n         * JSON only!\n         * @return array|mixed\n         */\n        public function transactionsLast() {\n                $url = $this->rest_url . \'last\' . $this->token . \'/transactions.json\';\n                return $this->parseJSON($this->download($url));\n        }\n\n        /**\n         * @param $url\n         * @return mixed\n         * @throws \\Exception\n         */\n        private function download($url) {\n                if (!extension_loaded(\'curl\')) {\n                        throw new \\Exception(\'Curl extension, does\\\'t loaded.\');\n                }\n                $curl = curl_init();\n                curl_setopt($curl, CURLOPT_URL, $url);\n                curl_setopt($curl, CURLOPT_HEADER, FALSE);\n                curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n                curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);\n                $result = curl_exec($curl);\n                return $result;\n                //return file_get_contents($url); //ALTERNATIVE\n        }\n\n        /**\n         * @param $data\n         * @return array|mixed\n         */\n        private function parseJSON($data) {\n                $json = json_decode($data);\n                if($json === NULL) {\n                        //Moc ryhlé požadavky na Fio API\n                        throw new \\Exception(\'Fio API overheated. Please wait...\');\n                        //Když se posílá stále moc požadavků, tak se to z Exception nikdy nevyhrabe. Musí se opravdu počkat.\n                }\n                if(!$json->accountStatement->transactionList) {\n                        return $json; // There are no transactions (header only)\n                }\n                $payments = array();\n                foreach ($json->accountStatement->transactionList->transaction as $row) {\n                        $out = array();\n                        foreach ($row as $column) {\n                                if ($column) {\n                                        $out[$column->id] = $column->value; //v $column->name je název položky\n                                        /*\n                                         * 0  - Datum\n                                         * 1  - Částka (!)\n                                         * 5  - Variabilní symbol (!)\n                                         * 14 - Měna (!)\n                                         * Hodnoty (!) se musí použít ke kontrole správnosti...\n                                         */\n                                }\n                        }\n                        array_push($payments, $out);\n                }\n                return $payments;\n        }\n\n}\n\\--\n\nS tím, že je zapotřebí předat FIO klíč z neonu. FIO třída se automaticky injectuje, tzn. že i konstruktor\ntéto třídy bude doplněn automaticky. Je jen zapotřebí přidat do neonu onu konfiguraci:\n\n/--code neon\nparameters:\n	fio_token: \'\' #token pro přístup do FIO banky\n    \n...\n\nservices:\n	- Fresh\\Fio(token: %fio_token%)\n    \n...\n\\--\n\nBylo by vhodné upozornit na fakt, že se jedná pouze o read-only přístup, tzn. že neexistují žádné funkce\npro zápis (ačkoliv existuje něco jako datumová zarážka). Díky tomu je možné použít takovéto nízkoúrovňové\nzabezpečení pomocí jednoho tokenu.',	'2013-07-29 10:36:44',	'0000-00-00 00:00:00'),
(49,	'Using fulltext searching with InnoDB',	'Sometimes is quite useful to use InnoDB engine. \nUnfortunately InnoDB is good for tables with foreign keys, but useless for fulltext search. \nYou can\'t create fulltext index on InnoDB tables, but you can create this index on MyISAM tables. \nUnfortunately you can\'t create foreign keys on MyISAM. It\'s starting to be quite embarassing. \nLet me show you how to search via fulltext on InnoDB tables.\n\nIn fact it\'s not possible to use fulltext index on InnoDB tables, \nbut there is possible workaround. At first you need a classic InnoDB structure. \nFor example database of  blog:\n\n/--code sql\nSET NAMES utf8;\nSET foreign_key_checks = 0;\nSET time_zone = \'SYSTEM\';\nSET sql_mode = \'NO_AUTO_VALUE_ON_ZERO\';\n\nDROP TABLE IF EXISTS `posts`;\nCREATE TABLE `posts` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `title` text NOT NULL,\n  `body` text NOT NULL,\n  `date` datetime NOT NULL,\n  `release_date` datetime NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `title_3` (`title`(200))\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nDROP TABLE IF EXISTS `tags`;\nCREATE TABLE `tags` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(50) NOT NULL,\n  `color` varchar(6) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nDROP TABLE IF EXISTS `posts_tags`;\nCREATE TABLE `posts_tags` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `tag_id` int(11) NOT NULL,\n  `post_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `tag_id` (`tag_id`),\n  KEY `post_id` (`post_id`),\n  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),\n  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\\--\n\nNow we have pretty simple database structure with InnoDB tables with foreign keys. \nIt would be nice to be able search on database table **posts** using fulltext search:\n\n/--code sql\nSELECT *\nFROM posts\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE);\n\\--\n\nBut it is not possible. It returns something like:\n>   Error in query: The used table type doesn\'t support FULLTEXT indexes\n\nLet\'s create another one table with triggers and fulltext indexes. \nWe need to create mirror table. For example:\n\n/--code sql\nDROP TABLE IF EXISTS `mirror_posts`;\nCREATE TABLE `mirror_posts` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `title` text NOT NULL,\n  `body` text NOT NULL,\n  PRIMARY KEY (`id`),\n  FULLTEXT KEY `title_body` (`title`,`body`),\n  FULLTEXT KEY `title` (`title`),\n  FULLTEXT KEY `body` (`body`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\n\\--\n\nAnd than we need to create triggers:\n\n/--code sql\nDELIMITER ;;\n\nCREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW\nINSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body);;\n\nCREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW\nUPDATE mirror_posts SET\n    id = NEW.id,\n    title = NEW.title,\n    body = NEW.body\nWHERE id = OLD.id;;\n\nCREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW\nDELETE FROM mirror_posts WHERE id = OLD.id;;\n\\--\n\nIt means, that we copy all of events and data from table **posts** to the table **mirror_posts**.\nFinally we can use more complex fulltext search feature:\n\n/--code sql\nSELECT *\nFROM mirror_posts\nWHERE MATCH(title, body) AGAINST (\'something\' IN BOOLEAN MODE)\nORDER BY 5 * MATCH(title) AGAINST (\'something\') + MATCH(body) AGAINST (\'something\') DESC;\n\\--\n\nAs I said, this is just workaround, not solution. \nSometimes it\'s bad practice, because you need copy of indexed columns. \nBut it works. And for small blogs it\'s sufficient.',	'2013-07-29 21:37:51',	'0000-00-00 00:00:00');

DELIMITER ;;

CREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW
INSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body);;

CREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW
UPDATE mirror_posts SET
    id = NEW.id,
    title = NEW.title,
    body = NEW.body
WHERE id = OLD.id;;

CREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW
DELETE FROM mirror_posts WHERE id = OLD.id;;

DELIMITER ;

DROP TABLE IF EXISTS `posts_tags`;
CREATE TABLE `posts_tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_id` int(11) NOT NULL,
  `post_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `tag_id` (`tag_id`),
  KEY `post_id` (`post_id`),
  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),
  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `posts_tags` (`id`, `tag_id`, `post_id`) VALUES
(98,	42,	10),
(99,	42,	9),
(101,	41,	11),
(102,	42,	11),
(104,	43,	4),
(105,	41,	45),
(106,	42,	45),
(107,	44,	45),
(108,	42,	46),
(109,	41,	46),
(110,	41,	47),
(111,	42,	47),
(114,	45,	49);

DROP TABLE IF EXISTS `tags`;
CREATE TABLE `tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `color` varchar(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `tags` (`id`, `name`, `color`) VALUES
(41,	'nette',	'106dcf'),
(42,	'php',	'aa16b1'),
(43,	'html',	'1c7640'),
(44,	'tester',	'9f1857'),
(45,	'sql',	'7608de');

-- 2013-07-29 22:04:35
